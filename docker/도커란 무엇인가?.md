## 1. Docker의 정의

도커는 어떠한 프로그램도 `컨테이너로 만들 수 있고 어디서든 돌아갑니다.`
가상머신과의 차이점은 가상머신처럼 독립적으로 실행되지만, 더 빠르고 더 쉽고, 더 효율적입니다.

## 2. Docker의 등장 배경

#### 문서관리

예전에는 서버를 운영하기 위해서 문서로 서버 운영방법을 기록했지만, 시간이 지나면서 문서의 정확성과 서버 업데이트와 관련된 이력들을 관리하기가 힘들어지는 문제가 있었습니다. 이러한 문제점들을 해결하기 위해 상태관리 도구가 등장했습니다.

#### 상태관리 도구

상태관리 도구는 프로그램을 실행할 때 프로그램이 참조하는 설정파일을 코드로 작성하여 협업도 하고 버전관리도 할 수 있엇습니다. 즉 문서보다는 코드로 서버 운영을 하였습니다. 하지만 단점은 러닝커브가 높고, 한 서버에서 다른 버전 여러개를 설치하는게 어려웠습니다.

#### 가상머신

그래서 등장한게 가상머신이라고 하는데, 가상머신은 한 서버에 여러개 설치가 쉽고, 현재 상태를 스냅샷으로 저장할 수도 있었지만, 처음부터 셋팅하는 방법이나 이미지 공유를 하기 힘들었습니다. 결정적으로는 너무 느렸습니다.

#### 자원격리

리눅스 가상화 기술을 사용하여 프로세스, 파일, 디렉토리를 가상으로 분리하였습니다.  또한 CPU, Memory, I/O도 그룹별로 제한을 하였는데, 이렇게 함으로써 속도도 빠르고 효율적인  서버 관리가 가능했지만, 이러한 기술을 익히기에는 기업에서 너무 어려웠기 때문에 주로 IT 공룡인 구글급 회사에서나 사용이 가능한 기술인게 단점이였습니다.

> 실제로 구글은 리눅스 가상화 기술을 사용하여 서버를 관리하였다고 합니다.

#### 도커의 등장

위의 4가지 방법들은 모두 서버관리에 대한 시행착오를 겪으면서 등장한 기술로 이러한 문제점들을 해소하기 위해 2013년 Docker가 첫등장 하였습니다. `Docker는 컨테이너라는 격리된 환경에서 작동하는 프로세스`를 오픈소스로 공개하였고 리눅스 커널의 여러 기술을 활용하여 `하드웨어 가상화 기술보다 가볍고 이미지 단위로 프로세스 실행환경을 구성하였습니다.`


## 3. Docker의 특징

- 확장성 / 이식성
    - 도커가 설치되어 있다면 어디서든 컨테이너 실행이 가능합니다.
    - 특정 회사나 서비스에 종속적이지 않습니다.
    - 쉽게 개발서버를 만들 수 있고 테스트 서버 생성도 간편합니다.
- 표준성
    - 도커를 사용하지 않는 경우 ruby, nodejs, java, go, php로 만든 서비스들의 배포방식은 제각각 다릅니다.
    - 컨테이너라는 표준으로 서버를 배포하므로 모든 서비스들의 배포과정이 동일해집니다.
- 이미지 
    - 이미지에서 컨테이너를 생성하기 때문에 반드시 이미지를 만드는 과정이 필요합니다.
    - Dockerfile을 이용하여 이미지를 만들고 처음부터 재현이 가능합니다.
    - 빌드 서버에서 이미지를 만들면 해당 이미지를 이미지 저장소에 저장하고 운영서버에서 이미지를 불러옵니다.
- 설정관리
    - 설정은 보통 환경변수로 제어합니다.
    - MYSQL_PASS=password와 같이 컨테이너를 띄울때 환경변수를 같이 지정합니다.
    - 하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어져야 합니다.
- 자원관리
    - 컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화됩니다.
    - 업로드 파일을 외부 스토리지와 링크하여 사용하거나 S3와 같은 별도의 저장소가 필요합니다.
    - 세션이나 캐시를 memcached나 redis와 같은 외부로 분리


## 도커의 기본 명령어

### run - 컨테이너 실행

```docker
docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
```

| 옵션 | 설명 |
|:----------|:----------|
| -d | detached mode (백그라운드 모드) |
| -p | 호스트와 컨테이너 포트를 연결 |
| -v | 호스트와 컨테이너의 디렉토리를 연결 |
| -e | 컨테이너 내에서 사용할 환경변수 설정 |
| --name | 컨테이너 이름 설정 |
| --rm | 프로세스 종료 시 컨테이너 자동 제거 |
| -it | -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션 |
| -network | 네트워크 연결 |
| --restart always | 컨테이너의 재시작 관련 정책으로 리눅스 시스템에서 도커 서비스가 작동할 때 컨테이너를 자동으로 시작 |


`run` 명령어를 사용하면 사용할 이미지가 저장되어 있는지 확인하고 없다면 도커 허브에서 다운로드(pull) 한 후 컨테이너를 `생성하고 시작`합니다.

컨테이너는 정상적으로 실행됬지만 만약 무엇을 해야할지 명령어를 전달하지 않으면 컨테이너는 생성되자마자 종료됩니다. 컨테이너는 `프로세스`이기 때문에 실행중인 프로세스가 없으면 컨테이너는 종료됩니다.

```docker
ex) docker run ubuntu:20.04 // 이 경우 컨테이너 생성 후 종료됩니다. 
```

### /bin/sh 실행하기

```docker
docker run --rm -it ubuntu:20.04 /bin/sh
```

도커 컨테이너 내부에 들어가기 위해 sh를 실행하고 키보드 입력을 위해 -it 옵션을 줍니다. 추가적으로 프로세스가 종료되면 컨테이너가 자동으로 삭제되도록 --rm 옵션도 추가하였습니다.

> --rm 옵션이 없다면 컨테이너가 종료되더라도 삭제되지 않고 남아 있어 수동으로 삭제해야 합니다.

### exec 명령어

exec 명령어는 run 명령어와 달리 실행중인 도커 컨테이너에 접속할 때 사용하며 컨테이너 안에 ssh server등을 설치하지 않고 exec 명령어로 접속합니다.

### Docker network create 명령어

도커 컨테이너끼리 이름으로 통신할 수 있는 가상 네트워크를 만듭니다.

```docker
docker network create app-network
```

app-network라는 이름으로 wordpress와 mysql이 통신할 네트워크를 만듭니다.

### Docker network connect 명령어

기존에 생성된 컨테이너에 네트워크를 추가합니다.

```docker
docker network connect app-network mysql
```

`mysql` 컨테이너에 네트워크를 추가합니다.

```docker
docker run -d -p 8080:80 \
 --network=app-network \
 -e WORDPRESS_DB_HOST=mysql \
 -e WORDPRESS_DB_NAME=wp \
 -e WORDPRESS_DB_USER=wp \
 -e WORDPRESS_DB_PASSWORD=wp \
 wordpress
```

워드프레스 컨테이너 생성 시 `app-network`에 속하게 하고 mysql을 이름으로 접근합니다.

### logs 명령어

```docker
docker logs [OPTIONS] CONTAINER
```

컨테이너가 정상적으로 동작하는지 확인하는 좋은 방법은 로그를 확인하는 것입니다.

기본 옵션과 -f, --tail 옵션을 살펴봅니다. -f를 주면 로그를 계속 추적하여 볼 수 있습니다.


### volume mount (-v) 명령어

호스트와 컨테이너의 디렉토리를 연결합니다. 만약 서버에 문제가 생겨서 컨테이너가 종료될 경우 컨테이너에서 생성한 데이터들도 같이 사라지게 됩니다. 이러한 문제를 해결하기 위해 호스트 서버에 디렉토리를 연결하면 컨테이너를 다시 생성 후 실행할 경우 기존 데이터 복구가 가능합니다.

```docker
docker run -d -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=true --network=app-network --name mysql -v /Users/limjun-young/mysql_test:/var/lib/mysql mysql:5.7
```

#### 실행결과 

![image](https://user-images.githubusercontent.com/22395934/119367781-453f9d00-bced-11eb-9137-5a071b96a642.png)

mysql 관련 파일들이 호스트 디렉토리에 생성된 것을 확인할 수 있었습니다.
