# 데이터 저장 구조 및 IO 메커니즘

I/O 튜닝이 곧 SQL 튜닝이라고 볼 수 있습니다. SQL 튜닝의 원리를 제대로 이해하려면 I/O에 대한 이해가 중요할 수밖에 없습니다. 

보통 디스크 I/O가 SQL 성능을 좌우한다고 합니다. I/O Call 속도는 Single Block I/O 기준으로 평균 10ms쯤 됩니다. 초당 100 블록쯤 읽는 셈입니다. 큰 캐시를 가진 SAN 스토리지는  4~8ms쯤 됩니다.  스토리지 성능이 빨리지고 있지만, 아직도 부족합니다. 전반적으로 I/O 튜닝이 안된 시스템이라면, 수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어납니다. 10초가 아니라 20초를 기다려야 할 수도 있습니다. SQL이 느린 이유가 여기 있습니다. 

## 데이터베이스 저장 구조

데이터를 저장하려면 먼저 테이블스페이스를 생성해야 합니다. 테이블스페이스는 세그먼트를 담는 컨테이너로서, 여러 개의 `데이터파일(디스크 상의 물리적인 OS 파일)`로 구성됩니다.

### 테이블스페이스 구조 

![테이블스페이스_구조](https://user-images.githubusercontent.com/22395934/126488839-49344a6f-e6c9-4753-b63c-0ee38fd30fa1.png)

- 익스텐트: 공간을 확장하는 단위, 연속된 블록의 집합
- 블록: 데이터를 읽고 쓰는 단위
- 세그먼트: 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블스페이스: 세그먼트를 담는 컨테이너
- 데이터파일: 디스크 상의 물리적인 OS 파일

세그먼트는 위 이미지처럼 여러 익스텐트로 구성됩니다. 파티션 구조가 아니라면 테이블도 하나의 세그먼트요, 인덱스도 하나의 세그먼트입니다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장합니다.

익스텐트는 공간을 확장하는 단위입니다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받습니다. 익스텐트는 연속된 블록의 집합이기도 합니다. 

테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당 받습니다. 익스텐트는 연속된 블록들의 집합이기도 합니다. 익스텐트 단위로 공간을 확장하지만, 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록입니다. 한 블록은 하나의 테이블이 독점합니다. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드입니다.

세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다고 했지만, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있습니다. 오히려 서로 다른 데이터 파일에 위치할 가능성이 더 높습니다. 하나의 테이블스페이스를 여러 데이터 파일로 구성하면 파일 경합을 줄일 수 있는 이점이 있습니다. 

> 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간을 보장하지 않습니다.

```sql
select segment_type, tablespace_name, extend_id, file_id, block_id, blocks
from dba_extends
where owner = USER
and segment_name = 'MY_SEGMENT'
order by extent_id;
```

## DBA란?

모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖습니다. 이 주소값을 `DBA`라고 부릅니다. 데이터를 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 DBA부터 확인해야 합니다.

인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 이용합니다. ROWID는 DBA + 로우(블록내 순번)로 구성되며 이를 분해하면 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있습니다.

데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽습니다. 심지어 1Byte짜리 컬럼 하나만 읽고 싶어도 블록을 통째로 읽습니다.


## 논리적 I/O vs 물리적 I/O

### DB 버퍼캐시

다시 강조하지만, 디스크 I/O가 SQL 성능을 결정합니다. SQL을 수행하는 과정에서 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에 읽는 것은 비효율적입니다. 모든 DBMS에 데이터 캐싱 메커니즘이 필수인 이유입니다.

데이터 버퍼의 존재 이유는 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있습니다.

서버 프로세스와 데이터파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색합니다. 운 좋게 캐시에서 블록을 찾는다면 바쁜 시간에 프로세스가 잠을 자지 않아도 됩니다. 운이 없어 캐시에서 못 찾아도 한번은 I/O Call을 하고 잠을 자겠지만, 같은 블록을 두 번째 읽을 때부터는 잠을 자지 않아도 됩니다. 버퍼캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 봅니다.

논리적 블록 I/O는 SQL 문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 말합니다. 

물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말합니다. SQL 처리 도중 읽어야 할 블록을 버퍼캐시에 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중 일부를 물리적 I/O 합니다.

메모리 I/O는 전기적 신호인 데 반해, 디스크 I/O는 엑세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느립니다. 보통 10,000배쯤 느립니다. 디스크 경합이 심할 때는 더 느립니다.

