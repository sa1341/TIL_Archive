# 데이터 저장 구조 및 IO 메커니즘

I/O 튜닝이 곧 SQL 튜닝이라고 볼 수 있습니다. SQL 튜닝의 원리를 제대로 이해하려면 I/O에 대한 이해가 중요할 수밖에 없습니다. 

보통 디스크 I/O가 SQL 성능을 좌우한다고 합니다. I/O Call 속도는 Single Block I/O 기준으로 평균 10ms쯤 됩니다. 초당 100 블록쯤 읽는 셈입니다. 큰 캐시를 가진 SAN 스토리지는  4~8ms쯤 됩니다.  스토리지 성능이 빨리지고 있지만, 아직도 부족합니다. 전반적으로 I/O 튜닝이 안된 시스템이라면, 수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어납니다. 10초가 아니라 20초를 기다려야 할 수도 있습니다. SQL이 느린 이유가 여기 있습니다. 

## 데이터베이스 저장 구조

데이터를 저장하려면 먼저 테이블스페이스를 생성해야 합니다. 테이블스페이스는 세그먼트를 담는 컨테이너로서, 여러 개의 `데이터파일(디스크 상의 물리적인 OS 파일)`로 구성됩니다.

### 테이블스페이스 구조 

![테이블스페이스_구조](https://user-images.githubusercontent.com/22395934/126488839-49344a6f-e6c9-4753-b63c-0ee38fd30fa1.png)

- 익스텐트: 공간을 확장하는 단위, 연속된 블록의 집합
- 블록: 데이터를 읽고 쓰는 단위
- 세그먼트: 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블스페이스: 세그먼트를 담는 컨테이너
- 데이터파일: 디스크 상의 물리적인 OS 파일

세그먼트는 위 이미지처럼 여러 익스텐트로 구성됩니다. 파티션 구조가 아니라면 테이블도 하나의 세그먼트요, 인덱스도 하나의 세그먼트입니다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장합니다.

익스텐트는 공간을 확장하는 단위입니다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받습니다. 익스텐트는 연속된 블록의 집합이기도 합니다. 

테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당 받습니다. 익스텐트는 연속된 블록들의 집합이기도 합니다. 익스텐트 단위로 공간을 확장하지만, 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록입니다. 한 블록은 하나의 테이블이 독점합니다. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드입니다.

세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다고 했지만, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있습니다. 오히려 서로 다른 데이터 파일에 위치할 가능성이 더 높습니다. 하나의 테이블스페이스를 여러 데이터 파일로 구성하면 파일 경합을 줄일 수 있는 이점이 있습니다. 

> 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간을 보장하지 않습니다.

```sql
select segment_type, tablespace_name, extend_id, file_id, block_id, blocks
from dba_extends
where owner = USER
and segment_name = 'MY_SEGMENT'
order by extent_id;
```

## DBA란?

모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖습니다. 이 주소값을 `DBA`라고 부릅니다. 데이터를 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 DBA부터 확인해야 합니다.

인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 이용합니다. ROWID는 DBA + 로우(블록내 순번)로 구성되며 이를 분해하면 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있습니다.

데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽습니다. 심지어 1Byte짜리 컬럼 하나만 읽고 싶어도 블록을 통째로 읽습니다.


## 논리적 I/O vs 물리적 I/O

### DB 버퍼캐시

다시 강조하지만, 디스크 I/O가 SQL 성능을 결정합니다. SQL을 수행하는 과정에서 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에 읽는 것은 비효율적입니다. 모든 DBMS에 데이터 캐싱 메커니즘이 필수인 이유입니다.

데이터 버퍼의 존재 이유는 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있습니다.

서버 프로세스와 데이터파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색합니다. 운 좋게 캐시에서 블록을 찾는다면 바쁜 시간에 프로세스가 잠을 자지 않아도 됩니다. 운이 없어 캐시에서 못 찾아도 한번은 I/O Call을 하고 잠을 자겠지만, 같은 블록을 두 번째 읽을 때부터는 잠을 자지 않아도 됩니다. 버퍼캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 봅니다.

논리적 블록 I/O는 SQL 문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 말합니다. 

물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말합니다. SQL 처리 도중 읽어야 할 블록을 버퍼캐시에 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중 일부를 물리적 I/O 합니다.

메모리 I/O는 전기적 신호인 데 반해, 디스크 I/O는 엑세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느립니다. 보통 10,000배쯤 느립니다. 디스크 경합이 심할 때는 더 느립니다.

## Table Full Scan vs Index Range Scan

테이블에 저장된 데이터를 읽는 방식은 두 가지입니다. 테이블 전체를 스캔해서 읽는 방식과 인덱스를 이용해서 읽는 방식입니다. 전자는 `Table Full Scan`이고, 후자는 `Index Range Scan` 방식입니다. 

인덱스를 이용한 테이블 엑세스는 인덱스에서 `일정량`을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식입니다. ROWID는 테이블 레코드가 디스크 상에 어디 저장됐는지를 가르키는 위치 정보입니다.

테이블 풀 스캔 방식은 시퀀셜 엑세스와 Multiblock I/O 방식으로 디스크 블록을 읽습니다. 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고, 캐시에서 못 찾으면 `한 번의 수면(I/O call)`을 통해 인접한 수십 ~ 수백  개 블록을 한꺼번에 I/O하는 메커니즘입니다. 이방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아집니다.

시퀀셜 엑세스와 Multiblock I/O가 아무리 좋아도 수십 ~ 수백 건의 소량 데이터를 찾을 때 수백만 ~ 수천만 건 데이터를 스캔하는 건 비효율적입니다. 큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 합니다.

`Index Range Scan`을 통한 테이블 엑세스는 랜덤 엑세스와 Single Block I/O 방식으로 디스크 블록을 읽습니다. 캐시에서 블록을 못 찾으면 레코드 하나를 읽기 위해 매번 잠을 자는 I/O 메커니즘입니다. 따라서 많은 데이터를 읽을 때는 `Table Full Scan`보다 불리합니다. 열심히 일해야 할 프로세스가 잠을 자는데, 스토리지 성능이 좋아도 의미가 없습니다. 게다가 이 방식은 읽었던 블록을 반복해서 읽는 비효율이 있습니다. 많은 데이터를 읽을 때 물리적인 블록 I/O뿐만 아니라 논리적인 I/O 측면에서도 불리하다는 애기입니다. 한 블록에 평균 레코드가 500개가 있다면, 같은 블록을 최대 500번 읽습니다. 만약 인덱스를 이용해 전체 레코드를 엑세스 한다면 모든 블록을 평균 500번씩 읽게 되는 셈입니다.  

위의 메커니즘들을 살펴보면 무조건 Index Range Scan 방식이 옳지는 않다고 합니다.

따라서 용도에 맞게 실행계획을 세워서 SQL을 실행해야 된다고 생각합니다.

