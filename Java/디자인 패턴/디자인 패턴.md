# 디자인 패턴

객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계 없이 또는 재설계를 최소화하면서 요구 사항의 변화를 수용할 수 있도록 만들어 줍니다. 객체 지향 설계를 하다 보면, 이전과 비슷한 상황에서 사용했던 설계를 재사용하는 경우가 종종 발생합니다. 

이런 설계는 특정 상황에 맞는 해결책을 빠르게 찾을 수 있도록 도와주는데, 이렇게 반복적으로 사용되는 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖습니다.
이런 패턴을 잘 습득하면 다음과 같은 이득을 얻을 수 있게 됩니다.

- 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있습니다.
- 각 패턴의 장단점을 통해서 설계를 선택하는데 도움을 얻을 수 있습니다.
- 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있습니다.

이 분야에 자주 사용되는 패턴들을 모아서 집대성한 다양한 책이 존재하는데, 그 중에서도 가장 유명한 GoF의 디자인 패턴은 많은 프로그래머들에게 도움을 주었습니다. 이 책은 객체지향 프로그래밍에서 발견된 여러 패턴들을 모아놓은 책으로서, 소프트웨어 개발에서 자주 만나게 되는 일반적인 문제를 해결해 주는 설계를 제시하고 있습니다. GoF의 디자인 패턴은 객체의 생성, 기능의 확장, 기능의 변경, 구조 등과 관련된 약 20여개에 이르는 패턴을 정리하고 있습니다.

이번 포스팅에서는 GoF의 패턴 중에서도 영역에 상관없이 자주 사용되는 패턴에 대해서 소개하겠습니다.

- 전략 패턴 / 템플릿 메서드 패턴 / 상태 패턴
- 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴
- 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴
- 추상 팩토리 패턴 / 컴포지트 패턴

그리고 GoF에는 속해 있지 않는 널(Null) 객체 패턴을 추가하였습니다. 이들 패턴은 개발과정에서 자주 사용하는 패터닝ㄴ 만큼, 익혀 두면 많은 도움을 얻을 것 입니다.


## 전략 패턴
한 과일 매장은 상황에 따라 다른 가격 할인 정책을 적용하고 있습니다. 매장을 열자마자 들어온 첫 손님을 위한 `첫 손님 할인`정책과 저녁 시간대에 신선도가 떨어진 과일에 대한 `덜 신선한 과일 할인`정책이 있다면, 아래 코드처럼 계산하는 모듈에 이런 가격 할인 정책을 적용하기 위한 if-else 블록이 포함될 것입니다.

```java
public class Calculator {

    public int calculate(boolean firstGuest, List<Item> items) {
        int sum = 0;
        for(Item item: items) {
            if(firstGuest) 
                sum += (int) (item.getPrice() * 0.9); // 첫 손님 10% 할인
            else if(!item.isFresh())
                sum += (int) (item.getPrice() * 0.8); // 덜 신선한 것 20% 할인
            else
                sum += item.getPrice();
        }
        return sum;
    }
}
```

위 코드는 비교적 간단하지만 다음의 문제를 포함하고 있습니다.

- 서로 다른 계산 정책들이 한 코드에 섞여 있어, 정책이 추가될수록 코드 분석을 어렵게 만듭니다.

- 가격 정책이 추가될 때마다 calculate 메서드를 수정하는 것이 점점 어려워집니다. 예를 들어 마지막 손님 50% 할인과 같은 새로운 가격 정책이 추가될 경우, calculate 메서드에 마지막 손님을 구분하기 위한 lastGuest 파라미터가 추가되고, if 블록이 하나 더 추가되어야 합니다.

이런 문제를 해결하기 위한 방법 중의 하나는 아래 그림처럼 가격 할인 정책을 별도 객체로 분리하는 것입니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/79305980-4d94a880-7f2f-11ea-8b28-aa4d32cfe87e.png)

위 그림에서 DiscountStrategy 인터페이스는 상품의 할인 금액 계산을 추상화하였고, 각 콘크리트 클래스는 상황에 맞는 할인 계산 알고리즘을 제공합니다. Calculator 클래스는 가격 합산 게산의 책임을 집니다. 여기서 가격 할인 알고리즘을 추상화하고 있는 DiscountStrategy을 전략이라고 부르고 가격 계산 기능 자체의 책임을 갖고 있는 Caculator를 콘텍스트라고 부르는데, 이렇게 특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법이 `전략 패턴`입니다.

전략 패턴에서 콘텍스트는 사용할 전략을 직접 선택하지 않습니다. 대신 콘텍스트의 클라이언트가 콘텍스트에 사용햘 전략을 전달 해줍니다. 즉 DI(의존성 주입)를 이용해서 콘텍스트에 전략을 전달해 줍니다. 그리고 전략이 어떤 메서드를 제공할 지의 여부는 콘텍스트가 전략을 어떤 식으로 사용하느냐에 따라 달라집니다.

앞서 위에 그림에서 보여주는 금액 할인 정책을 DiscountStrategy로 분리한 경우, 아래 코드처럼 Calculator를 구현할 수 있을 것입니다.

```java
public class Caluclator {

    private DiscountStrategy discountStrategy;

    public Calculator(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public int calculator(List<Item> items) {
        int sum = 0;
        for(Item item: items) {
            sum += discoutStrategy.discountPrice(item);
        }
    }
    return sum;
}
```

코드를 살펴보면 Calculator 클래스는 생성자를 통해서 사용할 전략 객체를 전달받고, calculate() 메서드에 각 Item의 가격을 계산할 때 전략 객체를 사용하고 있습니다. 위 코드에서 Calculator는 각 Item 별로 할인 정책을 적용하고 있으므로 DiscountStrategy 인터페이스는 아래 코드처럼 정의될 것입니다.

```java
public interface DiscountStrategy {
    public int getDiscountPrice();
}
```

만약 각 아이템 별로 할인 정책이 있고, 전체 금액에 대한 할인 정책이 별도로 필요하다면, DiscountStrategy의 인터페이스에 전체 금액 할인을 위한 메서드가 추가될 것입니다.

```java
public interface DiscountStrategy {
    public int getDiscountPrice(Item item);
    public int getDiscountPrice(int totalPrice);
}
```

또는, 전체 금액 할인 정책을 위한 전략을 별도 인터페이스로 분리할 수도 있을 것입니다.

```java
public interface ItemDiscountStrategy {
    int getDiscountPrice(Item item);
}

public interface TotalPriceDiscountStrategy {
    int getDiscountPrice(int totalPrice);
}
```
전략 객체는 콘텍스트를 사용하는 클라이언트에서 직접 생성합니다. 예를 들어, 첫 번째 손님에 대해 할인을 해주는 FirstGuestDiscountStrategy 구현 클래스를 아래 코드와 같이 구현했다고 합시다.

```java
public class FirstGuestDiscountStrategy implements DiscountStrategy {

    @Override
    public int getDiscountPrice(Item item) {
        return (int) (item.getPrice() * 0.9);
    }
}
```

첫 번째 손님이 들어와서 계산을 하면, 계산기에서 첫 번째 손님 할인 적용 버튼을 누른 뒤에 계산 버튼을 누를 것입니다. 이를 처리하는 코드는 다음과 같은 방식으로 작성될 것입니다.

```java
private DiscoutStrategy strategy;

public void onFirstGuestButtonClick() {
    // 첫 손님 할인 버튼 투를 때 생성 됩니다.
    strategy = new FirstGuestDiscountStrategy();
}

public void onCalculationButtonClick() {
    // 계산 버튼 누를 때 실행됨
    Calculator cal = new Calculator(strategy);
    int price = cal.calculate(items);
    ...
}
```

위 코드를 보면 Calculator를 사용하는 코드에서 FirstGuestDiscountStrategy 클래스의 객체를 생성하는 것을 알 수 있습니다. 이는 콘텍스트를 사용하는 클라이언트가 아래 그림처럼 전략의 상세 구현에 대한 의존이 발생한다는 것을 뜻합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/79309574-7ae45500-7f35-11ea-93d8-b677895acfbb.png)

콘텍스트의 클라이언트가 전략 인터페이스가 아닌 상세 구현을 안다는 것이 문제처럼 보일 수 있으나, 이 경우에는 전략의 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루기 때문에 유지 보수 문제가 발생할 가능성이 줄어듭니다.

예를 들어, 덜 신선한 과일 할인 정책을 추가하려면 클라이언트에 덜 신선한 과일 할인 정책 적용 버튼을 처리하는 코드가 생기고 이 코드에서 NonFreshDiscountStrategy 객체를 생성해 주게 됩니다. 또한 기능이 제거될 때에도 함께 제거됩니다. 따라서 클라이언트의 버튼 처리 코드에서 전략 객체를 직접 생성하는 것은 오히려 코드 이해를 높이고 코드 응집을 높여주는 효과를 갖습니다.


전략 패턴을 적용할 때 얻을 수 있는 이점은 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점입니다. 앞에서 본 예제에서 마지막 손님 대폭 할인 정책을 추가하는 경우, 계산을 제공하는 Calculator 클래스의 코드는 변경되지 않습니다. 단지 새로운 할인 정책을 구현한 LastGuestDiscountStrategy 클래스를 추가하고, 마지막 손님 대폭 할인 버튼을 클릭을 처리하는 코드에서 LastGuestDiscountStrategy의 객체를 생성해 주기만 하면 됩니다.


```java
private DiscountStrategy strategy;

public void onLastGuestButtonClick() {
    // 마지막 손님 대폭 할인 버튼 누를 때 생성됨
    strategy = new LastGuestDiscountStrategy();

}

public void onCalculationButtonClick() {
    // 계산 버튼 누를 때 실행 됩니다.
    Calculator cal = new Calculator(strategy);
    int price = cal.calculate(items);
    ...
}
```

전략 패턴을 적용함으로써 Calculator 클래스는 할인 정책 확장에는 열려 있고 변경에는 닫혀 있게 됩니다. 즉, 개방 폐쇄 원칙을 따르는 구조를 갖게 됩니다.

일반적으로 if-else로 구성된 코드 블록이 비슷한 기능을 수행하는 경우에 전략 패턴을 적용함으로써 코드를 확장 가능하도록 변경할 수 있습니다. 위에서 살펴본 if-else 블록에 따라 전략 패턴을 적용함으로써 새로운 할인 정책을 보다 쉽게 추가할수 있도록 만들어보았습니다.


## 템플릿 메서드 패턴
프로그램을 구현하다 보면, 완전한 동일한 절차를 가진 코드를 작성하게 될 때가 있습니다. 심지어 이 코드들은 절차 중 일부 과정의 구현만 다를 뿐 나머지 구현은 똑같을 때도 있습니다. 예를 들어, DB 데이터와 LDAP를 이용해서 인증을 처리하는 클래스는 사용자 정보를 가져오는 부분의 구현만 다를 뿐 인증을 처리하는 과정은 완전히 동일할 수 있습니다.

DB나 LDAP이 아닌 중간에 인증 서버를 두는 경우라도 두 클래스와 거의 유사한 코드를 갖게 될 것입니다. 이렇게 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴이 `템플릿 메서드 `패턴 입니다. 템플릿 메서드 패턴은 다음과 같이 두 가지로 구성됩니다.

- 실행 과정을 구현한 상위 클래스
- 실행 과정의 일부 단계를 구현한 하위 클래스

상위 클래스는 실행 과정을 구현한 메서드를 제공합니다. 이 메서드는 기능을 구현하는데 필요한 각 단계를 정의하며 이 중 일부 단계는 추상 메서드를 호출하는 방식으로 구현됩니다. 이대 추상 메서드는 구현이 다른 단계에 해당합니다. 예를 들어, 템플릿 메서드 패턴을 적용하면 아래 코드와 같이 상위 클래스를 작성할 수 있습니다.


```java
public abstract class Authenticator {

    // 템플릿 메서드
    public Auth authenticate(String id, String pw) {
        if(!doAuthenticate(id, pw)) 
            throw createException();
        
        return createAuth(id);
    }

    protected abstract boolean doAuthenticate(String id, String pw);

    private RuntimeException createException() {
        throw new AuthException();
    }
    protected abstract Auth createAuth(String id);
}
```

authenticate() 메서드는 DbAuthenticator와 LdapAuthenticaotr에서 동일했던 실행 과정을 구현하고 있고, 두 클래스에서 차이가 나는 부분은 별도의 추상 메서드로 분리하였습니다.

예를 들어, id/pw를 이용해서 인증 여부를 확인하는 단계는 doAuthenticate() 추상 메서드로 분리하였고, Auth 객체를 생성하는 단계는 createAuth() 추상 메서드로 분리하였습니다. Authenticate() 메서드는 모든 하위 타입에 동일하게 적용되는 실행 과정을 제공하기 때문에, 이 메서드를 템플릿 메서드라고 부릅니다.

Authenticator 클래스를 상속받은 하위 클래스는 authenticate() 메서드에서 호출하는 다른 메서드만 알맞게 재정의 해주면 됩니다. 예를 들어 LdapAuthenticator 클래스는 아래 코드처럼 구현할 수 있습니다.

```java
public class LdapAuthenticator extends Authenticator {

    @Override
    protected boolean doAuthenticate(String id, String pw) {
        return ldapClient.authenticate(id, pw);
    }

    @Override
    protected Auth createAuth(String id) {
        LdapContext ctx = ldapClient.find(id);
        return new Auth(id, ctx.getAttribute("name"));
    }
}
```

LdapAuthenticator 클래스는 이제 전체 실행 과정 구현을 제공하지 않고 일부 과정의 구현만을 제공합니다. 전체 실행 과정은 상위 타입인 Authenticator의 authenticate() 메서드에서 제공하게 됩니다.

템플릿 메서드 패턴을 사용하게 되면, 동일한 실행과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현할 수 있도록 할 수 있습니다. 이는 각 타입에서 코드가 중복되는 것을 방지합니다.

템플릿 메서드 패턴을 적용하기 전에 DbAuthenticator와 LdapAuthenticator는 완전히 동일한 구조를 갖고 있었습니다. 차이점이라면 DB를 사용하느냐 LDAP를 사용하느냐 일뿐, 실행 과정 자체는 완전히 동일했습니다. 새로운 인증 방식이 추가되더라도 이 과정은 완전히 동일하기 때문에 거의 비슷한 코드가 중복될 것입니다. 중복된 코드가 출현한다는 것은 그만큼 유지 보수를 어렵게 만드는데, 템플릿 메서드 패턴을 사용함으로써 코드 중복 문제를 제거하면서 동시에 코드를 재사용 할 수 있게 합니다.

## 상위 클래스가 흐름 제어 주체
템플릿 메서드 패턴의 특징은 하위 클래스가 아닌 상위 클래스에서 흐름 제어를 한다는 것입니다. 일반적인 경우 하위 타입이 상위 타입의 기능을 재사용할지 여부를 결정하기 때문에, 흐름 제어를 하위 타입이 하게 됩니다. 예를 들어, 아래 코드에서 SuperCar 클래스의 turnOn() 메서드는 상위 클래스의 turnOn() 메서드를 재사용할지 여부를 자신이 결정합니다.

```java
public class SuperCar extends ZetEngine {

    @Override
    public void turnOn() {
        // 하위 클래스에서 흐름 제어
        if(notReady) 
            beep();
        else 
            super.turnOn();
    }
}
```

반면에 템플릿 메서드 패턴에서는 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어하고, 하위 타입의 메서드는 템플릿 메서드에 호출되는 구조를 갖게 됩니다.

템플릿 메서드인 authenticate() 메서드와 템플릿 메서드에서 호출하는 메서드인 doAuthenticate() / createAuth() 메서드의 접근 범위는 각가 public과 protected로 설정되어 있습니다. 템플릿 메서드의 경우 외부에서 제공하는 기능에 해당되기 때문에 public 범위를 가져야 하는 반면에 doAuthenticate() 메서드나 createAuth() 메서드는 템플릿 메서드에서만 호출되는 메서드로서 public일 필요가 없습니다. 이 두 메서드는 하위 타입에서 재정의할 수 있어야 하기 때문에 private이 아닌 protected 범위를 가져야 합니다.

이 예제에서는 템플릿 메서드에서 호출하는 메서드를 추상 메서드로 정의했는데, 기본 구현을 제공하고 하위 클래스에서 알맞게 재정의하도록 구현할 수도 있습니다. 이 경우 해당 메서드는 기능의 확장 지점으로 사용될 수 있습니다. 예를 들어, 안드로이드에서 비동기 처리를 위한 기능을 제공하는 AsyncTask 클래스의 코드를 보면, 아래처럼 doBackground() 추상 메서드와 빈 구현을 갖는 onPreExecute() 메서드를 제공하고 있습니다.

```java
public abstract class AsyncTask<Params, Progress, Result> {

    public AsyncTask() {
        mWorker = new WorkerRunnable<Params, Result>() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                return postResult(doInBackground(mParams));
            }
        };
        ...
    }
    
    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {
        ...
        mStatus = Status.RUNNIN;
        onPreExecute();
        mWorker.mParams = params;
        exec.execute(mFuture);
        return this;
    }
    protected abstract Result doInBackground(Params... params);

    protected void onPreExecute() { // 하위 클래스의 확장 지점

    }
    ...// 기타 다른 코드
}
```

AsyncTask를 상속받아 구현하는 클래스는 doInBackground() 메서드는 반드시 구현해 주어야 하지만, onPreExecute() 메서드의 경우는 필요한 경우에만 구현해 주면 됩니다. 즉, onPreExecute() 메서드는 상위 클래스 입장에서는 제어 대상이 되는 확장 지점이 되며, 하위 클래스에 맞는 확장 기능을 구현할 위치가 됩니다.

> 훅 메서드란? 이렇게 상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드를 훅(hook) 메서드라고 부릅니다. 


## 템플릿 메서드와 전략 패턴의 조합

템플릿 메서드와 전략 패턴을 함께 사용하면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 활용 할 수 있는데, 대표적인 예가 스프링 프레임워크의 Template으로 끝나는 클래스 들입니다. 이 클래스들은 템플릿 메서드를 실행할 때, 변경되는 부분을 실행할 객체를 파라미터를 통해서 전달받는 방식으로 구현되어 있습니다.

예를 들어, 트랜잭션 기능을 제공하는 TransactionTemplate 클래스의 execute() 메서드는 다음과 같이 구현되어 있습니다.

```java
public <T> T execute(TransactionCallback<T> action) throw TransactionException {
    // 일부 코드 생략
    TransactionStatus status = this.transactionManager.getTransaction(this);
    T result; 
    try {
        result = action.doInTransaction(status);
    } catch (RuntimeException ex) {
        rollbackOnException(status, ex);
        throw ex;
    }
    // 기타 다른 익셉션 처리 코드
    this.transactionManager.commit(status);
    return result;
}
```

execute() 메서드는 트랜잭션의 시작.커밋/롤백 등의 실행 흐름을 제공하는 템플릿 메서드인데, execute() 메서드는 앞서 살펴본 템플릿 메서드와 다음의 차이점이 있습니다.

- 앞서 템플릿 메서드가 하위 타입에서 재정의할 메서드를 호출하고 있다면
- TransactionTemplate의 execute() 메서드는 파라미터로 전달받은 action의 메서드를 호출하고 있습니다.

따라서 TransactionTemplate의 execute() 메서드를 사용하는 코드는 다음과 같이 execute() 메서드를 호출할 때 원하는 기능을 구현한 TransactionCallback 객체를 전달합니다.

```java
transactionTemplate.execute(new TransactionCallback<String>(){
    public String doInTransaction(TransactionStatus status) {
        // 트랜잭션 범위 안에서 실행될 코드 
    }
}); 

```

템플릿 메서드 패턴과 전략 패턴을 조합하게 되면, 상속에 기반을 둔 템플릿 메서드 구현과 비교해서 유연함을 갖습니다. 상속을 통한 재사용의 경우 앞에 포스팅에서 살펴봤듯이 클래스가 불필요하게 증가할 수 있고 런타임에 교체할 수 없는 단점이 있는 반면에 조립/위임을 사용하는 경우에 런타임에 템플릿 메소드에서 사용할 객체를 교체할 수 있는 장점을 갖게 됩니다.
하지만, 상속 방식의 경우 훅 메서드를 재정의 하는 방법으로 하위 클래스에서 쉽게 확장 기능을 제공할 수 있는 장점이 있는 반면에, 조립/위임 방식에서는 확장 기능을 제공하려면 구현이 다소 복잡해지는 단점이 있습니다.
























