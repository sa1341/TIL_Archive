## 추상 팩토리(Abstract Factory) 패턴

비행기를 조정하고 미사일을 발사해서 적을 미사일로 쏴 맞춰 잡는 슈팅 게임을 만든다고 가정해봅시다. 이런 게임은 흔히 여러 종유릐 적이 출현하고 한 단계의 끝에 다다르면 그 단계의 보스가 출현하고, 이 보스를 맞춰 잡으면 당므 단계로 넘어가는 방식을 취합니다. 또한, 중간 중간에 공격은 하지 않지만, 부딪히면 안 되는 장애물이 출현하기도 합니다. 보스 적기, 작은 적기 그리고 장애물은 단계마다 다른 종류가 출현합니다.

예를 들어, 특별 공격으로 작은 분신을 만들어 내는 보스와 강력한 미사일을 발사하는 보스의 두 가지 종류가 있을 수 있고, 적기에도 미사일을 발사하는 적기와 자폭하는 적기가 있을 수 있습니다. 또한, 각 단계마다 적들의 공격력이나 방어력이 달라질 수 있습니다. 이런 보스, 적기, 장애물을 구현하기 위해 아래 그림과 같이 Boss, SmallFlight, Obstacle 클래스 및 하위 클래스를 구성하였습니다.

![Untitled Diagram (4)](https://user-images.githubusercontent.com/22395934/81499868-70856300-9309-11ea-8648-9c4200544fec.png)

실제 게임 플레이를 진행하는 Stage 클래스는 몇 단계인지 따라 서로 다른 적기, 장애물 또는 보스를 생성해야 합니다. 이를 처리하기 위해 Stage 클래스의 코드를 다음과 같이 작성할 수 있을 것입니다.

```java
// Stage 클래스
public void createEnemies() {

    for (int i = 0; i<= ENEMY_COUNT; i++) {
        if(stageLevel == 1) {
            enemies[i] = new DashSmallFlight(1, 1); // 공격/수비력 1
        } else if (stageLevel == 2) {
            enemies[i] = new MissileSmallFlight(1, 1);
        }
    }

    if (stageLevel == 1) {
        boss = new StrongAttackBoss(1, 10);
    } else if (stageLevel == 2) {
        boss = new CloningBoss(5, 20);
    }
}

private void createObstacle() {
    for(int i = 0; i < OBSTACLE_COUNT; i++) {
        if (stageLevel == 1) {
            obstacles[i] = new RockObstacle();
        } else {
            obstacles[i] = new BombObstacle();
        }
    }
}
```

위 코드의 문제는 단계별로 적기, 보스, 장애물을 생성하는 규칙이 Stage 클래스에 포함되어 있다는 점입니다. 새로운 적 클래스가 추가되거나 각 단계의 보스 종류가 바뀔 때 Stage 클래스를 함께 수정해 주어야 하고, 각 단계별로 적기 생성 규칙이 달라질 경우에도 Stage 클래스를 수정해 주어야 합니다.
또한 중첩되거나 연속된 조건문으로 인해 코드가 복잡해지기 쉽고 이는 코드 수정을 어렵게 만드는 원인이 됩니다.

적과 장애물 객체의 생성을 Stage 클래스에서 직접 수행하면서 앞서 언급한 문제들이 발생하기 때문에, Stage 클래스로부터 객체 생성 책임을 분리함으로써 이 문제를 해소할 수 있습니다. 이 때 사용되는 패턴이 바로 `추상 팩토리 패턴입니다.`

추상 팩토리 패턴에서는 관련된 객체 군을 생성하는 책임을 갖는 타입을 별도로 분리합니다. 앞서 예의 경우 SmallFlight, Boss, Obstacle 객체를 생성해 주는 책임을 갖는 EnemyFactory 타입을 추가할 수 있습니다.

EnemyFactory 클래스는 Boss, SmallFlight, Obstacle 객체를 생성해 주는 메서드를 정의하고 있습니다. 여기서 EnemyFactory 클래스는 객체 생성 메서드를 선언하는 추상 타입으로서 팩토리에 해당되며, 팩토리가 생성하는 대상인 Boss, SmallFlight, Obstacle은 제품 타입이 됩니다.

EnemyFactory.getFactory() 메서드는 정적 메서드로서 파라미터로 전달받은 레벨에 따라 알맞은 EnemyFactory 객체를 리턴하도록 정의하였습니다. 아래 코드를 보고 어떻게 생성하는지 살펴보겠습니다.

```java
public abstract class EnemyFactory {
    public static EnemyFactory getFactory(int level) {
        if (level == 1) 
            return EasyStageEnemyFactory();
        else 
            return HardEnemyFactory();
    }

    // 객체 생성을 위한 팩토리 메서드
    public abstract Boss createBoss();
    public abstract SmallFlight createSmallFlight();
    public abstract Obstacle createObstacle();
}
```

팩토리인 EnemyFactory를 구현한 콘크리트 팩토리 클래스는 아래 코드에서 보듯이 알맞은 객체를 생성합니다.
