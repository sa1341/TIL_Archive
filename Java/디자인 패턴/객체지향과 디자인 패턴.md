# 절차지향
절차 지향이라고 해서 뭔가 순서에 따라 프로그래밍하는 방식을 생각할 수 있으나, 사실 여기서의 절차는 영어 단위를 우리말로 옮긴 것 뿐입니다. 각 프로시저는 데이터를 사용해서 기능을 구현하며, 필요에 따라 다른 프로시저를 사용하기도 합니다. 또한 여러 프로시저가 동일한 데이터를 공유합니다. 이 점은 양날의 검입니다. 예를 들어서 한 데이터를 사용하는 프로시저가 많을수록 그 데이터의 타입을 변경하기 어려워집니다.

만약 전자 장비의 꺼짐/켜짐 상태를 저장하기 위해 boolean 타입이고 이름이 isOn이라는 데이터를 사용한다고 가정해보겠습니다.

이 데이터를 사용하는 프로시저는 모두 isOn을 boolean 타입으로 처리할 것입니다. 그런데, 요구 사항이 변경되어서 꺼짐/켜짐 상태뿐만 아니라 대기 상태를 추가해야한다고 해봅시다. 이 요구사항이 반영하기 위해 isOn 데이터 타입을 boolean 타입에서 열거 타입으로 변경하게 되면, 이 데이터를 사용하는 모든 프로시저도 함께 수정해 주어야 합니다.

이러한 문제는 절차 지향적으로 프로그램을 구성할 때 매우 흔하게 발생하는 문제들입니다. 이로 인해 새로운 요구사항이 생겨서 프로그램의 한 곳을 수정하게 되면, 다른 곳에서 문제가 발생하고, 다시 그 곳을 수정하면 또 다른 곳에서 문제가 발생하는 악순환이 발생하기도 합니다. 이는 결국 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현을 투입하게 만듭니다.

# 객체 지향
절차 지향과 달리 객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶습니다. 객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성합니다.

각 객체는 자신만의 데이터와 프로시저를 갖습니다. 객체는 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있게 된다. 객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용하는데, 이때 프로시저는 자신이 속한 객체의 데이터에만 접근할 수 있으며, 다른 객체에 속한 데이터에는 접근할 수 없습니다.

모든 프로시저가 데이터를 공유하는 절차 지향과 달리 객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 하고, 프로그램의 규모가 작을 때에는 절차 지향 방식보다 복잡한 구조를 갖게 됩니다.

하지만, 객체 지향적으로 만든 코드에서는 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는 영향을 주지 않기 때문에, 요구 사항의 변화가 발생했을 때 절차 지향 방식보다 프로그램을 더 쉽게 변경할 수 있는 장점을 갖습니다. 


## 인터페이스와 클래스

객체는 객체가 제공하는 기능으로 정의됩니다. 보통 객체가 제공하는 기능을 오퍼레이션이라고 합니다. 즉, 객체는 오퍼레이션으로 정의가 됩니다. 객체가 제공하는 기능을 사용한다는 것은 결국 객체의 오퍼레이션을 사용한다는 의미가 됩니다. 그런데, 객체가 제공하는 오퍼레이션을 사용할 수 있으려면, 그 오퍼레이션의 사용법을 알아야 합니다.

예를 들어, 소리 크게 제어 객체가 있는데, 말 그대로 소리 크기를 높이거나 줄이거나 혹은 음소거를 하는 오퍼레이션을 가진 객체입니다. 이 오퍼레이션을 사용하려면 당연히 사용법을 알아야 하는 것입니다. 오퍼레이션의 사용법은 일반적으로 다음과 같이 세 개로 구성되며, 이 세가지를 합쳐서 시그니처(Signature)라고 부릅니다.

- 기능 식별 이름
- 파라미터 및 파라미터 타입
- 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 `인터페이스`라고 부르며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 타입입니다. 여기서 말하는 인터페이스는 자바 언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어입니다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 됩니다.

인터페이스는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않습니다. 실제 객체의 구현을 정의하는 것은 클래스입니다. 이 클래스에는 오퍼레이션을 구현하는데 필요한 데이터 및 오퍼레이션의 구현이 포함됩니다. 여기서의 클래스도 자바나 C#등의 언어에서 말하는 클래스와 유사합니다.

인터페이스, 오퍼레이션, 클래스, 객체의 관계를 정리해보면 아래와 같습니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/77655970-8daede00-6fb6-11ea-8a08-4c90d78784ea.png)


## 메시지
객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 됩니다. 예를들어, 파일에서 데이터를 읽어오는 객체가 있고, 데이터를 암호화 해주는 객체가 있습니다. 파일에 데이터를 쓰는 객체가 있다고 합시다. 이 경우, 특정 파일에서 데이터를 읽어와 암호화 한 뒤에 다른 파일로 쓰는 프로그램은 아래와 같이 세 개의 객체로 구성될 수 있을 것입니다. 물론, 실제로는 더 복잡하겠지만 예를 들기 위해 단순화시켰습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77659230-22b3d600-6fbb-11ea-9c76-45fde0740944.png)


파일 읽기 객체가 제공하는 인터페이스가 다음과 같은 오퍼레이션을 제공한다고 합시다.

- 오퍼레이션 이름: read
- 파라미터: 없음
- 리턴 타입: byte 배열

이 경우, 암호화 처리 객체는 파일 읽기 객체에게 read 오퍼레이션을 실행해달라는 요청을 전달하며, 요청을 받은 파일 읽기 객체는 해당 요청에 해당하는 기능을 실행한 뒤에 응답을 전달하게 됩니다. 이 때 오퍼레이션의 실행을 요청하는 것을 `메시지를 보낸다.`고 표현합니다.

자바와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당됩니다. 아래 코드를 봅시다.

```java
FileInputStream is = new FileInputStream(fileName);
byte[] data = new byte[512];
int readBytes = is.read(data);
```
이 코드에서 is 변수는 FileInputStream 타입의 객체를 참조하는데, is.read(data) 코드는 is가 참조하는 객체에 read() 오퍼레이션을 실행해 달라는 메시지를 전송한다고 생각하면 됩니다.

## 객체의 책임과 크기

객체는 객체가 제공하는 기능으로 정의된다고 했는데, 이는 다시 말하면 객체마다 자신만의 책임(responsibility)이 있다는 의미를 갖습니다. 예를 들어, 위 그림에서 설명한 암호화 처리 객체는 제공 받은 데이터를 암호화해서 다른 파일에 보내는 책임이 있습니다.
파일 읽기 객체는 파일에서 데이터를 읽어와 제공하는 책임이 있고, 파일 쓰기 객체는 파일에 데이터를 쓰는 책임이 있습니다.

한 객체가 갖튼 책임을 정의한 것이 바로 타입/인터페이스라고 생각하면 됩니다. 그럼, 객체가 갖는 책임은 어떻게 결정될까요? 이 결정을 하는 것이 바로 객체 지향 설계의 출발점입니다.

위의 세 개의 객체가 서로 다른 책임을 지는데, 이런 책임 할당이 처음부터 바로 결정되는 것은 아닙니다. 처음에는 프로그램을 만들기 위해 필요한 기능 목록을 정리해야 합니다. 

다음은 기능 목록을 정리한 예입니다.

- 파일의 byte 데이터를 제공합니다.
- 파일에 byte 데이터를 씁니다.
- byte 데이터를 암호화해서 새로운 byte 데이터를 생성합니다.
- 전체 흐름을 제어합니다.

이 기능을 어떻게 객체들에게 분배하느냐에 따라서 객체의 구성이 달라집니다. 

객체 지향적으로 프로그래밍을 할 때, 가장 어려우면서 가장 중요한 것이 바로 객체마다 기능을 할당하는 과정입니다.

기능이 몇개 안되는 경우에도 다양한 조합의 구성이 가능하기 때문에, 이런 다양한 조합 중에서 알맞은 구성을 찾아내는 것은 쉽지 않습니다.

상황에 따라 객체가 가져야 할 기능의 종류와 개수가 달라지기 때문에, 모든 상황에 들어맞는 객체-책임 구성 규칙이 존재하는 것은 아닙니다. 하지만, 객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 존재하는데, 그 규칙은 바로 객체가 갖는 책임의 크기는 작을수록 좋다는 것입니다. 객체가 갖는 책임이 작아야 한다는 것은 객체가 제공하는 기능의 개수가 적다는걸 의미합니다.

만약 한 객체에 많은 기능이 포함된다면, 그 기능과 관련된 데이터들도 한 객체에 모두 포함됩니다. 이 구조는 객체에 정의된 많은 오퍼레이션들이 데이터들을 공유하는 방식으로 프로그래밍 된다는 것을 의미하는데, 이는 곧 데이터를 중심으로 개발되는 절차 지향 방식과 동일한 구조가 됩니다. 따라서 객체가 갖는 책임이 커질수록 절차 지향적으로 구조가 변질되며, 절차 지향의 가장 큰 단점인 기능 변경의 어려움 문제가 발생하게 됩니다.

따라서 객체가 갖는 책임의 크기는 작아질수록 객체 지향의 장점인 변경의 유연함을 얻을 수 있게 됩니다. 객체의 크기와 관련된 원칙이 있는데 그 원칙은 바로 단일 책임 원칙입니다. 단일 책임 원칙은 이름에서 알 수 있듯이 객체는 단 한개의 책임만을 가져야 한다는 원칙입니다. 이 원칙에 따르면 아래 그림의 객체 구조는 다음과 같이 네 개의 객체가 각각 한개의 책임만을 갖도록 재구성됩니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/77762596-1c862e00-707d-11ea-8f2d-a4c6e2fb56d3.png)

단일 책임 원칙을 따르다 보면 자연스럽게 기능의 세부 내용이 변경될 때, 변경해야 할 부분이 한 곳으로 집중됩니다.

예를 들어, 파일을 읽어 오는 방법을 변경해야 한다면 `파일 읽기` 책임을 가진 객체의 코드만 수정되며, 다른 객체의 코드를 수정해야 할 가능성은 낮아집니다. 비슷하게 암호화 알고리즘을 변경해야 할 경우, `byte 암호화` 객체의 코드만 변경될 뿐 다른 객체의 코드가 변경될 가능성은 줄어듭니다. 즉, 단일 책임 원칙은 변경의 유연함을 얻기 위한 가장 기본 원칙이 됩니다.

> 객체가 책임을 갖는다는 것은  객체가 역할을 수행한다는 의미를 갖습니다. 앞서 예에서 `흐름 제어` 책임을 갖는 객체는 흐름을 제어하는 역할을 수행하는 객체라고 표현하기도 합니다. 객체 지향 관련 서적이나 글을 읽을 때 객체의 역할이란 단어가 나오면 이는 곧 객체의 책임과 동일한 의미로 사용됨을 기억합시다.

## 의존
객체 지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이용해서 자신의 기능을 완성하는 객체가 출현하게 됩니다. 예를 들어, 앞서 `흐름 제어` 객체는 `byte 암호화` 객체와 `파일 읽기` 객체, `파일 쓰기` 객체를 이용해서 파일 데이터 암호화 프로그램의 실행 흐름 기능을 완성하였습니다.

한 객체가 다른 객체를 이용한다는 것은, 실제 구현에서는 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출한다는 것을 뜻합니다. `흐름 제어` 객체의 실제 코드는 다음과 같이 다른 객체의 메서드를 호출해서 기능을 완성해 나갈 것입니다.

```java
public class FlowController {

    //fileName 필드 초기화 코드 생략
    public void process() {
        FileDataReader reader = new FileDataReader(fileName); // 객체 생성
        byre[] plainText = reader.read(); // 메서드 호출

        ByteEncryptor encryptor = new ByteEncryptor(); // 객체 생성
        byte[] encryptedBytes = encryptor.encrypt(plainBytes); // 메서드 호출

        FileDataWriter writer = new FileDataWriter(); // 객체 생성

        writer.write(encrypyedBytes); // 메서드 호출
    }
}
```
이렇게 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현합니다.

위 코드에서 FlowController가 FileDataReader에 의존한다고 표현할 수 있습니다. 객체를 생성하거나 메서드를 호출하는 것뿐만 아니라 파라미터로 전달받는 경우에도 의존한다고 볼 수 있습니다.

예를 들어, 아래 코드와 같이 ByteEncryptor를 파라미터로 받으면, 메서드 구현 과정에서 파라미터로 전달받은 ByteEncryptor 객체를 사용할 가능성이 높기 때문에, 이는 process() 메서드가 ByteEncryptor에 의존한다고 볼 수 있습니다.

```java
public void process(ByteEncrpytor encryptor) {
    ...// 내부에서 encryptor를 사용할 가능성이 높습니다.
}
```

객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받든 다른 타입에 의존을 한다는 것은 의존하는 타입에 변경이 발생할 때 나도 함꼐 변경될 가능성이 높다는 것을 뜻합니다. 예를 들어, FileDataWriter의 생성자가 String 타입으로 파일 경로를 받도록 수정된다면, FlowController 클래스 코드에서 FileDataWriter를 생성하는 코드도 알맞게 수정해 주어야 합니다.

```java
public class FlowController {

    //outfileName 필드 초기화 위한 코드 추가 발생
    public void process() {
        ...
       //FileDataWriter writer = new FileDataWriter(); // 기존 코드
         FileDataWriter writer = new FileDataWriter(outfileName); // 변경 발생
        writer.write(encrypyedBytes); // 메서드 호출
    }
}
```

의존의 영향은 꼬리에 꼬리를 문 것처럼 전파되는 특징을 갖습니다. 예를 들어, 아래 그림과 같이 C 클래스가 B 클래스에 의존하고, B클래스가 A 클래스에 의존한다고 합시다. 이 경우 A 클래스의 변경은 B 클래스에 영향을 줄 가능성이 높고, 이는 다시 C 클래스에 영향을 주게됩니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77823922-f7a7be80-7141-11ea-8c86-ac38ef5f2e9c.png)

의존의 이런 특징 때문에 의존이 순환해서 발생할 경우 다른 방법이 없는지 고민해야 합니다. 아래 그림에서 A 클래스의 변화는 C 클래스까지 영향을 줄 수 있는데, C 클래스의 변화는 다시 A 클래스에 영향을 줄 수 있습니다. 이는 결국 A 클래스를 변경한 여파가 다시 A 클래스의 또 다른 변화를 유발할 수 있다는 것을 뜻합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/77823991-83214f80-7142-11ea-84c9-cee049efbdee.png)

순환 의존의 이런 특징 때문에, 순환 의존이 발생할 경우 적극적으로 이를 해소하는 방법을 찾아야 합니다. 순환 의존이 발생하지 않도록 하는 원칙 중의 하나로 의존 역전 원칙(Dependency inversion principle; DIP)이 있는데, 이에 대한 내용은 5장에서 살펴보도록 하겠습니다.

## 의존의 양면성
다음 코드를 보겠습니다.

```java
public class Authenticate {

    public boolean authenticate(String id, String password) {
        Member m = findMemberById(id);
        if(m == null) return false;
        
        return m.equalPassoword(password); // password가 m의 암호와 동일하면 true
    }
    ...
}
```

Authenticator 클래스를 사용하는 코드는 다음과 같이 authenticate() 메서드를 이용해서 사용자가 입력한 암호가 올바른지 여부를 판단할 것입니다.

```java
public class AuthenticationHandler {

    public void handleRequest(String inputId, 
    String inputPassword) {
        Authenticate auth = new Authenticate();
        if(auth.authenticate(inputId, inputPassword)) {
            // 아이디 암호 일치할 때의 처리
        } else {
            // 아이디 암호 일치하지 않을 때의 처리
        }
    }
}
```

위 코드에서 AuthenticationHandler 클래스는 Authenticator 클래스를 사용하고 있습니다. 즉 AuthenticationHandler 클래스가 Authenticator 클래스에 의존하고 있고, Authenticator 클래스에 변화가 생기면 AuthenticationHandler 클래스에도 영향을 받게 됩니다.

그런데 잘못된 아이디를 입력한 것인지 아니면 암호가 틀린 것인지 여부를 확인해서 시스템 상에 로그를 남겨 달라는 요구가 추가되었습니다. 이 요구를 충족시키려면 Authenticator의 authenticate() 메서드는 단순히 boolean 값을 리턴하면 안됩니다. 아이디가 잘못되었는지 암호가 잘못되었는지 여부를 알려줄수 있어야 합니다. 예를 들면 AuthenticationHandler 클래스의 코드는 다음과 같이 익셉션을 통해서 인증 실패 이유를 구분할 수 있어야 합니다.

```java
public class AuthenticationHandler {

    public void handleRequest(String inputId, 
    String inputPassword) {
        Authenticate auth = new Authenticate();
        try {
            auth.authenticate(inputId, inputPassword);
             // 아이디/암호 일치하는 경우의 처리
        } catch(MemberNotFoundException ex) {
             // 아이디가 잘못된 경우의 처리
        } catch(InvalidPassowrdException ex) {
             // 암호가 잘못된 경우의 처리
        }
    }
}
```

AuthenticationHandler 클래스으를 위와 같이 작성하려면 Authentor 클래스의 authenticate() 메서드가 다음과 같이 변경되어야만 합니다.

```java
public class Authenticator {

    public void authenticate(String id, String password) {
        Member m = findMemberById(id);
        if(m == null) throw new MemberNotFoundException();

        if(!m.equalPassowrd(password)) throw new InvalidPasswordException();
    }
    ...
}
```
AuthenticationHandler 클래스가 Authenticator 클래스에 의존하고 있는 상황에서, AuthenticationHandler 클래스의 변경 요구 때문에 Authenticator 클래스에 변화가 발생한 것입니다. 이는 의존이 다음과 같이 상호간에 영향을 준다는 것을 보여줍니다.

- 내가 변경되면 나에게 의존하고 있는 코드에 영향을 줍니다.
- 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 줍니다.

## 캡슐화

객체 지향의 장점은 한 곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 해준다는데 있습니다. 즉, 수정을 좀 더 원활하게 할 수 있도록 하는 것이 객체지향적으로 프로그래밍을 하는 이유인 것입니다. 객체 지향은 기본적으로 캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 최소화 합니다.

캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것입니다. 이를 통해 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않도록 만들어 줍니다. 즉, 내부 구현 변경의 유연함을 주는 기법이 바로 캡슐화 입니다. 본 절에서는 간단한 기능 구현을 절차 지향 방식과 캡슐화 방식으로 구현해 보고, 이 두 구현의 비교를 통해 실제로 캡슐화가 어떻게 구현 변경의 유연함을 주는지 살펴보도록 합시다.


## 절차 지향 방식 코드
회원의 서비스 만료 날짜 여부에 따라 서비스를 제공하거나 안내 페이지를 보여줘야 한다고 합시다. 서비스 만료 날짜 여부를 확인하는 코드는 여러 곳에서 사용될 것입니다. 회원 정보를 담고 있는 클래스는 아래 코드와 같이 만료 날짜 데이터를 담고 있을 것입니다.

```java
public class Member {

    private Date expiryDate;
    private boolean male;

    public Date getExpiryDate() {
        return expiryDate;
    }
    public boolean isMale() {
        return male;
    }
}
```

Member 객체를 이용해서 만료 여부를 확인하는 코드는 Member가 제공하는 expiryDate 데이터의 값과 현재 시간을 비교하게 됩니다. 아래와 같은 형태의 코드는 시간이 흐를수록 이곳저곳에서 사용될 것입니다.

```java
if(member.getExpiryDate() != null && member.getExpiryDate() < System.currentTimeMillis()) {
    // 만료되었을 때의 처리
}
```

그런데, 서비스를 잘 운영해 오던 중에, 여성 회원인 경우 만료 기간이 지났어도 30일 간은 서비스를 사용할 수 있도록 정책이 변경되었다고 가정해 봅시다. 만료 여부를 확인하는 규칙이 변경되었으므로 이를 코드에 반영해 주어야 합니다. 변경되는 코드는 다음과 같이 복잡해질 것 입니다.


```java
long day30 = 1000 * 60 * 60 * 24 * 30; // 30일
if((
    member.isMale() && member.getExpiryDate() != null &&
    member.getExpiryDate().getDate() < System.currentTimeMillis()
   )
   ||
   (
    !member.isMale() && member.getExpiryDate() != null && 
    member.getExpiryDate().getDate() < System.currentTimeMillis() - day30
   ))
{
    // 만료 되었을 때의 처리
}
```

물론 만료 여부를 확인하는 코드는 이미 여러 곳에서 사용되는 중이기 때문에, 그 코드들을 모두 찾아서 위와 같이 변경해 주어야 합니다. 만료 여부를 확인하는 코드가 많을수록 수정해주지 않는 실수를 범할 가능성이 높아지고, 이는 프로그램의 버그로 직결됩니다. 버그가 발견된 시기에 차이가 발생해서 버그의 원인을 빠르게 찾기도 힘들게 됩니다.

우여곡절 끝에 만료 여부 확인 코드를 모두 찾아서 수정해 주었다고 합시다. 그런데, 시간이 흘러 다시 만료 여부 확인 정책에 변화가 생겼다. 이런 ~ 슬프게도 그 사이에 만료 여부를 확인하는 코드를 사용하는 곳이 증가했습니다. 더불어, 관련 개발자도 바뀌었습니다. 새로운 개발자는 그 사이의 내역을 모르기 때문에, 많은 시간을 들여서 어딜 바꿔 줘야 하는지 찾아야 합니다. 물론, 완벽하게 찾지 못할 가능성이 높고, 이로 인해 다시 버그가 숨게 됩니다. 동일한 악순환이 반복되는 것입니다.

이러한 문제가 발생한 원인은 직접 데이터를 중심으로 프로그래밍 했기 때문입니다. 즉, 절차지향적으로 만들었기 때문입니다. 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에, 요구 사항의 변화로 인해 데이터의 구조나 쓰임새가 변경되면 이로 인해 데이터를 사용하는 코드들도 연쇄적으로 수정해 주어야 합니다.

## 캡슐화 된 기능 구현
이제 절차 지향이 아닌 객체 지향적으로 코드를 재구성하겠습니다. 캡슐화는 기능이 내부적으로 어떻게 구현되었는지 숨기는 것이라고 했습니다. 이 예제의 경우 만료 여부를 검사하는 기능이 캡슐화 대상이 됩니다. Member 클래스가 만료 여부를 확인할 수 있는 데이터를 포함하고 있으므로, Member 클래스에 만료 여부를 확인하는 기능을 정의하도록 하겠습니다.

```java
public class Member {

    ...// 다른 데이터
    private Date expiryDate;
    private boolean male;

    public boolean isExpired() {
        return expiryDate != null 
            && expirDate.getDate() < System.currentTimeMillis();
    }
}
```

Member 클래스이 isExpired() 메서드는 만료 여부 확인 기능을 제공하는데, 다른 클래스에서는 Member 클래스가 isExpired() 메서드를 어떻게 구현했는지 알지 못합니다. 단지, 회원의 서비스 사용이 만료되었으면 isExpired() 메서드가 true를 리턴한다는 것만 알고 있을 뿐입니다. 만료 여부에 따라 다르게 동작해야 하는 코드는 다음과 같이 isExpired() 메서드를 사용하게 됩니다.

```java
if(member.isExpired()) {
    // 만료에 따른 처리
}
```

이번에도 역시나 서비스를 잘 운영해오고 있는데, 마케팅 팀의 요구로 만료 여부 규칙이 변경되었습니다. 앞서 예와 동일하게 여성인 경우 한 달 더 사용할 수 있는 특권을 주도록 결정한것입니다. 자, 이제 개발자는 어떻게 할까요? 먼저 Member 클래스의 isExpired() 메서드가 새로운 요구사항을 따르도록 수정합니다.


```java
// 만료 여부 확인 기능을 수정한 Member 클래스
public class Member {

    private static final lon DAY30 = 1000 * 60 * 60 * 24 * 30; // 30일
    ...// 다른 데이터
    private Date expiryDate;
    private boolean male;

    public boolean isExpired() { // 만료 여부 확인 구현을 캡슐화
        if(male) {
            return expiryDate != null && 
                expiryDate.getDate() < System.currentTimeMillis();
        }
        return expiryDate != null && 
            expiryDate.getDate() < System.currentTimeMillis() - DAY30;
    }
}
```

자, 이제 isExpired() 메서드를 수정했으니, isExpired() 메서드를 사용한 곳을 수정할 차례입니다. 아래는 그 결과입니다.

```java
if(member.isExpired()) {
    // 만료에 따른 처리
}
```
다시 살펴보니 수정할 곳이 없습니다. isExpired() 메서드만 수정했을 뿐, isExpired() 메서드를 사용하는 코드는 변경할 필요가 없는 것입니다. 이후 만료 여부를 확인하는 규칙이 새롭게 변경된다 하더라도 isExpired() 메서드만 수정될 뿐, 이를 사용하는 코드는 변경되지 않습니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/77843214-f2944f00-71d5-11ea-8d46-2d7c9535d10b.png)

## 캡슐화의 결과는 내부 구현 변경의 유연성 획득
기능 구현을 캡슐화하면 내부 구현이 변경되더라도, 기능을 사용하는 곳의 영향을 최소화할 수 있습니다.  앞서 isExpired()의 예에서는 아예 영향을 주지 않았습니다. 이는 캡슐화를 통해서 내부 기능 구현 변경의 유연함을 얻을 수 있다는 것을 의미합니다. 즉, 캡슐화를 잘 할수록 보다 쉽게 구현을 변경할 수 있게 됩니다.


## 캡슐화를 위한 두 개의 규칙
앞서 예에서 보듯이 기능 구현을 캡슐화하는 것은 어렵지 않습니다. 하지만, 객체 지향을 처음 접하는 사람들은 그 동안 몸에 밴 절차지향 방식 습관 때문에 무심결에 데이터 중심적인 코드를 만들기 쉽습니다.
이런 습관을 고치는데 도움이 되는 두 개의 규칙이 있는데 그 규칙은 다음과 같습니다.
 
- Tell, Don't Ask
- 데미테르의 법칙(Law of Demeter)

"Tell, Don't Ask" 규칙은 간단합니다. 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라는 규칙입니다. 앞서 회원 만료 여부를 확인하는 코드를 다시 떠올려 보면 됩니다. 절차 지향 방식은 만료 일자 데이터를 가져와서 직접 만료 여부를 확인했습니다.

```java
// member.getExpiryDate(); 만료 일자 데이터를 가져옵니다.
if(member.getExpiryDate() != null && 
    member.getExpiryDate().getDate() < System.currentTimeMillis()) {
        // 만료 되었을 때의 처리
}
```

데이터를 읽는 것은 데이터를 중심으로 코드를 작성하게 만드는 원인이 되며, 따라서 절차 지향적인 코드를 유도하게 됩니다.

데이터 대신 기능을 실행해달라고 명령을 내리면 만료일 자 데이터를 가진 객체에게 만료 여부를 확인해 다랄고 해야합니다. 즉, 아래 코드와 같이 기능 실행을 요청하는 방식으로 코드를 작성하게 됩니다.

```java
if(member.isExpired()) {
    // 만료에 따른 처리
}
```

기능 실행을 요청하는 방식으로 코드를 작성하다 보면, 자연스럽게 해당 기능을 어떻게 구현했는지 여부가 감춰집니다. 즉, 기능 구현이 캡슐화되는 것입니다.

데미테르의 법칙(Law of Demeter)은 `Tell, Don't Ask` 규칙을 따를 수 있도록 만들어 주는 또 다른 규칙입니다. 데미테르의 법칙은 다음과 같이 간단한 규칙으로 구성됩니다.

- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출

```java
public void processSome(Member member) {
    if(member.getDate().getTime() < ...) { // 데미테르 법칙 위반
        ...
    }
}
```
이때 위 코드는 데미테르의 법칙을 어긴 것입니다. 데미테르의 법칙에 따르면 파라미터로 전달 받은 객체의 메서드만 호출하도록 되어 있는데, 위 코드의 경우 파라미터로 전달받은 member의 getDate() 메서드를 호출한 뒤에, 다시 getDate()가 리턴한 Date 객체의 getTime()메서드를 호출했기 때문입니다.

따라서 데미테르의 법칙을 따르려면, 위 코드를 member 객체에 대한 한 번의 메서드 호출로 변경해 주어야 합니다. 이는 결국 데이터 중심이 아닌 기능 중심으로 코드를 작성하도록 유도하기 때문에, 기능 구현의 캡슐화를 향상시켜 줍니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77843482-8ff08280-71d8-11ea-9a31-eb17f8d98591.png)
