# 절차지향
절차 지향이라고 해서 뭔가 순서에 따라 프로그래밍하는 방식을 생각할 수 있으나, 사실 여기서의 절차는 영어 단위를 우리말로 옮긴 것 뿐입니다. 각 프로시저는 데이터를 사용해서 기능을 구현하며, 필요에 따라 다른 프로시저를 사용하기도 합니다. 또한 여러 프로시저가 동일한 데이터를 공유합니다. 이 점은 양날의 검입니다. 예를 들어서 한 데이터를 사용하는 프로시저가 많을수록 그 데이터의 타입을 변경하기 어려워집니다.

만약 전자 장비의 꺼짐/켜짐 상태를 저장하기 위해 boolean 타입이고 이름이 isOn이라는 데이터를 사용한다고 가정해보겠습니다.

이 데이터를 사용하는 프로시저는 모두 isOn을 boolean 타입으로 처리할 것입니다. 그런데, 요구 사항이 변경되어서 꺼짐/켜짐 상태뿐만 아니라 대기 상태를 추가해야한다고 해봅시다. 이 요구사항이 반영하기 위해 isOn 데이터 타입을 boolean 타입에서 열거 타입으로 변경하게 되면, 이 데이터를 사용하는 모든 프로시저도 함께 수정해 주어야 합니다.

이러한 문제는 절차 지향적으로 프로그램을 구성할 때 매우 흔하게 발생하는 문제들입니다. 이로 인해 새로운 요구사항이 생겨서 프로그램의 한 곳을 수정하게 되면, 다른 곳에서 문제가 발생하고, 다시 그 곳을 수정하면 또 다른 곳에서 문제가 발생하는 악순환이 발생하기도 합니다. 이는 결국 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현을 투입하게 만듭니다.

# 객체 지향
절차 지향과 달리 객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶습니다. 객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성합니다.

각 객체는 자신만의 데이터와 프로시저를 갖습니다. 객체는 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있게 된다. 객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용하는데, 이때 프로시저는 자신이 속한 객체의 데이터에만 접근할 수 있으며, 다른 객체에 속한 데이터에는 접근할 수 없습니다.

모든 프로시저가 데이터를 공유하는 절차 지향과 달리 객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 하고, 프로그램의 규모가 작을 때에는 절차 지향 방식보다 복잡한 구조를 갖게 됩니다.

하지만, 객체 지향적으로 만든 코드에서는 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는 영향을 주지 않기 때문에, 요구 사항의 변화가 발생했을 때 절차 지향 방식보다 프로그램을 더 쉽게 변경할 수 있는 장점을 갖습니다. 


## 인터페이스와 클래스

객체는 객체가 제공하는 기능으로 정의됩니다. 보통 객체가 제공하는 기능을 오퍼레이션이라고 합니다. 즉, 객체는 오퍼레이션으로 정의가 됩니다. 객체가 제공하는 기능을 사용한다는 것은 결국 객체의 오퍼레이션을 사용한다는 의미가 됩니다. 그런데, 객체가 제공하는 오퍼레이션을 사용할 수 있으려면, 그 오퍼레이션의 사용법을 알아야 합니다.

예를 들어, 소리 크게 제어 객체가 있는데, 말 그대로 소리 크기를 높이거나 줄이거나 혹은 음소거를 하는 오퍼레이션을 가진 객체입니다. 이 오퍼레이션을 사용하려면 당연히 사용법을 알아야 하는 것입니다. 오퍼레이션의 사용법은 일반적으로 다음과 같이 세 개로 구성되며, 이 세가지를 합쳐서 시그니처(Signature)라고 부릅니다.

- 기능 식별 이름
- 파라미터 및 파라미터 타입
- 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 `인터페이스`라고 부르며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 타입입니다. 여기서 말하는 인터페이스는 자바 언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어입니다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 됩니다.

인터페이스는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않습니다. 실제 객체의 구현을 정의하는 것은 클래스입니다. 이 클래스에는 오퍼레이션을 구현하는데 필요한 데이터 및 오퍼레이션의 구현이 포함됩니다. 여기서의 클래스도 자바나 C#등의 언어에서 말하는 클래스와 유사합니다.

인터페이스, 오퍼레이션, 클래스, 객체의 관계를 정리해보면 아래와 같습니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/77655970-8daede00-6fb6-11ea-8a08-4c90d78784ea.png)


## 메시지
객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 됩니다. 예를들어, 파일에서 데이터를 읽어오는 객체가 있고, 데이터를 암호화 해주는 객체가 있습니다. 파일에 데이터를 쓰는 객체가 있다고 합시다. 이 경우, 특정 파일에서 데이터를 읽어와 암호화 한 뒤에 다른 파일로 쓰는 프로그램은 아래와 같이 세 개의 객체로 구성될 수 있을 것입니다. 물론, 실제로는 더 복잡하겠지만 예를 들기 위해 단순화시켰습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77659230-22b3d600-6fbb-11ea-9c76-45fde0740944.png)


파일 읽기 객체가 제공하는 인터페이스가 다음과 같은 오퍼레이션을 제공한다고 합시다.

- 오퍼레이션 이름: read
- 파라미터: 없음
- 리턴 타입: byte 배열

이 경우, 암호화 처리 객체는 파일 읽기 객체에게 read 오퍼레이션을 실행해달라는 요청을 전달하며, 요청을 받은 파일 읽기 객체는 해당 요청에 해당하는 기능을 실행한 뒤에 응답을 전달하게 됩니다. 이 때 오퍼레이션의 실행을 요청하는 것을 `메시지를 보낸다.`고 표현합니다.

자바와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당됩니다. 아래 코드를 봅시다.

```java
FileInputStream is = new FileInputStream(fileName);
byte[] data = new byte[512];
int readBytes = is.read(data);
```
이 코드에서 is 변수는 FileInputStream 타입의 객체를 참조하는데, is.read(data) 코드는 is가 참조하는 객체에 read() 오퍼레이션을 실행해 달라는 메시지를 전송한다고 생각하면 됩니다.





