# 절차지향
절차 지향이라고 해서 뭔가 순서에 따라 프로그래밍하는 방식을 생각할 수 있으나, 사실 여기서의 절차는 영어 단위를 우리말로 옮긴 것 뿐입니다. 각 프로시저는 데이터를 사용해서 기능을 구현하며, 필요에 따라 다른 프로시저를 사용하기도 합니다. 또한 여러 프로시저가 동일한 데이터를 공유합니다. 이 점은 양날의 검입니다. 예를 들어서 한 데이터를 사용하는 프로시저가 많을수록 그 데이터의 타입을 변경하기 어려워집니다.

만약 전자 장비의 꺼짐/켜짐 상태를 저장하기 위해 boolean 타입이고 이름이 isOn이라는 데이터를 사용한다고 가정해보겠습니다.

이 데이터를 사용하는 프로시저는 모두 isOn을 boolean 타입으로 처리할 것입니다. 그런데, 요구 사항이 변경되어서 꺼짐/켜짐 상태뿐만 아니라 대기 상태를 추가해야한다고 해봅시다. 이 요구사항이 반영하기 위해 isOn 데이터 타입을 boolean 타입에서 열거 타입으로 변경하게 되면, 이 데이터를 사용하는 모든 프로시저도 함께 수정해 주어야 합니다.

이러한 문제는 절차 지향적으로 프로그램을 구성할 때 매우 흔하게 발생하는 문제들입니다. 이로 인해 새로운 요구사항이 생겨서 프로그램의 한 곳을 수정하게 되면, 다른 곳에서 문제가 발생하고, 다시 그 곳을 수정하면 또 다른 곳에서 문제가 발생하는 악순환이 발생하기도 합니다. 이는 결국 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현을 투입하게 만듭니다.

# 객체 지향
절차 지향과 달리 객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶습니다. 객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성합니다.

각 객체는 자신만의 데이터와 프로시저를 갖습니다. 객체는 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있게 된다. 객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용하는데, 이때 프로시저는 자신이 속한 객체의 데이터에만 접근할 수 있으며, 다른 객체에 속한 데이터에는 접근할 수 없습니다.

모든 프로시저가 데이터를 공유하는 절차 지향과 달리 객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 하고, 프로그램의 규모가 작을 때에는 절차 지향 방식보다 복잡한 구조를 갖게 됩니다.

하지만, 객체 지향적으로 만든 코드에서는 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는 영향을 주지 않기 때문에, 요구 사항의 변화가 발생했을 때 절차 지향 방식보다 프로그램을 더 쉽게 변경할 수 있는 장점을 갖습니다. 


## 인터페이스와 클래스

객체는 객체가 제공하는 기능으로 정의됩니다. 보통 객체가 제공하는 기능을 오퍼레이션이라고 합니다. 즉, 객체는 오퍼레이션으로 정의가 됩니다. 객체가 제공하는 기능을 사용한다는 것은 결국 객체의 오퍼레이션을 사용한다는 의미가 됩니다. 그런데, 객체가 제공하는 오퍼레이션을 사용할 수 있으려면, 그 오퍼레이션의 사용법을 알아야 합니다.

예를 들어, 소리 크게 제어 객체가 있는데, 말 그대로 소리 크기를 높이거나 줄이거나 혹은 음소거를 하는 오퍼레이션을 가진 객체입니다. 이 오퍼레이션을 사용하려면 당연히 사용법을 알아야 하는 것입니다. 오퍼레이션의 사용법은 일반적으로 다음과 같이 세 개로 구성되며, 이 세가지를 합쳐서 시그니처(Signature)라고 부릅니다.

- 기능 식별 이름
- 파라미터 및 파라미터 타입
- 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 `인터페이스`라고 부르며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 타입입니다. 여기서 말하는 인터페이스는 자바 언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어입니다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 됩니다.

인터페이스는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않습니다. 실제 객체의 구현을 정의하는 것은 클래스입니다. 이 클래스에는 오퍼레이션을 구현하는데 필요한 데이터 및 오퍼레이션의 구현이 포함됩니다. 여기서의 클래스도 자바나 C#등의 언어에서 말하는 클래스와 유사합니다.

인터페이스, 오퍼레이션, 클래스, 객체의 관계를 정리해보면 아래와 같습니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/77655970-8daede00-6fb6-11ea-8a08-4c90d78784ea.png)


## 메시지
객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 됩니다. 예를들어, 파일에서 데이터를 읽어오는 객체가 있고, 데이터를 암호화 해주는 객체가 있습니다. 파일에 데이터를 쓰는 객체가 있다고 합시다. 이 경우, 특정 파일에서 데이터를 읽어와 암호화 한 뒤에 다른 파일로 쓰는 프로그램은 아래와 같이 세 개의 객체로 구성될 수 있을 것입니다. 물론, 실제로는 더 복잡하겠지만 예를 들기 위해 단순화시켰습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77659230-22b3d600-6fbb-11ea-9c76-45fde0740944.png)


파일 읽기 객체가 제공하는 인터페이스가 다음과 같은 오퍼레이션을 제공한다고 합시다.

- 오퍼레이션 이름: read
- 파라미터: 없음
- 리턴 타입: byte 배열

이 경우, 암호화 처리 객체는 파일 읽기 객체에게 read 오퍼레이션을 실행해달라는 요청을 전달하며, 요청을 받은 파일 읽기 객체는 해당 요청에 해당하는 기능을 실행한 뒤에 응답을 전달하게 됩니다. 이 때 오퍼레이션의 실행을 요청하는 것을 `메시지를 보낸다.`고 표현합니다.

자바와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당됩니다. 아래 코드를 봅시다.

```java
FileInputStream is = new FileInputStream(fileName);
byte[] data = new byte[512];
int readBytes = is.read(data);
```
이 코드에서 is 변수는 FileInputStream 타입의 객체를 참조하는데, is.read(data) 코드는 is가 참조하는 객체에 read() 오퍼레이션을 실행해 달라는 메시지를 전송한다고 생각하면 됩니다.

## 객체의 책임과 크기

객체는 객체가 제공하는 기능으로 정의된다고 했는데, 이는 다시 말하면 객체마다 자신만의 책임(responsibility)이 있다는 의미를 갖습니다. 예를 들어, 위 그림에서 설명한 암호화 처리 객체는 제공 받은 데이터를 암호화해서 다른 파일에 보내는 책임이 있습니다.
파일 읽기 객체는 파일에서 데이터를 읽어와 제공하는 책임이 있고, 파일 쓰기 객체는 파일에 데이터를 쓰는 책임이 있습니다.

한 객체가 갖튼 책임을 정의한 것이 바로 타입/인터페이스라고 생각하면 됩니다. 그럼, 객체가 갖는 책임은 어떻게 결정될까요? 이 결정을 하는 것이 바로 객체 지향 설계의 출발점입니다.

위의 세 개의 객체가 서로 다른 책임을 지는데, 이런 책임 할당이 처음부터 바로 결정되는 것은 아닙니다. 처음에는 프로그램을 만들기 위해 필요한 기능 목록을 정리해야 합니다. 

다음은 기능 목록을 정리한 예입니다.

- 파일의 byte 데이터를 제공합니다.
- 파일에 byte 데이터를 씁니다.
- byte 데이터를 암호화해서 새로운 byte 데이터를 생성합니다.
- 전체 흐름을 제어합니다.

이 기능을 어떻게 객체들에게 분배하느냐에 따라서 객체의 구성이 달라집니다. 

객체 지향적으로 프로그래밍을 할 때, 가장 어려우면서 가장 중요한 것이 바로 객체마다 기능을 할당하는 과정입니다.

기능이 몇개 안되는 경우에도 다양한 조합의 구성이 가능하기 때문에, 이런 다양한 조합 중에서 알맞은 구성을 찾아내는 것은 쉽지 않습니다.

상황에 따라 객체가 가져야 할 기능의 종류와 개수가 달라지기 때문에, 모든 상황에 들어맞는 객체-책임 구성 규칙이 존재하는 것은 아닙니다. 하지만, 객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 존재하는데, 그 규칙은 바로 객체가 갖는 책임의 크기는 작을수록 좋다는 것입니다. 객체가 갖는 책임이 작아야 한다는 것은 객체가 제공하는 기능의 개수가 적다는걸 의미합니다.

만약 한 객체에 많은 기능이 포함된다면, 그 기능과 관련된 데이터들도 한 객체에 모두 포함됩니다. 이 구조는 객체에 정의된 많은 오퍼레이션들이 데이터들을 공유하는 방식으로 프로그래밍 된다는 것을 의미하는데, 이는 곧 데이터를 중심으로 개발되는 절차 지향 방식과 동일한 구조가 됩니다. 따라서 객체가 갖는 책임이 커질수록 절차 지향적으로 구조가 변질되며, 절차 지향의 가장 큰 단점인 기능 변경의 어려움 문제가 발생하게 됩니다.

따라서 객체가 갖는 책임의 크기는 작아질수록 객체 지향의 장점인 변경의 유연함을 얻을 수 있게 됩니다. 객체의 크기와 관련된 원칙이 있는데 그 원칙은 바로 단일 책임 원칙입니다. 단일 책임 원칙은 이름에서 알 수 있듯이 객체는 단 한개의 책임만을 가져야 한다는 원칙입니다. 이 원칙에 따르면 아래 그림의 객체 구조는 다음과 같이 네 개의 객체가 각각 한개의 책임만을 갖도록 재구성됩니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/77762596-1c862e00-707d-11ea-8f2d-a4c6e2fb56d3.png)

단일 책임 원칙을 따르다 보면 자연스럽게 기능의 세부 내용이 변경될 때, 변경해야 할 부분이 한 곳으로 집중됩니다.

예를 들어, 파일을 읽어 오는 방법을 변경해야 한다면 `파일 읽기` 책임을 가진 객체의 코드만 수정되며, 다른 객체의 코드를 수정해야 할 가능성은 낮아집니다. 비슷하게 암호화 알고리즘을 변경해야 할 경우, `byte 암호화` 객체의 코드만 변경될 뿐 다른 객체의 코드가 변경될 가능성은 줄어듭니다. 즉, 단일 책임 원칙은 변경의 유연함을 얻기 위한 가장 기본 원칙이 됩니다.

> 객체가 책임을 갖는다는 것은  객체가 역할을 수행한다는 의미를 갖습니다. 앞서 예에서 `흐름 제어` 책임을 갖는 객체는 흐름을 제어하는 역할을 수행하는 객체라고 표현하기도 합니다. 객체 지향 관련 서적이나 글을 읽을 때 객체의 역할이란 단어가 나오면 이는 곧 객체의 책임과 동일한 의미로 사용됨을 기억합시다.

## 의존
객체 지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이용해서 자신의 기능을 완성하는 객체가 출현하게 됩니다. 예를 들어, 앞서 `흐름 제어` 객체는 `byte 암호화` 객체와 `파일 읽기` 객체, `파일 쓰기` 객체를 이용해서 파일 데이터 암호화 프로그램의 실행 흐름 기능을 완성하였습니다.

한 객체가 다른 객체를 이용한다는 것은, 실제 구현에서는 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출한다는 것을 뜻합니다. `흐름 제어` 객체의 실제 코드는 다음과 같이 다른 객체의 메서드를 호출해서 기능을 완성해 나갈 것입니다.

```java
public class FlowController {

    //fileName 필드 초기화 코드 생략
    public void process() {
        FileDataReader reader = new FileDataReader(fileName); // 객체 생성
        byre[] plainText = reader.read(); // 메서드 호출

        ByteEncryptor encryptor = new ByteEncryptor(); // 객체 생성
        byte[] encryptedBytes = encryptor.encrypt(plainBytes); // 메서드 호출

        FileDataWriter writer = new FileDataWriter(); // 객체 생성

        writer.write(encrypyedBytes); // 메서드 호출
    }
}
```
이렇게 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현합니다.

위 코드에서 FlowController가 FileDataReader에 의존한다고 표현할 수 있습니다. 객체를 생성하거나 메서드를 호출하는 것뿐만 아니라 파라미터로 전달받는 경우에도 의존한다고 볼 수 있습니다.

예를 들어, 아래 코드와 같이 ByteEncryptor를 파라미터로 받으면, 메서드 구현 과정에서 파라미터로 전달받은 ByteEncryptor 객체를 사용할 가능성이 높기 때문에, 이는 process() 메서드가 ByteEncryptor에 의존한다고 볼 수 있습니다.

```java
public void process(ByteEncrpytor encryptor) {
    ...// 내부에서 encryptor를 사용할 가능성이 높습니다.
}
```

객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받든 다른 타입에 의존을 한다는 것은 의존하는 타입에 변경이 발생할 때 나도 함꼐 변경될 가능성이 높다는 것을 뜻합니다. 예를 들어, FileDataWriter의 생성자가 String 타입으로 파일 경로를 받도록 수정된다면, FlowController 클래스 코드에서 FileDataWriter를 생성하는 코드도 알맞게 수정해 주어야 합니다.

```java
public class FlowController {

    //outfileName 필드 초기화 위한 코드 추가 발생
    public void process() {
        ...
       //FileDataWriter writer = new FileDataWriter(); // 기존 코드
         FileDataWriter writer = new FileDataWriter(outfileName); // 변경 발생
        writer.write(encrypyedBytes); // 메서드 호출
    }
}
```

의존의 영향은 꼬리에 꼬리를 문 것처럼 전파되는 특징을 갖습니다. 예를 들어, 아래 그림과 같이 C 클래스가 B 클래스에 의존하고, B클래스가 A 클래스에 의존한다고 합시다. 이 경우 A 클래스의 변경은 B 클래스에 영향을 줄 가능성이 높고, 이는 다시 C 클래스에 영향을 주게됩니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/77823922-f7a7be80-7141-11ea-8c86-ac38ef5f2e9c.png)

의존의 이런 특징 때문에 의존이 순환해서 발생할 경우 다른 방법이 없는지 고민해야 합니다. 아래 그림에서 A 클래스의 변화는 C 클래스까지 영향을 줄 수 있는데, C 클래스의 변화는 다시 A 클래스에 영향을 줄 수 있습니다. 이는 결국 A 클래스를 변경한 여파가 다시 A 클래스의 또 다른 변화를 유발할 수 있다는 것을 뜻합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/77823991-83214f80-7142-11ea-84c9-cee049efbdee.png)

순환 의존의 이런 특징 때문에, 순환 의존이 발생할 경우 적극적으로 이를 해소하는 방법을 찾아야 합니다. 순환 의존이 발생하지 않도록 하는 원칙 중의 하나로 의존 역전 원칙(Dependency inversion principle; DIP)이 있는데, 이에 대한 내용은 5장에서 살펴보도록 하겠습니다.

## 의존의 양면성
다음 코드를 보겠습니다.

```java
public class Authenticate {

    public boolean authenticate(String id, String password) {
        Member m = findMemberById(id);
        if(m == null) return false;
        
        return m.equalPassoword(password); // password가 m의 암호와 동일하면 true
    }
    ...
}
```

Authenticator 클래스를 사용하는 코드는 다음과 같이 authenticate() 메서드를 이용해서 사용자가 입력한 암호가 올바른지 여부를 판단할 것입니다.

```java
public class AuthenticationHandler {

    public void handleRequest(String inputId, 
    String inputPassword) {
        Authenticate auth = new Authenticate();
        if(auth.authenticate(inputId, inputPassword)) {
            // 아이디 암호 일치할 때의 처리
        } else {
            // 아이디 암호 일치하지 않을 때의 처리
        }
    }
}
```

위 코드에서 AuthenticationHandler 클래스는 Authenticator 클래스를 사용하고 있습니다. 즉 AuthenticationHandler 클래스가 Authenticator 클래스에 의존하고 있고, Authenticator 클래스에 변화가 생기면 AuthenticationHandler 클래스에도 영향을 받게 됩니다.

그런데 잘못된 아이디를 입력한 것인지 아니면 암호가 틀린 것인지 여부를 확인해서 시스템 상에 로그를 남겨 달라는 요구가 추가되었습니다. 이 요구를 충족시키려면 Authenticator의 authenticate() 메서드는 단순히 boolean 값을 리턴하면 안됩니다. 아이디가 잘못되었는지 암호가 잘못되었는지 여부를 알려줄수 있어야 합니다. 예를 들면 AuthenticationHandler 클래스의 코드는 다음과 같이 익셉션을 통해서 인증 실패 이유를 구분할 수 있어야 합니다.

```java
public class AuthenticationHandler {

    public void handleRequest(String inputId, 
    String inputPassword) {
        Authenticate auth = new Authenticate();
        try {
            auth.authenticate(inputId, inputPassword);
             // 아이디/암호 일치하는 경우의 처리
        } catch(MemberNotFoundException ex) {
             // 아이디가 잘못된 경우의 처리
        } catch(InvalidPassowrdException ex) {
             // 암호가 잘못된 경우의 처리
        }
    }
}
```

AuthenticationHandler 클래스으를 위와 같이 작성하려면 Authentor 클래스의 authenticate() 메서드가 다음과 같이 변경되어야만 합니다.

```java
public class Authenticator {

    public void authenticate(String id, String password) {
        Member m = findMemberById(id);
        if(m == null) throw new MemberNotFoundException();

        if(!m.equalPassowrd(password)) throw new InvalidPasswordException();
    }
    ...
}
```
AuthenticationHandler 클래스가 Authenticator 클래스에 의존하고 있는 상황에서, AuthenticationHandler 클래스의 변경 요구 때문에 Authenticator 클래스에 변화가 발생한 것입니다. 이는 의존이 다음과 같이 상호간에 영향을 준다는 것을 보여줍니다.

- 내가 변경되면 나에게 의존하고 있는 코드에 영향을 줍니다.
- 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 줍니다.

