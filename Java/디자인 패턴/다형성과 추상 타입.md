# 다형성과 추상 타입

객체 지향이 주는 장점은 구현 변경의 유연함입니다. 앞서 이전 포스팅에서 객체는 캡슐화를 통해서 객체를 사용하는 다른 코드에 영향을 최소화하면서 객체의 내부 구현을 변경할 수 있는 유연함을 얻을 수 있었습니다. 유연함을 얻을 수 있도록 해 주는 또다른 방법은 추상화에 있는데, 이 장에서는 추상화가 주는 유연함에 대한 내용을 공부해 볼 것입니다.

## 상속 개요
상속은 한 타입을 그대로 사용하면서 구현을 추가할 수 있도록 해주는 방법을 제공합니다. 예를 들어, 금액 할인에 사용되는 쿠폰을 표현하기 위해 Coupon이라는 클래스를 작성했다고 합시다.

```java
public class Coupon {

    private int discountAmount;

    public Coupon(int discountAmount) {
        this.discountAmount = discountAmount;
    }

    public int getDiscountAmount() {
        return discountAmount;
    }

    public calculateDiscountPrice(int price) {
        if(price < discountAmount) 
            return 0;
        
        return price - discountAmount;
    }
}
```

Coupon 객체를 이용해서 할인된 금액을 구하는 코드는 다음과 같이 Coupon 클래스의 calculateDiscountPrice() 메서드를 사용할 것입니다.

```java
Coupon coupon = new Counpon(3000);
int price = coupon.calculateDiscountPrice(product.getPrice);
```
금액 할인 쿠폰 중, 상품 금액이 지정한 금액 이상인 경우에만 할인을 받도록 하는 쿠폰을 새로 만들고 싶습니다. 이미 Coupon 클래스가 쿠폰의 기본적인 기능을 제공하고 있으므로 이 기능을 확장해서 새로운 쿠폰 기능을 구현하면 좀 더 수월하게 새로운 쿠폰 기능을 제공할 수 있을 것 같습니다. 바로 이럴 때 상속을 사용합니다.

다음은 Coupon 클래스를 상속받아 새로운 클래스를 만드는 예를 보여주고 있습니다.

```java
public class LimitPriceCoupon extends Coupon {

    private int limitPrice;

    public LimitPriceCoupon(int limitPrice, int discountAmount) {
        super(discountAmount);
        this.limitPrice = limitPrice;
    }

    public int getLimitPrice() {
        return limitPrice;
    }

}
```
```java
    @Override
    public int calculateDiscoutPrice(int price) { // 재정의 
        if(price < limitPrice>)
            return price;

        return super.calculateDiscountPrice(price);
    }
}
```

위 코드에서 LimitPriceCoupon 클래스는 Coupon 클래스를 상속받고 있습니다. 이때 상속이 되는 Coupon 클래스를 상위(super) 클래스 또는 부모 클래스라고 부르고, 상속받는 LimitPriceCoupon 클래스를 하위(sub) 클래스 또는 자식(child) 클래스라고 부릅니다.

자식 클래스는 부모 클래스에 정의된 구현을 물려받습니다. 예를 들어, Coupon 클래스에 getDiscountAmount() 메서드가 정의되어 있고, LimitPriceCoupon 클래스에는 이 메서드가 정의되어 있지 않습니다. 그렇지만 LimitPriceCoupon 클래스는 Coupon 클래스에 정의된 getDiscountAmoun() 메서드를 물려받았기 때문에, LimitPriceCoupon 클래스의 객체를 생성한 뒤에 getDiscountAmount() 메서드를 실행할 수 있습니다.


```java
LimitPriceCoupon ipCoupon = new LimitPriceCoupon(5000, 1000);
int discountAmount = ipCoupon.getDiscountAmount(); // Coupon 클래스에서 물려 받습니다.
int limitPrice = ipCoupon.getLimitPrice(); // LimitPriceCoupon 클래스에 정의
```
프로그래밍 언어마다 하위 타입에서 물려받을 수 있는 것이 다를 수 있는데, 다수의 언어에서 private 범위를 갖는 메서드나 필드를 제외한 나머지를 물려받을 수 있도록 하고 있습니다.

위 예에서 Coupon 클래스의 getDiscountAmount() 메서드는 접근 범위가 public이므로 하위 클래스인 LimitPriceCoupon 클래스가 물려받습니다. 반면에 Coupon 클래스의 discountAmount 필드는 private이기 때문에 하위 클래스인 LimitPriceCoupon 클래스에서 접근할 수 없습니다.


## Mock 객체의 사용
```java
public void testProcess() {

    ByteSource mockSource = new MockByteSource();
    FlowController fc = new FlowController(mockSource);
    fc.process();

    // 결과가 정상적으로 만들어졌는지 확인하는 코드
}

class MockByteSource implements ByteSource {

    public byte[] read() {
        byte[] data = new byte[128];
        // data를 테스트 목적의 데이터로 초기화
        return data;
    }
}
```

위 코드에서 MockByteSource 클래스는 ByteSource 인터페이스를 상속받아 구현하고 있는데, 이 클래스의 read() 메서드는 테스트에 필요한 byte 데이터를 직접 생성합니다.(즉, 소켓이나 파일 등에서 읽어오지 않고 테스트에서 사용할 데이터를 하드코딩 합니다.) 그리고 FlowController 객체는 사용할 ByteSource 객체로 FileDataReader 대신에 MockByteSource를 사용하도록 하였습니다.


이제 fc.process() 코드를 실행하면, MockByteSource의 read() 메서드를 통해서 byte 데이터를 읽어 오게 됩니다. byte 데이터를 읽어 왔으므로 FlowController의 process() 메서드는 이 후 코드를 정상적으로 실행할 수 있습니다. 즉, FileDataReader 클래스 없이 FlowController 클래스를 테스트 할 수 있는 것입니다.

이렇게 실제 콘크리트 클래스 대신에 진짜처럼 해동하는 객체를 Mock(가짜, 모의) 객체라고 부르는데, Mock 객체를 사용함으로써 실제 사용할 콘크리트 클래스의 구현 없이 테스트 할 수 있습니다. Mock 객체를 만드는 방법은 다양하게 존재하지만, 사용할 대상을 인터페이스로 추상화하면 좀 더 쉽게 Mock 객체를 만들 수 있게 되며, 이는 사용할 코드의 완성을 기다릴 필요 없이 내가 만든 코드를 먼저 빠르게 테스트 할 수 있도록 해줍니다.


## 설계 원칙 SOLID

객체지향적으로 설계하는데 가장 기본이 되는 설계 원칙인 SOLID에 대해서 살펴볼것입니다. SOLID 설계 원칙은 앞서 살펴봤었던 설계 관련 내용들을 체계적으로 정리한 것으로서 이 원칙만으로도 좋은 설계를 하는데 큰 도움이 될 것입니다.

- 단일 책임 원칙 (Single responsibility principle; SRP)
- 개방-폐쇠 원칙 (Open-closed principle; OCP)
- 리스코프 치환 원칙 (Liskov substitution principlel; LSP)
- 인터페이스 분리 원칙(Interface segregation principle; ISP)
- 의존 역전 원칙(Dependency inversion principle; DIP)

이들 원칙들은 지금까지 공부했던 객체 지향 설계에 대한 내용들보다 명확하게 만들어 줄 것입니다. 


## 단일 책임 원칙(Single responsibility principle)

객체 지향의 기본 책임을 객체에게 할당하는 데 있습니다. 객체를 객체로 존재하게 하는 이유가 책임인데, 단일 책임 원칙(Single responsibility principle; SRP)은 이 책임과 관련된 원칙입니다. 단일 책임 원칙은 다음과 같은 규칙입니다.

- 클래스는 단 한 개의 책임을 가져야 합니다.

클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에, 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 합니다. 이런 이유로 이 원칙은 다른 말로 ` 클래스를 변경하는 이유는 단 한개여야 한다`라고 표현합니다.

객체에게 책임을 할당하는 것이 객체 설계의 기본인 만큼, 단일 책임 원칙은 가장 중요한 원칙 중 하나입니다. 반드시 숙지하고 넘어가야 합니다. 이 단일 책임 원칙이 잘 지켜지지 않으면 다른 원칙들도 그 효과가 반감되기 때문에 최대한 지켜야하는 원칙이기도 합니다. 그런데, 단일 책임 원칙은 가장 어려운 원칙이기도 합니다. 한 개의 책임에 대한 정의가 명확하지 않고, 책임을 도출하기 위해서는 다양한 경험이 필요하기 때문입니다.

우선, 책임에 대해서 살펴보기에 앞서 단일 책임 원칙을 따르지 않으면 어떤 문제가 발생하는지 알아볼 것입니다. 이 과정에서 단일 책임에 대한 감을 잡도록 하겠습니다.

## 단일 책임 원칙 위반이 불러오는 문제점

HTTP 프로토콜을 이용해서 데이터를 읽어 와 화면에 보여주는 기능이 필요한 상황을 가정해 봅시다. 이를 구현하기 위해 ㅁ클래스를 아래 코드와 같이 작성하였습니다.

```java
public class DataViewer {

    public void display() {
        String data = loadHtml();
        updateGui(data);
    }

    public String loadHtml() {
        HttpClient client = new HttpClient();
        client.connect(url);
        return client.getResponse();
    }

    private void updateGui(String data) {
        GuiData guiModel = parseDataToGuiData(data);
        tableUI.changeData(guiModel);
    }

    private GuiData parseDataToGuiData(String data) {
        ... // 파싱 처리코드
    }
    ... // 기타 필드 등 다른 코드
}
```
display() 메서드는 loadHtml()에서 읽어 온 HTML 응답 문자열을 updateGui()에 보냅니다. updateGui() 메서드는 parseDataToGuiData() 메서드를 이용해서 HTML 응답 메시지를 GUI에 보여주기 위한 GuiData 객체로 변환한 뒤에 실제 tableUI를 이용해서 데이터를 보여주고 있습니다.

DataViewer를 잘 사용하고 있는 도중에 데이터를 제공하는 서버가 HTTP 프로토콜에서 소켓 기반의 프로토콜로 변경되었습니다. 이 프로토콜은 응답 데이터로 byte를 제공합니다. 이제 어떤 일이 벌어질까요? 데이터를 읽어오는 기능의 변화로 인해 DataViewer는 내부적으로 아래와 같이 변화가 연쇄적으로 발생할 것입니다.

```java
public class DataViewer {

    public void display() {
        byte[] data = loadHtml();
        updateGui(data);
    }
    
    public byte[] loadHtml() {
        SocketClient client = new SocketClient();
        client.connect(server, port);
        return client.read();
    }

    public void updateGui(byte[] data) {
        GuiData guiModel = parseDataToGuiData(data);
        tableGui.changeData(guiModel);
    }

    private GuiData
    parseDataToGuiData(byte[] data) {
        파싱 코드 변경 ... // 파싱 처리 코드
    }
    ... // 기타 필드 등 다른 코드
}
```

이러한 연쇄적인 코드 수정은 두 개의 책임-데이터 읽는 책임과 화면에 보여주는 책임이 한 클래스에 아주 밀접하게 결합되어 있어서 발생한 증상입니다. 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향은 비례해서 증가하게 되는데, 이는 결국 코드를 절차 지향적으로 만들어 변경을 어렵게 만듭니다.

데이터 읽기와 데이터를 화면에 보여주는 책임을 두 개의 클래스로 분리하고 둘 간에 주고받을 데이터를 저수준의 String이 아닌 알맞게 추상화된 타입을 사용하면, 데이터를 읽어 오는 부분의 변경 때문에 화면을 보여주는 부분의 코드가 변경되는 상황을 막을 수 있을 것입니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/78144547-b4fc2400-746a-11ea-8bcd-6715f718c1ff.png)


위 그림에서 DataLoader 클래스가 내부적으로 구현을 변경하더라도, DataDisplayer는 영향을 받지 않습니다. 즉, 한 클래스에 섞여 있던 책임을 두 클래스로 분리함으로써 변경의 여파를 줄일 수 있게 되는 것입니다.

단일 책임 원칙을 어길 때 발생하는 또 다른 문제점은 재사용을 어렵게 한다는 것입니다. 앞서 DataViewer 클래스의 예제로 다시 돌아가보겠습니다. DataViewer 클래스가 HTTP 연동을 위해서 HttpClient라는 패키지를 사용하고, 화면에 데이터를 보여주기 위해 GuiComp라는 패키지를 사용한다고 가정합시다. HttpClient 패키지와 GuiComp 패키지가 각각 별도의 jar 파일로 제공된다고 하겠습니다. 이 상태에서 데이터를 읽어오는 기능이 필요한 DataRequiredClient 클래스를 만들어야 한다면, DataRequiredClient 클래스를 구현하기 위해 필요한 것은 DataViewer 클래스와 HttpClient jar 파일입니다. 하지만 실제로는 DataViewer가 GuiComp를 필요로 하므로 GuiComp jar 파일까지 필요합니다. 즉, 실제 사용하지 않는 기능이 의존하는 jar 파일까지 필요한 것입니다.


단일 책임 원칙에 따라 책임이 분리되었다면, DataRequiredClient 클래스를 구현할 때에는 데이터를 읽어오는 데 필요한 dataLoader 패키지와 HttpClient 패키지만 필요하며, 데이터를 읽어 오는 것과 상관없는 GuiComp 패키지나 datadisplay 패키지는 포함시킬 필요가 없어집니다.

## 책임이란 변화에 대한 것

단일 책임 원칙을 지키지 않았을 때, 한 책임의 구현 변경에 의해 다른 책임과 관련된 코드가 변경될 가능성이 높아진다는 것을 예를 통해 살펴보았습니다. 앞서 DataViewer 클래스는 수정에 대한 문제가 없었을 것입니다. (물론 재사용 측면에서는 여전히 문제가 남아있습니다.) 기능 변경 요구가 없을 때 수정에 대한 문제가 없다는 것은, 뒤집어 보면 책임의 단위는 변화되는 부분과 관련된다는 의미가 됩니다. 예를 들어, DataViewer 클래스에서 데이터를 읽어 오는 기능에 변화가 발생했는데, 이런 변화를 통해 데이터를 읽어 오는 기능이 별도로 분리되어야 할 책임이라는 것을 알 수 있는 것입니다.

각각의 책임은 서로 다른 이유로 변경되고, 서로 다른 비율로 변경되는 특징이 있습니다. 

예를 들어, 데이터를 읽어 오는 책임의 기능이 변경될 때 데이터를 보여주는 책임은 변경되지 않습니다. 반대로 데이터를 테이블에서 그래프로 바꿔서 보여주더라도 데이터를 읽어 오는 기능은 변경되지 않습니다. 따라서 서로 다른 이유로 바뀌는 책임들이 한 클래스에 함꼐 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다고 볼 수 있습니다.

하지만, 서로 다른 이유로 변경되는 것을 알아채려면 많은 프로그래밍 경험을 필요로 하기 때문에 경험이 적은 프로그래머가 단일 책임 원칙을 처음부터 잘 지키기란 쉽지 않습니다. 그러면 어떻게 하면 단일 책임 원칙을 잘 지킬 수 있을까요? 그 방법은 바로 메서드를 실행하는 것이 누구인지 확인해 보는 것입니다.


![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/78153307-e2020400-7475-11ea-86ee-75a3b970100d.png)


위 그림에서 DataViewer 클래스는 display() 메서드와 loadData() 메서드를 제공하는데, GUIApplication은 display()를 사용하고, DataProcessor는 loadData()를 사용한다고 해 봅시다. GUIApplication이 화면에 표시되는 방식을 변경해야 할 경우, 변경되는 메서드는 DataViewer 클래스의 display() 메서드 입니다. 반면에 DataProcessor가 읽어 오는 데이터를 String이 아닌 다른 타입으로 변경해야 할 경우, DataViewer의 loadData()
메서드는 String이 아닌 DataProcessor가 요구하는 타입으로 변경될 가능성이 높습니다. 이렇게 클래스의 사용자들이 서로 다른 메서드들을 사용한다면 그들 메서드는 각각 다른 책임에 속할 가능성이 높고, 따라서 책임 분리 후보가 될 수 있습니다.


## 개방 폐쇄 원칙(Open - closed principle)

개방 폐쇄 원칙(Open-close principle; OCP)은 다음과 같습니다.

- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다.

말이 좀 어려운데, 이 말을 구체적으로 풀어보면 다음과 같습니다.

- 기능을 변경하거나 확장할 수 있으면서
- 그 기능을 사용하는 코드는 수정하지 않습니다.

기능을 변경하면서 동시에 그 기능을 사용하는 코드를 수정하지 말라니.... 이것이 진정 가능한지 궁금하겠지만, 이러한 코드를 앞에서 추상화를 이용해서 구현했었습니다.

개방 폐쇄 원칙을 구현하는 또 다른 방법은 상속을 이용하는 것입니다. 상속은 상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 구현을 오버라이딩 할 수 있는 방법을 제공합니다.

예를 들어, 클라이언트의 요청이 왔을 때 데이터를 HTTP 응답 프로토콜에 맞춰 데이터를 전송해주는 ResponseSender가 있다고 합시다.

```java
public class ResponseSender {

    private Data data;

    public ResponseSender(Data data) {
        this.data = data;
    }

    public Data getData() {
        return data;
    }

    public void send() {

        sendHeader();
        sendBody();

    }

    protected void sendHeader() {
        // 헤더 데이터 전송
    }

    protected void sendBody() {
        // 텍스트 데이터 전송
    }
}
```

ResponseSender 클래스의 send() 메서드는 헤더와 몸체 내용을 전송하기 위해 sendHeader() 메서드와 sendBody() 메서드를 차례대로 호출하며, 이 두 메서드는 알맞게 HTTP 응답 데이터를 생성합니다. sendHeader() 메서드와 sendBody() 메서드는 protected 공개 범위를 갖고 있기 때문에, 하위 클래스에서 이 두 메서드를 오버라이딩 할 수 있습니다.

만약 압축해서 데이터를 전송받는 기능을 추가하고 싶다면 어떻게 하면 될까요? 간단합니다. ResponseSender 클래스를 상속받는 클래스에서 sendHeader() 메서드와 sendBody() 메서드를 오버라이딩 하면 됩니다.

```java
public class ZippedResponseSender extends ResponseSender {

    public ZippedResponseSender(Data data) {
        super(data);
    }

    @Override
    protected void sendBody() {
        // 데이터 압축 처리
    }
}
```

ZippedResponseSender 클래스는 기존 기능에 압축 기능을 추가해 주는데, 이 기능을 추가하기 위해 ResponseSender 클래스의 코드는 바뀌지 않았습니다. 즉, ResponseSender 클래스는 확장에는 열려 있으면서 변경에는 닫혀 있는 것입니다. 

## 개방 폐쇄 원칙이 깨질 때의 주요 증상
추상화와 다형성을 이용해서 개방 폐쇄 원칙을 구현하기 때문에, 추상화와 다형성이 제대로 지켜지지 않은 코드는 개방 폐쇄 원칙을 어기게 됩니다. 개방 폐쇄 원칙을 어기는 코드는 전형적인 특징은 다음과 같습니다.

- 다운 캐스팅을 합니다.

예를 들어, 슈팅 게임을 개발하는 경우 플레이어, 적, 미사일 등을 그리기 위해 아래 그림과 같은 상속 관계를 사용할 수 있습니다.


![Untitled Diagram (3)](https://user-images.githubusercontent.com/22395934/78251501-631bd280-752c-11ea-890c-81a464b36897.png)

그런데, 화면에 이들 캐릭터를 표시해주는 코드가 다음과 같다면 어떨까요?

```java
public void drawCharacter(Character character) {

    if(character instanceof Missile) { // 타입 확인
        Missile missile = (Missile) character; // 타입 다운 캐스팅
        missile.drawSpecific();
    } else {
        character.draw();
    }
}
```

위 코드는 character 파라미터 타입이 Missile인 경우 별도 처리를 하고 있습니다. 만약 위와 같이 특정 타입인 경우에 별도 처리를 하도록 drawCharacter()메서드를 구현한다면 drawCharacter() 메서드는 Character 클래스가 확장될 때 함께 수정됩니다. 즉, 변경에 닫혀 있지 않은 것입니다.

instanceof와 같은 타입 확인 연산자가 사용된다면 해당 코드는 개방 폐쇄 원칙을 지키지 않을 가능성이 높습니다. 이런 경우에는 타입 캐스팅 후 실행하는 메서드가 변화 대상인지 확인해봐야 합니다.

예를 들어, 위 코드의 경우 타입이 Missile이면 타입 변환 뒤에 drawSpecific() 메서드를 호출하는데, 이 drawSpecific() 메서드가 실제로 객체마다 다르게 동작할 수 있는 변화 대상인지를 확인해 보는 것입니다. 만약 향후 객체들마다 다르게 동작할 가능성이 높다면 이 메서드를 알맞게 추상화해서 Character 타입에 추가해 주어야 합니다.

개방 폐쇄 원칙을 깨드리는 코드의 또 다른 특징은 다음과 같습니다.

- 비슷한 if-else 블록이 존재합니다.

앞의 게임 캐릭터를 이용해서 예를 들어 보도록 하겠습니다. Enemy 캐릭터의 움직이는 경로를 몇 가지 패턴으로 정한다고 합시다. 이 때, 정해진 패턴에 따라 경로를 이동하는 코드를 다음과 같이 작성할 수 있을 것입니다.

```java
public class Enemy extends Character {

    private int pathPattern;

    public Enemy(int pathPattern) {
        this.pathPattern = pathPattern;
    }

    public void draw() {
        if(pathPattern == 1) {
            x += 4;
        } else if(pathPattern == 2) {

        } else if(pathPattern == 4) {
            x += 4;
            y += 10;
        }
        ..; // 그려주는 코드
    }
}
```

Enemy 클래스에 새로운 경로 패턴을 추가해야 할 경우 Enemy 클래스의 draw() 메서드에는 새로운 if 블록이 추가됩니다. 즉, 경로를 추가하는데 Enemy 클래스가 닫혀 있지 않는 것이다. 이를 개방 폐쇄 원칙을 따르도록 변경하면 아래 그림과 같이 경로 패턴을 추상화하고 Enemy에서 추상화 타입을 사용하는 구조로 바뀝니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/78259963-53a28680-7538-11ea-8699-a1e8a34a739b.png)


Enemy 코드는 PathPattern을 사용하도록 변경됩니다.

```java
public class Enemy extends Character {

    private PathPattern pathPattern;

    public Enemy(PathPattern pathPattern) {
        this.pathPattern = pathPattern;
    }

    public void draw() {
        int x = pathPattern.nextX();
        int y = pathPattern.nextY();
        ...; // 그려주는 코드
    }
}
```
이제 새로운 이동 패턴이 생기더라도 Enemy 클래스의 draw() 메서드는 변경ㅇ되지 않으며, 새로운 타입의 PathPattern 구현 클래스를 추가해 주기만 하면 됩니다.

## 개방 폐쇄 원칙은 유연함에 대한 것
개방 폐쇄 원칙은 변경의 유연함과 관련된 원칙입니다. 만약 기존 기능을 확장하기 위해 기존 코드를 수정해 주어야 한다면, 새로운 기능을 추가하는 것이 점점 힘들어집니다. 즉, 확장에는 닫히고 변경에는 열리는 반대 상황이 발생하는 것입니다. 

앞서 FlowController와 ByteSource 예에서 보듯이, 개방 폐쇄 원칙은 변화되는 부분을 추상화함으로써 사용자입장에서 변화를 고정시킵니다. 이를 통해 사용자가 ByteSource의 확장에 폐쇄적일 수 있도록 만들어 줍니다.

상속을 이용한 개방 폐쇄 원칙 구현에서도 ResponseSender 클래스는 변화되는 부분을 sendHeader() 메서드와 sendBody() 메서드로 고정시켰습니다. 하위 클래스에서는 이 두 메서드를 오버라이딩 함으로써 기존 기능을 확장시킬 수 있었고, 반면에 이 두기능을 하위 클래스에 변경하더라도 ResponseSender 클래스는 변경할 필요가 없습니다

개방 폐쇄 원칙은 변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해줍니다. 이 말은 변화되는 부분을 추상화하지 못하면 개방 페쇄 원칙을 지킬 수 없게 되어 시간이 흐를수록 기능 변경이나 확장을 어렵게 만든다는 것을 뜻합니다. 따라서 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정할 수 있는지 확인하는 습관을 갖도록 합시다.
