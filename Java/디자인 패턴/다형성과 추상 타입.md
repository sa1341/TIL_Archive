# 다형성과 추상 타입

객체 지향이 주는 장점은 구현 변경의 유연함입니다. 앞서 이전 포스팅에서 객체는 캡슐화를 통해서 객체를 사용하는 다른 코드에 영향을 최소화하면서 객체의 내부 구현을 변경할 수 있는 유연함을 얻을 수 있었습니다. 유연함을 얻을 수 있도록 해 주는 또다른 방법은 추상화에 있는데, 이 장에서는 추상화가 주는 유연함에 대한 내용을 공부해 볼 것입니다.

## 상속 개요
상속은 한 타입을 그대로 사용하면서 구현을 추가할 수 있도록 해주는 방법을 제공합니다. 예를 들어, 금액 할인에 사용되는 쿠폰을 표현하기 위해 Coupon이라는 클래스를 작성했다고 합시다.

```java
public class Coupon {

    private int discountAmount;

    public Coupon(int discountAmount) {
        this.discountAmount = discountAmount;
    }

    public int getDiscountAmount() {
        return discountAmount;
    }

    public calculateDiscountPrice(int price) {
        if(price < discountAmount) 
            return 0;
        
        return price - discountAmount;
    }
}
```

Coupon 객체를 이용해서 할인된 금액을 구하는 코드는 다음과 같이 Coupon 클래스의 calculateDiscountPrice() 메서드를 사용할 것입니다.

```java
Coupon coupon = new Counpon(3000);
int price = coupon.calculateDiscountPrice(product.getPrice);
```
금액 할인 쿠폰 중, 상품 금액이 지정한 금액 이상인 경우에만 할인을 받도록 하는 쿠폰을 새로 만들고 싶습니다. 이미 Coupon 클래스가 쿠폰의 기본적인 기능을 제공하고 있으므로 이 기능을 확장해서 새로운 쿠폰 기능을 구현하면 좀 더 수월하게 새로운 쿠폰 기능을 제공할 수 있을 것 같습니다. 바로 이럴 때 상속을 사용합니다.

다음은 Coupon 클래스를 상속받아 새로운 클래스를 만드는 예를 보여주고 있습니다.

```java
public class LimitPriceCoupon extends Coupon {

    private int limitPrice;

    public LimitPriceCoupon(int limitPrice, int discountAmount) {
        super(discountAmount);
        this.limitPrice = limitPrice;
    }

    public int getLimitPrice() {
        return limitPrice;
    }

}
```
```java
    @Override
    public int calculateDiscoutPrice(int price) { // 재정의 
        if(price < limitPrice>)
            return price;

        return super.calculateDiscountPrice(price);
    }
}
```

위 코드에서 LimitPriceCoupon 클래스는 Coupon 클래스를 상속받고 있습니다. 이때 상속이 되는 Coupon 클래스를 상위(super) 클래스 또는 부모 클래스라고 부르고, 상속받는 LimitPriceCoupon 클래스를 하위(sub) 클래스 또는 자식(child) 클래스라고 부릅니다.

자식 클래스는 부모 클래스에 정의된 구현을 물려받습니다. 예를 들어, Coupon 클래스에 getDiscountAmount() 메서드가 정의되어 있고, LimitPriceCoupon 클래스에는 이 메서드가 정의되어 있지 않습니다. 그렇지만 LimitPriceCoupon 클래스는 Coupon 클래스에 정의된 getDiscountAmoun() 메서드를 물려받았기 때문에, LimitPriceCoupon 클래스의 객체를 생성한 뒤에 getDiscountAmount() 메서드를 실행할 수 있습니다.


```java
LimitPriceCoupon ipCoupon = new LimitPriceCoupon(5000, 1000);
int discountAmount = ipCoupon.getDiscountAmount(); // Coupon 클래스에서 물려 받습니다.
int limitPrice = ipCoupon.getLimitPrice(); // LimitPriceCoupon 클래스에 정의
```
프로그래밍 언어마다 하위 타입에서 물려받을 수 있는 것이 다를 수 있는데, 다수의 언어에서 private 범위를 갖는 메서드나 필드를 제외한 나머지를 물려받을 수 있도록 하고 있습니다.

위 예에서 Coupon 클래스의 getDiscountAmount() 메서드는 접근 범위가 public이므로 하위 클래스인 LimitPriceCoupon 클래스가 물려받습니다. 반면에 Coupon 클래스의 discountAmount 필드는 private이기 때문에 하위 클래스인 LimitPriceCoupon 클래스에서 접근할 수 없습니다.


## Mock 객체의 사용
```java
public void testProcess() {

    ByteSource mockSource = new MockByteSource();
    FlowController fc = new FlowController(mockSource);
    fc.process();

    // 결과가 정상적으로 만들어졌는지 확인하는 코드
}

class MockByteSource implements ByteSource {

    public byte[] read() {
        byte[] data = new byte[128];
        // data를 테스트 목적의 데이터로 초기화
        return data;
    }
}
```

위 코드에서 MockByteSource 클래스는 ByteSource 인터페이스를 상속받아 구현하고 있는데, 이 클래스의 read() 메서드는 테스트에 필요한 byte 데이터를 직접 생성합니다.(즉, 소켓이나 파일 등에서 읽어오지 않고 테스트에서 사용할 데이터를 하드코딩 합니다.) 그리고 FlowController 객체는 사용할 ByteSource 객체로 FileDataReader 대신에 MockByteSource를 사용하도록 하였습니다.


이제 fc.process() 코드를 실행하면, MockByteSource의 read() 메서드를 통해서 byte 데이터를 읽어 오게 됩니다. byte 데이터를 읽어 왔으므로 FlowController의 process() 메서드는 이 후 코드를 정상적으로 실행할 수 있습니다. 즉, FileDataReader 클래스 없이 FlowController 클래스를 테스트 할 수 있는 것입니다.

이렇게 실제 콘크리트 클래스 대신에 진짜처럼 해동하는 객체를 Mock(가짜, 모의) 객체라고 부르는데, Mock 객체를 사용함으로써 실제 사용할 콘크리트 클래스의 구현 없이 테스트 할 수 있습니다. Mock 객체를 만드는 방법은 다양하게 존재하지만, 사용할 대상을 인터페이스로 추상화하면 좀 더 쉽게 Mock 객체를 만들 수 있게 되며, 이는 사용할 코드의 완성을 기다릴 필요 없이 내가 만든 코드를 먼저 빠르게 테스트 할 수 있도록 해줍니다.





