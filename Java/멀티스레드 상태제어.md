## 스레드 상태
스레드는 객체를 생성하고, start() 메소드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만 실은 실행 대기 상태가 됩니다. 실행 대기 상태란 아직 스케줄링이 되지 않아서 실행을 기다리고 있는 상태를 말합니다. 실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 비로서 CPU를 점유하고 run() 메소드를 실행합니다.
이때를 `실행(Running)`상태라고 합니다. 실행 상태의 스레드는 run() 메소드를 모두 실행하기 전에 스레드 스케줄링에 의해 다시 실행 대기 상태로 돌아 갈 수 있습니다. 그리고 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가 됩니다. 이렇게 스레드는 실행 대기 상태와 실행 상태를 번갈아가면서 자신의 run() 메소드를 조금씩 실행합니다. 실행 상태에서 run() 메소드가 종료되면, 더 이상 실행할 코드가 없기 때문에 실행은 멈추게 됩니다. 이 상태를 종료 상태라고 합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/71639624-07d40d00-2cbd-11ea-9e3f-c9a8459b0885.png)

경우에 따라서 스레드는 실행 상태에서 실행 대기 상태로 가지 않을 수도 있습니다. 실행 상태에서 일시 정지 상태로 가기도 하는데, 일시 정지 상태는 스레드가 실행할 수 없는 상태입니다. 일시 정지 상태는 WAITINGM, TIMED_WATING, BLOCKED가 있습니다. 스레드가 다시 실행 상태로 가기 위해서는 일시 정지 상태에서 실행 대기 상태로 가야 한다는것을 알아둬야 합니다.



![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71639666-08b96e80-2cbe-11ea-839c-b4d479049efd.png)

이러한 스레드의 상탱를 코드에서 확인할 수 있도록 하기 위해 자바 5부터 Thread 클래스에 getState() 메소드가 추가 되었습니다. getState() 메소드는 아래 표처럼 스레드 상태에 따라서 Thread.State 열거 상수를 리턴합니다.


|  <center>상태</center> |  <center>열겨 상수</center> | <center>설명</center>
|:--------|:--------:|:--------|
|  객체 생성 | <center>NEW</center> | 스레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태 |
| 실행 대기 | <center>RUNNABLE</center> | 실행 상태로 언제든지 갈 수 있는 상태 |
| 일시정지 | <center>WAITING</center> | 다른 스레드가 통지할 때까지 기다리는 상태 | 
| 일시정지 | <center>TIMED_WAITING</center> | 주어진 시간 동안 기다리는 상태 | 
| 일시정지 | <center>BLOCKED</center> | 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태 | 
| 종료 | <center>TERMINATED</center> | 실행을 마친 상태 | 

아래 코드는 스레드의 상태를 출력하는 StatePrintThread 클래스 입니다. 생성자 매개값으로 받는 타겟 스레드 상태를 0.5초 주기로 출력합니다.

#### 타겟 스레드의 상태를 출력하는 스레드
```java
public class StatePrintThread extends Thread {

    private Thread targetThread;

    public StatePrintThread(Thread targetThread) {
        this.targetThread = targetThread;
    }

    @Override
    public void run() {

        while(true){

            Thread.State state = targetThread.getState();
            System.out.println("타겟 스레드 상태: " + state);

            if(state == Thread.State.NEW){
                targetThread.start();
            }

            if(state == State.TERMINATED){
                break;
            }


            try {
                Thread.sleep(500);
            }catch (Exception e) {}

        }
    }
}
```

다음은 타겟 스레드 클래스입니다. 처음 for문에서 10억 번 루핑을 돌게 해서 RUNNABLE 상태를 유지하고 그 후에 sleep() 메소드를 호출해서 1.5초간 TIME_WAITING 상태를 유지합니다. 그리고 마지막으로 다시 for문으로 10억번 루핑을 돌게 해서 RUNNABLE 상태를 유지합니다.

#### 타겟 스레드
```java
public class TargetThread extends Thread {

    @Override
    public void run() {

        for (int i = 0; i < 1000000000; i++) {}

        try{
            Thread.sleep(1500);
        }catch (Exception e){}


        for (int i = 0; i < 1000000000; i++) {}
    }
}
```

TargetThread가 객체로 생성되면 NEW 상태를 가지고, run() 메소드가 종료되면 TERMINATED 상태가 되므로 결국 아래와 같은 상태로 변합니다.

`NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED`

다음은 StatePrintThread를 생성해서 매개값으로 전달 받은 TargetThread의 상태를 출력하도록 작성된 실행 클래스입니다.

## 스레드 상태 제어
사용자는 미디어 플레이어에서 동영상을 보다가 일시 정지시킬 수도 있고, 종료시킬 수도 있습니다. 일시 정지는 조금 후 다시 동영상을 보겠다는 의미로 미디어 플레이어는 동영상 스레드를 일시 정지 상태로 만들어야 합니다. 그리고 종료는 더 이상 동영상을 보지 않겠다는 의미이므로 미디어 플레리어는 스레드를 종료 상태로 만들어야 합니다. 이와 같이 실행 중인 스레드의 상태를 변경하는 것을 `스레드 상태 제어`라고 합니다. 멀티 스레드 프로그램을 만들기 위해서는 정교한 스레드 상태 제어가 필요한데, 상태 제어가 잘못되면 프로그램은 불안정해져서 먹통이 되거나 다운됩니다. 멀티 스레드 프로그래밍이 어렵다고 하는 이유는 여기에 있습니다. 스레드는 잘 사용하면 약이 되지만, 잘못 사용하면 치명적인 프로그램의 버그가 되기 때문에 스레드를 정확하게 제어하는 방법을 잘 알고 있어야 합니다. 스레드 제어를 제대로 하기 위해서는 스레드의 상태 변화를 가져오는 메소드를 파악하고 있어야 합니다. 아래 그림은 상태 변화를 가져오는 메소드의 종류를 보여줍니다.


![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/71640100-17585380-2cc7-11ea-8c71-3b08b6312ea4.png)

위 그림에서 취소선을 가진 메소드는 스레드의 안전성을 해친다고 하여 더 이상 사용하지 않도록 권장된 Deprecated 메소드들 입니다.


### 스레드 상태를 제어하는 대표적인 메소드는 아래와 같습니다
interrupt() : 일시 정지 상태의 스레드에서 InterruptedException 예외를 발생시켜, 예외처리 코드(catch)에서 실행 대기 상태로 가거나 종료 상태로 갈 수 있도록 합니다

notify(), notifyAll() : 동기화 블록 내에서 wait() 메소드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만듭니다.

resume() : suspend() 메소드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만듭니다.

- Deprecated (대신 notify(), notifyAll() 사용)

sleep(long mills), sleep(long mills, int nanos): 주어진 시간 동안 스레드를 일시 정지 상태로 만듭니다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 됩니다.

join(), join(long mills), join(long mills, int nanos) : join() 메서드를 호출한 스레드는 일시 정지 상태가 됩니다. 실행 대기 상태로 가려면 join() 메서드를 맴버로 가지는 스레드가 종료되거나, 매개값으로 주어진 시간이 지나야 합니다.

wait(), wait(long mills), wait(long mills, int nanos) : 동기화(synchronized) 블록 내에서 스레드를 일시 정지 상태로 만듭니다. 매개값으로 주어진 시간이 지나면 자동적으로 실행 대기 상태로 됩니다. 시간이 주어지지 않으면 notify(), notifyAll() 메소드에 의해 실행 대기 상태로 갈 수 있습니다.

suspend() : 스레드를 일시 정지 상태로 만듭니다. resume() 메소드를 호출하면 다시 실행 대기 상태가 됩니다. 
 
 - Deprecated(대신 wait() 사용)

 yield() : 실행 중에 우선순위가 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 됩니다.

 stop() : 스레드를 즉시 종료시킵니다

  - Deprecated

  위에서 설명한 wait(), notify(), notifyAll()은 Object 클래스의 메소드이고, 그 이외의 메소드는 모두 Thread 클래스의 메소드들입니다. wait(), notify(), notifyAll Object 클래스의 메소드이고, 그 이외의 메소드는 모두 Thread 클래스의 메소드들 입니다. 

    
## 주어진 시간동안 일시정지(sleep())
실행 중인 스레들를 일정 시간 멈추게 하고 싶다면 Thread 클래스의 정적 메소드인 sleep()을 사용하면 됩니다. 다음과 같이 Thread.sleep() 메소드를 호출한 스레드는 주어진 시간 동안 일시 정지 상태가 되고, 다시 실행 대기 상태로 돌아갑니다.

```java
try{
    Thread.sleep(1000);
}catch(Exception e){
    // interrupt() 메소드가 호출되면 실행
}
```
매개값에는 얼마 동안 일시 정지 상태로 있을 것인지, 밀리세컨드(1/1000) 단위로 시간을 주면 됩니다. 위와 같이 1000이라는 값을 주면 스레드는 1초가 경과할 동안 일시 정지 상태로 있게 됩니다. 일시 정지 상태로 주어진 시간이 되기 전에 interrupt() 메소드가 호출되면 InterruptedException이 발생하기 때문에 예외 처리가 필요합니다.
아래 예제는 3초 주기로 비프(beep)음을 10번 발생 시킵니다.


```java
import java.awt.*;

public class SleepExample {
    public static void main(String[] args) {

        Toolkit toolkit = Toolkit.getDefaultToolkit();

        for (int i = 0; i < 10; i++) {
            toolkit.beep();

            try {
                Thread.sleep(3000);
            } catch (Exception e) {

            }
        }
    }
}
```

메인 스레드를 3초 동안 일시 정지 상태로 보내고, 3초가 지나면 다시 실행 준비 상태로 돌아오도록 했습니다. 

## 다른 스레드에게 실행 양보
스레드가 처리하는 작업은 반복적인 실행을 위해 for문이나 while문을 포함하는 경우가 많습니다. 가끔은 이 반복문들이 무의미한 반복을 하는 경우가 있습니다.

```java
public void run(){
    while(true){
        if(work){
            System.out.println("ThreadA 작업 내용");
        }
    }
}
```
스레드가 시작되어 run() 메소드를 실행하면 while(true) {} 블록을 무한 반복 실행합니다. 만약 work 값이 false라면 그리고 work의 값이 false에서 true로 변경되는 시점이 불명확하다면, while 문은 어떠한 실행문도 실행하지 않고 무의미한 반복을 합니다. 이것보다는 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 가는 것이 전체 프로그램 성능에 도움이 됩니다. 이런 기능을 위해서 스레드는 yield() 메소드를 제공하고 있습니다. yield() 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행 기회를 가질 수 있도록 해줍니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71640717-bf274e80-2cd2-11ea-9903-1d3e8b603210.png)

다음 코드는 의미 없는 반복을 줄이기 위해 yield() 메소드를 호출해서 다른 스레드에게 실행 기회를 주도록 수정하였습니다.

```java
public void run(){
    while(true){
        if(work){
            System.out.println("ThreadA 작업 내용");
        }else {
            Thread.yield();
        }
    }
}
```

다음 예제에서는 처음 실행 후 3초 동안은 ThreadA와 ThreadB가 번갈아가며 실행됩니다. 3초 뒤에 메인 스레드가 ThreadA의 work 필드를 false로 변경함으로써 ThreadA는 yield() 메소드를 호출합니다. 따라서 이후 3초 동안에는 ThreadB가 더 많은 실행 기회를 얻게 됩니다. 메인 스레드는 3초 뒤에 다시 ThreadA의 work 필드를 true로 변경해서 ThreadA와 ThreadB가 번갈아가며 실행하도록 합니다. 마지막으로 메인 스레드는 3초 뒤에 ThreadA와 ThreadB의 stop 필드를 true로 변경해서 두 스레드가 반복 작업을 중지하고 종료하도록 합니다.

#### 스레드 실행 양보 예제
```java
public class YieldExample {
    public static void main(String[] args) {
        ThreadA threadA = new ThreadA();
        ThreadB threadB = new ThreadB();

        // ThreadA, ThreadB 모두 실행
        threadA.start();
        threadB.start();

        try{
            Thread.sleep(3000);
        }catch (InterruptedException e) {}

        // ThreadB만 실행
        threadA.work = false;

        try{
            Thread.sleep(3000);
        }catch (InterruptedException e) {}

        // ThreadA, ThreadB 모두 실행
        threadA.work = true;

        // ThreadA, ThreadB 모두 종료
        threadA.stop = true;
        threadB.stop = true;
    }
}
```

```java
public class ThreadA extends Thread {

    public boolean stop = false; // 종료 플래그
    public boolean work = true; // 작업 진행 여부 플래그

    @Override
    public void run() {
        while (!stop) { // stop이 true가 되면 while 문 종
            if (work) {
                System.out.println("ThreadA 작업 내용");
            } else {
                Thread.yield(); // work가 false가 되면 다른 스레드에게 실행 양보
            }
        }

        System.out.println(this.getName() + "종료");
    }
}
```

```java
public class ThreadB extends Thread {

    public boolean stop = false; // 종료 플래그
    public boolean work = true; // 작업 진행 여부 플래그

    @Override
    public void run() {
        while (!stop) { // stop이 true가 되면 while 문 종
            if (work) {
                System.out.println("ThreadB 작업 내용");
            } else {
                Thread.yield(); // work가 false가 되면 다른 스레드에게 실행 양보
            }
        }

        System.out.println(this.getName() + "종료");
    }
}
```

## 다른 스레드의 종료를 기다림(join())
스레드는 다른 스레드와 독립적으로 실행하는 것이 기본이지만 다른 스레드가 종료될 때까지 기다렸다가 실행해야 하는 경우가 발생할 수도 있습니다. 예를 들어 계산 작업을 하는 스레드가 모든 계산 작업을 마쳤을 때, 계산 결과값을 받아 이용하는 경우가 이에 해당합니다. 이런 경우를 위해서 Thread는 join() 메서드를 제공하고 있습니다. 아래 그림을 보고 이해하면 됩니다. ThreadA가 ThreadB의 join() 메소드를 호출하면 ThreadA는 ThreadB가 종료할 때까지 일시 정지 상태가 됩니다. ThreadB의 run() 메소드가 종료되면 비로소 ThreadA는 일시 정지에서 풀려 다음 코드를 실행하게 됩니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/71641136-3d3b2380-2cda-11ea-83c5-4974c42b9ea2.png)

다음 예제를 보면 메인 스레드는 SumThread가 계산 작업을 모두 마칠 때까지 일시 정지 상태에 있다가 SumThread가 최종 계산된 결과값을 산출하고 종료하면 결과값을 받아 출력합니다.

```java
public class SumThread extends Thread {

    private long sum;

    public long getSum(){
        return sum;
    }

    public void setSum(long sum){
        this.sum = sum;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
    }
}
```

```java
public class JoinExample {
    public static void main(String[] args) {

        SumThread sumThread = new SumThread();
        sumThread.start();

        try {
            sumThread.join();
        } catch (Exception e) {
        }

        System.out.println("1 ~ 100 합: " + sumThread.getSum());
    }
}
```

JoinExample 클래스에서 sumThread.join()를 주석 처리하고 실행하면 1~100까지의 합을 출력하는 콘솔 창에 결과 값이 0이 나옵니다. 그 이유는 SumThread가 계산 작업을 완료하지 않는 상태에서 합을 먼저 출력하기 때문입니다.
스레드는 하나의 독립적인 실행코드기 때문에 발생하는 문제입니다.

## 스레드간 협엽(wait(), notify(), notifyAll())
경우에 따라서는 두개의 스레드를 교대로 번갈아가며 실행해야 할 경우가 있습니다. 정확한 교대 작업이 필요할 경우, 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고, 자신은 일시 정지 상태로 만드는 것입니다. 이 방법의 핵심은 공유 객체에 있습니다. 공유 객체는 두 스레드가 작업할 내용을 각각 동기화 메소드로 구분해 놓습니다.
한 스레드가 작업을 완료하면 notify() 메소드를 호출해서 일시 정지 상태에 있는 다른 스레드를 실행 대기 상태로 만들고, 자신은 두 번 작업을 하지 않도록 wait() 메소드를 호출하여 일시 정지 상태로 만듭니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71641357-e9cad480-2cdd-11ea-833f-a972640bf229.png)


만약 wait() 대신 wait(long timeout)이나, wait(long timeoutm, int nanos)를 사용하면 notify()를 호출하지 않아도 지정된 시간이 지나면 스레드가 자동적으로 실행 대기 상태가 됩니다. notify() 메소드와 동일한 역할을 하는 notifyAll() 메소드도 있는데, notify()는 wait()에 의해 일시 정지된 모든 스레드들을 실행 대기 상태로 만듭니다. 이 메소드들은 Thread 클래스가 아닌 Object 클래스에 선언된 메소드이므로 모든 공유 객체에서 호출이 가능합니다. `주의할 점은 이 메소드들은 동기화 메소드 또는 동기화 블록 내에서만 사용할 수 있습니다.` 다음 예제는 두 스레드 작업을 WorkObject의 methodA()와 methodB()에 정의해 두고, 두 스레드 ThreadA와 ThreadB가 교대로 methodA()와 methodB()를 호출하도록 했습니다.


#### 두 스레드의 작업 내용을 동기화 메소드로 작성한 공유 객체
```java
public class WorkObject {
    public synchronized void methodA(){
        System.out.println("ThreadA의 methodA() 작업 실행");
        notify(); // 일시 정지 상태에 있는 ThreadB를 실행 대기 상태로 만듬.
        try{
            wait(); // ThreadA를 일시 정지 상태로 만듬.
        }catch (Exception e){}

    }

    public synchronized void methodB(){
        System.out.println("ThreadB의 methodB() 작업 실행");
        notify();  // 일시 정지 상태에 있는 ThreadA를 실행 대기 상태로 만듬.

        try{
            wait(); // ThreadB를 일시 정지 상태로 만듬.
        }catch (Exception e) {}
    }
}
```


```java
public class WorkThreadA extends Thread {

    private  WorkObject workObject;
     // 공유 객체를 매개값으로 받아 필드에 저장
    public WorkThreadA(WorkObject workObject) {
        this.workObject = workObject;
    }
    // 공유 객체의 methodA()를 10번 반복 호출
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
           workObject.methodA();
        }
    }
}
```
```java
public class WorkThreadB extends Thread {

    private WorkObject workObject;
    // 공유 객체를 매개값으로 받아 필드에 저장
    public WorkThreadB(WorkObject workObject) {
        this.workObject = workObject;
    }
    // 공유 객체의 methodB()를 10번 반복 호출
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            workObject.methodB();
        }
    }
}
```

```java
public class WaitNotifyExample {
    public static void main(String[] args) {

        // 공유객체 생성
        WorkObject sharedObject = new WorkObject();

        WorkThreadA threadA = new WorkThreadA(sharedObject);
        WorkThreadB threadB = new WorkThreadB(sharedObject);

        // ThreadA와 ThreadB를 실행
        threadA.start();
        threadB.start();
        
    }
}
```

#### 실행 결과
![스크린샷 2020-01-01 오후 10 40 55](https://user-images.githubusercontent.com/22395934/71641999-cad14000-2ce7-11ea-9917-876dc9bf1809.png)

실행 결과 WorkThreadA와 WorkThreadB가 번갈아가면서 공유 객체의 methodA, methodB를 수행하는 것을 알 수가 있습니다.

다음 예제는 데이터를 저장하는 스레드(생산자 스레드)가 데이터를 저장하면, 데이터를 소비하는 스레드(소비자 스레드)가 데이터를 읽고 처리하는 교대 작업을 구현한 것입니다.


![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/71642083-7333d400-2ce9-11ea-861b-0db9af955009.png)

생산자 스레드는 소비자 스레드가 읽기 전에 새로운 데이터를 두 번 생성하면 안되고 (setData() 메소드를 두 번 실행하면 안됨), 소비자 스레드는 생산자 스레드가 새로운 데이터를 생성하기 전에 이전 데이터를 두 번 읽어서도 안 됩니다.(getData() 메소드를 두 번 실행하면 안 됨). 구현 방법은 공유 객체(DataBox)에 데이터를 저장할 수 있는 data 필드 값이 null이면 생산자 스레드를 실행 대기 상태로 만들고, 소비자 스레드를 일시 정지 상태로 만드는 것입니다. 반대로 data 필드의 값이 null이 아니면 소비자 스레드를 실행 대기 상태로 만들고, 생산자 스레드를 일시 정지 상태로 만들면 됩니다.

```java
public class DataBox {

    private String data;

    public synchronized String getData(){
        if(data == null){
            try {
                wait();
            }catch (InterruptedException e) {}
        }

        String resultValue = data;
        System.out.println("ConsumerThread가 읽은 데이터: " + resultValue);
        data = null;
        notify();

        return resultValue;
    }


    public synchronized void setData(String data){
       if(this.data != null){
           try{
               wait();
           }catch (InterruptedException e) {}
       }
        this.data = data;
        System.out.println("ProductThread가 생성한 데이터: " + data);
        notify();
    }
}
```

```java
public class ProducerThread extends Thread {

    private DataBox dataBox;

    // 공유 객체를 필드에 저장
    public ProducerThread(DataBox dataBox) {
        this.dataBox = dataBox;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            String data = "Data-" + i;
            dataBox.setData(data); // 새로운 데이터 저장
        }
    }
}
```

```java
public class ConsumerThread extends Thread {

    private DataBox dataBox;

    public ConsumerThread(DataBox dataBox) {
        this.dataBox = dataBox;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            String data = dataBox.getData();
        }
    }
}
```

```java
public class WaitNotiExample {
    public static void main(String[] args) {

        DataBox dataBox = new DataBox();

        ProducerThread producerThread = new ProducerThread(dataBox);
        ConsumerThread consumerThread = new ConsumerThread(dataBox);

        producerThread.start();
        consumerThread.start();
    }
}
```

#### 실행 결과
![스크린샷 2020-01-01 오후 11 31 37](https://user-images.githubusercontent.com/22395934/71642481-1affd080-2cef-11ea-8a1d-d7fe9f15d570.png)


## 스레드의 안전한 종료(stop 플래그, interrupt())
스레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료된다. 경우에 따라서는 실행 중인 스레드를 즉시 종효할 필요가 있습니다. 예를 들어 동영상을 끝까지 보지 않고, 사용자가 멈춤을 요구할 수 있습니다. Thread는 스레드를 즉시 종료시키기 위해서 stop() 메소드를 제공하고 있는데, 이 메소드는 deprecated 되었습니다. 그 이유는 stop() 메소드로 스레드를 갑자기 종료하게 되면 스레드가 사용 중이던 자원들이 불완전한 상태로 남겨지기 때문입니다. 여기서 자원이란 파일, 네트워크 연결 등을 말합니다. 그렇다면 스레드를 즉시 종료시키기 위한 최선의 방법은 무엇일까요?

## stop 플래그를 이용하는 방법
스레드는 run() 메소드가 끝나면 자동적으로 종료되므로, run() 메소드가 정상적으로 종료되도록 유도하는 것입니다. 다음 코드는 stop 풀래그를 이용해서 run() 메소드의 종료를 유도합니다.

```java
public class XXXThread extends Thread{

    private boolean stop; // stop 플래그

    public void run(){
        while(!stop){
            // 스레드가 반복 실행하는 코드;
        }
        // 스레드가 사용한 자원 정리
    }
} 
```

위 코드에서 stop 필드가 false일 경우에는 while문의 조건식이 true가 되어 반복 실행하지만, stop 필드가 true일 경우에는 while문의 조건식이 false가 되어 while문을 빠져나옵니다. 그리고 스레드가 사용한 자원을 정리하고, run() 메소드가 끝나게 됨으로써 스레드는 안전하게 종료됩니다.

아래 예제는 PrintThread1을 실행한 후 1초 후에 PrintThread1을 멈추도록 setStop() 메소드를 호출합니다.

```java
public class StopFlagExample {
    public static void main(String[] args) {

        PrintThread1 printThread1 = new PrintThread1();
        printThread1.start();

        try {
            Thread.sleep(1000);
        }catch (InterruptedException e) {}

        printThread1.setStop(true);
    }
}
```

```java
public class PrintThread1 extends Thread {

    private boolean stop;

    public PrintThread1() {
        System.out.println(stop);
    }

    public void setStop(boolean stop){
        this.stop = stop;
    }

    @Override
    public void run() {

        while(!stop){
            System.out.println("실행 중");
        }

        System.out.println("자원 정리");
        System.out.println("실행 종료");
    }
}
```
