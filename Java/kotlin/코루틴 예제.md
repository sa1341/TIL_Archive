# 코루틴 

Kotlin 공식 홈페이지에 들어가면 코루틴에 대한 정의는 아래와 같습니다.

`비동기 논블로킹 코드를 작성하도록 해주는 경량형 스레드`

Kotlin에서 코루틴은 `CoroutineScope`에서 코루틴 빌더를 통해서 생성하고, 실행이 가능합니다.

대표적인 CoroutineScope로는 GolbalScope, runBlocking이 있습니다.

## runBlocking 

```kotlin
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {

    /*
        structure concurrency
        부모코루틴이 자식코루틴이 종료될때까지 대기하기 때문에
        job.join()을 하지않아도 코루틴이 전부 수행이 됨
     */

    launch {
        myWorld()
    }

     launch {
        myWorld()
    }

    println("Hello,")
}

suspend fun myWorld() {
    println("World!")
}
```

`runBlocking ` CoroutineScope에서 코루틴이 실행되면 해당 코루틴을 호출한 스레드를 blocking 합니다.
즉, 위 예제코드에서 main 메서드는 runBlocking에서  실행중인 코루틴이 종료될때까지 대기합니다.


### 실행결과

```kotlin
Hello, [main]
World! [main]
World! [main]

Process finished with exit code 0
```

실행결과를 보면 `launch`라는 코루틴빌더가 코루틴을 실행하기 위해 스케줄링되고, `Hello,`를 먼저 출력하는 것을 알 수 있습니다. 

이것을 `Structure Concurrency`라고 하는데, 부모 코루틴은 자식 코루틴이 종료될때까지 대기하기 때문에, 별도로 delay 메서드를 주지않아도 코루틴이 중간에 실행되다가 종료되지 않고 전부 실행되는 것을 확인할 수 있습니다.


> suspend 키워드는 coroutineScope내에서만 호출 할 수 있습니다. 코루틴은 진행중인 작업을 중지하고 언제든지 재개할 수 있는 것을 의미하기 때문입니다.

## suspend, resume 학습

실제로 코루틴이 실행되다가, 중단되고 다시 재개되는 예제코드를 작성해봤습니다.

```kotlin
fun main() = runBlocking {

    // delay는 suspend 메서드이기 때문에 진입 재개를 반복하여 코루틴 실행이 가능합니다.
    launch {
        repeat(5) {
            println("Coroutine A, $it")
            delay(10L)
        }
    }

    launch {
        repeat(5) {
            println("Coroutine B, $it")
            //delay(10L)
        }
    }

    println("Coroutine Outer")
}

fun <T>println(msg: T) {
    kotlin.io.println("$msg [${Thread.currentThread().name}]")
}
```

위 코드는 CoroutineA와 CoroutineB를 각 repeat 메서드를 사용하여 5번씩 콘솔에 문자열을 출력하는 예제코드입니다. 

이때 delay 메서드를 사용하면 CoroutineA가 1번 호출되고 중단이 되고, CoroutineB가 5번 호출되고 나서야 나머지 CoroutineA가 모두 호출되고 있습니다. 

이렇게 실행되는 이유는 CoroutineB는 중간에 중단하는 메서드가 없기 때문에 계속 코루틴이 실행되는것을 알 수 있습니다.

만약 CoroutineB에 delay 메서드의 주석을 없애고 다시 실행해보면 CoroutineA와 CoroutineB가 진입과 재개를 통해서 사이좋게 반복적으로 콘솔에 문자열이 출력되는 것을 알 수 있습니다. 

## 코루틴 cancel

코루틴이 실행도중에 작업을 cancel하기 위해서는 코루틴이 협조적이도록 코드를 작성해야 합니다.

```kotlin
import kotlinx.coroutines.cancelAndJoin
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {

    val job = launch {
        try {
            repeat(1000) {
                println("job: I'm sleeping $it ...")
                delay(500L)
            }
        } catch (e: Exception) {
            println("Exception: $e")
        }
    }

    delay(1300L)
    println("main: I'm tired of waiting")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}
```

실행중인 코루틴을 취소하는 방법 중 하나는 `suspend` 메서드를 호출하는 것입니다.

기본적으로 job 객체의 cancel()을 호출하게 되면 위의 delay() 메서드는 아래와 같이 `JobCancellationException` 예외를 던지게 되고 코루틴의 실행이 중단됩니다.


### 실행결과

```kotlin
Exception: kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine{Cancelling}@759ebb3d [main]
```

두번째로 작업 취소를 하기 위해 코루틴 협조적으로 코드를 작성하는 방법은 코루틴이 제공하는 상태값을 이용하는 것입니다.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {

    val job = launch(Dispatchers.Default) {
        var i = 0

        while (isActive) {
            println("I'm sleeping ${i++}")
        }
    }

    delay(1300L)
    println("main: I'm tired of waiting")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}
```

코루틴 빌더에 아규먼트를 `Dispatchers.Default`를 주면 코루틴을 background 모드로 실행하게 되고, cancel() 메서드를 호출하게 되면 `isActive` 상태값이 `false`가 되어서 코루틴이 실행을 멈추게 됩니다.


마지막으로는 `withTimeoutOrNull`이라는 코루틴 빌더를 사용하여 코루틴을 실행하는데 이때 타임아웃을 주고 만약 주어진 시간동안 완료하지 못하면 null이나 예외를 던져서 코루틴 작업을 중단하도록 만들수도 있습니다.

```kotlin
fun main(args: Array<String>) = runBlocking {

    val result = withTimeoutOrNull(1300L) {
        repeat(1000) {
            println("I'm sleeping $it")
            delay(500L)
        }
        "Done"
    }

    println("Result is $result")
}
```

### 실행결과

```kotlin
I'm sleeping 0 [main]
I'm sleeping 1 [main]
I'm sleeping 2 [main]
Result is null [main]
```

위 코드에서 코루틴을 0.5초마다 1000번을 실행하는데 타임아웃은 1.3초로 주었기 때문에 결국 `result` 값은 null을 반환하게 됩니다. 만약 `withTimeout` 코루틴빌더를 사용하게 되면 주어진 시간이 지나면 null이 아니라 예외를 던지게 됩니다.
