# 즉시로딩과 지연로딩

이제 JPA에서 연관관계를 조회할때 가장 중요한 글로벌 패치 전략인 `즉시로딩(EAGER)`과 `지연로딩(LAZY)`에 대해서 살펴보겠습니다.

```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
System.out.println(team.getName()); // 팀 엔티티 사용
```
위와 같이 회원 엔티티를 조회할때 조회 시점을 선택할 수 있도록 다음 두 가지 방법을 제공합니다. 

- 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회합니다.
  em.find(Member.class, "member1")를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회합니다.
  설정방법: `@ManyToOne(fetch = FetchType.EAGER)`


- 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회합니다.
  member.getTeam().getName(()처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회합니다.
  설정방법: `@ManyToOne(fetch = FetchType.LAZY)`


  # 즉시로딩
  즉시 로딩을 사용하려면 `@ManyToOne`의 fetch 속성을 FetchType.EAGER로 지정합니다.
  

```java
@Entity
public class Member {

    @Id
    @Column(name = "member_id")
    private String id;

    private String name;

    private int age;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "team_id")
    private Team team;
}

//즉시 로딩 실행 코드
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
```

위의 예제코드에서는 회원과 팀을 즉시 로딩으로 설정했습니다. 따라서 em.find(Member.class, "member1")로 회원을 조회하는 순간 팀도 함께 조회합니다. 이때 회원과 팀 두 테이블을 조회해야 하므로 쿼리를 2번 수행할 것 같지만, 대부분의 JPA 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용합니다. 여기서는 회원과 팀을 조인해서 쿼리 한번으로 두 엔티티를 모두 조회합니다.

### 즉시로딩(fetch = FetchType.EAGER)
![스크린샷 2019-11-21 오전 2 52 39](https://user-images.githubusercontent.com/22395934/69335205-c30d8d00-0c9f-11ea-86f7-88627ddea453.png)

실제로 JPA가 left outer join 쿼리문을 날려서 회원과 팀을 한 번으로 조회한 것을 알 수 있습니다.
이후 member.getTeam()을 호출하면 이미 로딩된 팀1 엔티티를 반환합니다.

> 참고

NULL 제약조건과 JPA 전략
즉시 로딩 실행 SQL에서 JPA가 `내부 조인`이 아닌 `외부 조인`을 사용하고 있습니다. 그 이유는 현재 회원 테이블에서 TEAM_ID 외래 키는 NULL 값을 허용하고 있습니다. 따라서 팀에 소속되지 않는 회원이 존재할 가능성이 있기 때문에 팀에 소속되지 않는 회원과 팀을 내부조인하면 팀은 물론이고 회원 데이터도 조회할 수 없습니다. JPA는 이런 상황을 고려해서 `외부 조인`을 사용합니다. 하지만 `성능상으로 외부조인보다 내부조인이 최적화에 더 유리합니다.` 따라서 외래키에 NOT NULL 제약 조건을 설정하면 값이 있는 것을 보장하기 때문에 이런 경우에는 `내부조인만` 사용해도 됩니다.

`ex)`

```java
@Entity
public class Member{

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "TEAM_ID", nullable = false)
    private Team team;
    //...
}
```

#### nullable 설정에 따른 조인 전략
- @JoinColumn(nullable = true): NULL 허용(기본값), 외부 조인 사용
- @JoinColumn(nullable = false): NULL 허용하지 않음, 내부 조인 사용

또는 아래 코드 처럼 내부 조인을 사용할 수 있습니다.

```java
@Entity
public class Member{

    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "TEAM_ID", nullable = false)
    private Team team;
    //...
}
```

 > JPA는 선택적 관계이면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용합니다. 

### 내부 조인 결과

 ![스크린샷 2019-11-22 오전 1 08 06](https://user-images.githubusercontent.com/22395934/69355089-91f38380-0cc4-11ea-81aa-6cc419ba63e7.png)


# 지연로딩

지연 로딩을 사용하면 `@ManyToOne`의 fetch 속성을 `FetchType.LAZY`로 지정합니다.

```java
// 지연로딩 설정
@Entity
public class Member {

    @Id
    @Column(name = "member_id")
    private String id;

    private String name;

    private int age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;
}


//지연 로딩 실행 코드
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
team.getName(); // 팀 객체 실제 사용
```

위의 코드에서는 회원과 팀을 지연 로딩으로 설정했습니다. 따라서 예제코드에서 em.find(Member.class, "member1")를 호출하면 회원만 조회하고 팀은 조회하지 않습니다. 대신에 team 맴버변수에 `프록시` 객체를 넣어 둡니다.

```java
Team team = member.getTeam(); // 프록시 객체 
```

반환된 팀 객체는 프록시 객체입니다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룹니다. 그래서 `지연로딩`이라고 합니다.

```java
team.getName() // 팀 객체 실제 사용
```

위의 코드처럼 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화 합니다.

em.find(Member.class, "member1") 호출 시 실행되는 SQL은 다음과 같습니다.

```sql
SELECT * FROM MEMBER WHERE MEMBER_ID='member1';
```

team.getName() 호출로 프록시 객체가 초기화되면서 실행되는 SQL은 다음과 같습니다.

```sql
SELECT * FROM TEAM WHERE TEAM_ID='team1';
```

> 참고로 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없습니다. 따라서 프록시가 아닌 실제 객체를 사용합니다. 


즉시로딩과 지연로딩 중에 어느것이 더 효율적인가에 대해서는 아무래도 프로젝트 상황에 따라 다를거 같습니다. 애플리케이션 로직에서 회원과 팀 엔티티를 같이 사용한다고 하면 SQL 조인을 사용해서 회원과 팀 엔티티를 한번에 조회하는 것이 더 효율적입니다. 페이스북에서 댓글 더보기 기능처럼 실제로 조회가 필요할때 게시물과 연관된 댓글을 조회하는것도 대표적인 지연로딩 방식입니다.

# 지연 로딩 활용

사내 주문 관리 시스템을 개발한다고 가정하겠습니다.

![스크린샷 2019-11-22 오전 1 43 29](https://user-images.githubusercontent.com/22395934/69358021-8191d780-0cc9-11ea-94bf-b4681ab8a506.png)


- 회원은 팀 하나에만 소속할 수 있습니다. (N:1)
- 회원은 여러 주문내역을 가집니다. (1:N)
- 주문내역은 상품정보를 가집니다. (N:1)

애플리케이션 로직을 분석해보니 다음과 같았습니다.

- Member와 연관된 Team은 자주 함꼐 사용되었습니다. 그래서 Member와 Team은 `즉시 로딩`으로 설정했습니다.

- Member와 연관된 Order는 가끔 사용되었습니다. 그래서 Member와 Order는 `지연 로딩`으로 설정했습니다.
- Order와 연관된 Product는 자주 함께 사용되었습니다. 그래서 Order와 Product는 `즉시 로딩`으로 설정했습니다.
