# Webflux 요청처리에 대한 고찰

현재 실무에서 하는 프로젝트 중에 몇몇은 `Webflux`를 사용하여 요청을 처리하는 코드들이 존재합니다.

스프링 부트에서 Reactive Stream 프로젝트를 진행하면서 Non Blocking 방식과 Pub/Sub, Flux, Mono등을 알아봤지만, 대체 어떻게 Webflux가 적은 스레드로 Spring MVC 보다 많은 요청을 처리하는지 구글링을 해봐도 이해가 안돼었다가 다른 블로그를 보고 그나마 가닥을 잡히는듯? 보여서 한번 정리해봤습니다.

기본적으로 Spring MVC는 스레드 풀의 갯수가 200개이고, 이렇게 만드는 이유는 스레드 생성 비용이 생각보다 비싸기때문에 미리 스레드 풀에 쌓아놓았다가 요청을 처리하면 다시 풀에 반환하여 재사용하는 방식으로 요청을 처리하고 있습니다.

그에 반해 `Webflux`는 core * 2의 Thread만을 생성한다고 합니다.

즉, 현재 서버의 H/W 스펙이 옥타코어이면 Webflux에서 사용하는 가용할 수 있는 총 스레드 수가 12개라는 뜻입니다.

## 1. Spring MVC 동작원리

먼저, Webflux가 적은 스레드로 어떻게 많은 요청을 처리하는지 이해하기 위해 가장 익숙한 Spring MVC 요청처리 절차에 대해서 간단하게 정리해봤습니다.

1. 요청이 들어오면 ThreadPool에서 Thread를 하나 생성함.

2. I/O(File I/O, Network I/O 등)가 발생하면 CPU를 Idle 상태로 빠짐.

3. 이 시점에 다른 요청이 들어오면 ThreadPool에서 Thread를 하나 사용함.

4. 이런 식으로 스레드를 돌아가면서 요청을 처리하고 blocking이 풀리면 작업을 계속 재개합니다.

일단 이것도 간략하긴하지만, 실제로 트랜잭션에서 무거운 쿼리를 수행하게되면(DB I/O) 스레드가 고갈되는 이슈가 생길 수 있습니다.


## 2. Webflux 동작원리

그럼 이제 Webflux 요청처리 절차를 정리해보겠습니다.

1. 요청을 받는 스레드(A 스레드)가 존재함

2. I/O가 발생하면 CPU가 Idle 상태로 빠짐

3. 이때 비동기로 작업을 처리하기 위한 event queue에 넣음.

4. A 스레드는 계속해서 요청을 받아서 처리함.

5. 동시에 C라는 스레드에서 이벤트 큐를 무한 루프를 돌면서 감시함.

6. 이벤트 루프에서 감시를 하다가 작업이 끝난 이벤트가 있으면 B 스레드에서 해당 이벤트를 처리

이런 flow로 인해서 CPU가 Idle 타임에 빠지지 않도록 일을 열심히 시킨다는 메커니즘으로 설계된 것 같습니다.

## 3. Webflux는 왜 CPU Core * 2개의 스레드를 사용하는가?

이게 사실 가장 궁금한 부분이였는데, 단순히 스레드 생성 비용이 비싸서 적게 스레드를 생성해서 성능이 더 좋아지는 것은 아닙니다.

스레드가 많다는 것은 그만큼 공유 자원의 동기화 이슈가 있고, 이러한 이슈로 인해 시간이 오래 걸리게 됩니다. 따라서 Thread가 적으면 적을 수록 동기화 이슈로 인한 문제에 덜 시달리게 됩니다.

그리고 CPU는 한 번에 하나의 작업 밖에 수행하지 못합니다. 따라서 CPU 코어 갯수보다 더 많은 스레드를 생성하는 것은 무의미한 동기화 이슈를 늘리는 것에 불과합니다. 


> 참조 블로그: https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/


