# Spring Reactive Programming

애플리케이션 코드를 개발할 때는 아래와 같이 두 가지 형태로 코드를 작성할 수 있습니다.

- 명령형: 순차적으로 연속되는 작업이며, 각 작업은 한 번에 하나씩 그리고 이전 작업 다음에 실행됩니다. 데이터는 모아서 처리되고 이전 작업 데이터 처리를 끝낸 후에 다음 작업으로 넘어갈 수 있습니다.

- 리액티브: 데이터 처리를 위해 일련의 작업들이 정의되지만, 이 작업들은 병렬로 실행될수 있습니다. 그리고 각 작업은 부분 집합의 데이터를 처리할 수 있으며, 처리가 끝난 데이터를 다음 작업에 넘겨주고 다른 부분집합의 데이터로 계속 작업할 수 있습니다.

## 리액터 시작하기

리액티브 프로그래밍은 명령형 프로그래밍과 매우 다른 방식으로 접근해야 합니다. 즉, 일련의 작업단계를 기술하는 것이 아니라 데이터가 전달될 파이프라인을 구성하는 것입니다. 

예를 들어, 사람의 이름을 가져와서 모두 대문자로 변경한 후 이것으로 인사말 메시지를 출력한다고 해보면, 명령형 프로그래밍 모델에서는 아래와 같은 코드로 작성할 수 있습니다.

```kotlin
var name = "jeancalm"
val capitalName = name.toUpperCase()
val greeting = "Hello, ${capitalName}!"
```

이 경우 각 줄의 코드가 같은 스레드에서 한 단계씩 차례로 실행됩니다. 그리고 각 단계가 완료될 때까지 다음 단계로 이동하지 못하게 실행 중인 스레드를 막습니다.

반면에 리액티브 코드에서는 다음과 같이 할 수 있습니다.

```kotlin
Mono.just("jeancalm")
	.map(n -> n.toUpperCase())
  .map(cn -> "Hello, ${cn}!")
	.subscribe(System.out::println)
```

위 코드도 단계별로 실행되는 것처럼 보이겠지만, 실제로는 데이터가 전달되는 파이프라인을 구성하는 것입니다.

그리고 파이프라인의 각 단계에서는 어떻게 하든 데이터가 변경됩니다. 또한, 각 오퍼레이션은 같은 스레드로 실행되거나 다른 스레드로 실행될 수 있습니다.

 

Reactor가 제공하는 두가지 타입에 대해서 살펴봤습니다.

- Mono:  하나의 데이터 항목만 갖는 데이터셋에 최적화된 리액티브 타입입니다.
- Flux: 0, 1 또는 다수의 데이터를 갖는 파이프라인을 나타냅니다.

## 리액티브 타입 생성하기

스프링에서 리액티브 타입을 사용할 때는 리퍼지터리나 서비스로부터 위에서 설명한 Flux나 Mono가 제공됩니다. 

그러나 데이터를 발행하는 새로운 리액티브 발행자를 생성해야 할 때가 있습니다.

리액터는 Flux나 Mono를 생성하는 오퍼레이션을 제공합니다.

```kotlin
@Test
fun createAFlux_just() {
	fruitFlux: Flux<String> = Flux
		.just("Apple", "Orange", "Grape", "Banana", "Strawberry")
}
```

이 경우 Flux는 생성되지만, 구독자 subscriber가 없습니다.  구독자가 없이는 데이터가 전달되지 않을 것입니다.

정원용 호스에 비유해서 생각해보낟면 호수를 수도꼭지에 끼운 것입니다. 그러나 수도꼭지를 틀어야 물이 흐르게 됩니다.

리액티브 타입을 구독한다는 것은 데이터가 흘러갈 수 있게 하는 것입니다.

구독자를 추가할 때는 flux의  subscribe() 메서드를 호출하면 됩니다.

```kotlin
fruitFlux.subscribe(
	println("Here's some fruit ${it}") 
}
```
