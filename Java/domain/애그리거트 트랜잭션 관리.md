# 애그리거트 트랜잭션 관리

## 애그리거트와 트랜잭션

한 주문 애그리거트에 대해 운영자는 배송 상태로 변경할 때 사용자는 배송지 주소를 변경하면 될까요? 아래 그림은 발생할 수 있는 다양한 경우 중에서 한 가지를 시간순서로 표현한 것입니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/101484120-7d039400-399c-11eb-80a5-49e31b39ac7f.png)

>> 한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요합니다.

위 그림은 운영자와 고객이 동시에 한 주문 애그리거트를 수정하는 과정을 보여줍니다. 메모리 캐시를 사용하지 않을 경우 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 됩니다. (트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성합니다.)

운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트이지만 물리적으로 서로 다른 애그리거트 객체를 사용합니다. 때문에 운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경한더라도 고객 스레드가 사용하는 주문 애그리거트 객체에는 영향을 주지 않습니다. 고객 스레드 입장에서 주문 애그리거트 객체는 아직 배송 상태 전이므로 배송지 정보를 변경할 수 있습니다.

이 상황에서 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DBMS에 반영합니다. 즉, 배송 상태로 바뀌고 배송지 정보도 바뀌게 됩니다. 이 순서의 문제점은 운영자는 기존 배송지 정보를 이용해서 배송 상태로 변경했는데 그 사이 고객은 배송지 정보를 변경했다는 점입니다. 즉, 애그리거트 일관성이 깨지는 것입니다.

이런 문제가 발생하지 않도록 하려면 다음의 두 가지 중 하나를 해야합니다.

- 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막습니다.

- 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 합니다.

이 두가지는 애그리거트 자체의 트랙잭션과 관련이 있습니다. DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요합니다. 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점(Pessimistic)잠금과 비선점(Optimistic)잠금의 두 가지 방식이 있습니다.


## 선점 잠금

선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식입니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/101486379-e638d680-399f-11eb-971d-5c114e68f9da.png)


위 그림에서 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구하고 있는데, 이 경우 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때 까지 블로킹 됩니다.

스레드1이 애그리거트를 수정하고 트랜잭션을 커밋하면 잠금을 해제합니다. 이 순간 대기하고 있던 스레드2가 애그리거트에 접근하게 됩니다. 스레드1이 트랜잭션을 커밋한 뒤에 스레드2가 애그리거트를 구하게 되므로 스레드2는 스레드1이 수정한 애그리거트의 내용을 보게 됩니다.

한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있습니다. 앞서 배송지 정보 수정과 배송 상태 변경을 동시에 하는 문제에 선금 잠금 방식을 적용하면 아래 그림과 같이 동작합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/101486802-91499000-39a0-11eb-84e0-eeb1fa8e85c2.png)

운영자 스레드가 먼저 선점 잠금 방식으로 주문 애그리거트를 구한 경우 운영자 스레드가 잠금을 해제할 때까지 고객 스레드는 대기 상태가 됩니다. 운영자 스레드가 배송 상태로 변경한 뒤 트랜잭션을 커밋하면 잠금을 해제합니다. 잠금이 해제된 시점에 고객 스레드가 구하는 주문 애그리거트는 운영자 스레드가 수정한 배송 상태의 주문 애그리거트입니다. 배송 상태이므로 주문 애그리거트는 배송지 변경 시 에러를 발생하고 트랜잭션은 실패하게 됩니다. 이 시점에 고객은 `이미 배송이 시작되어 배송지를 변경할 수 없습니다`와 같은 안내 문구를 보게 될 것입니다.

선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현합니다. 오라클을 비롯한 다수 DBMS가 for update와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공합니다.

JPA의 EntityManager는 LockModeType을 인자로 받는 find() 메서드를 제공하는데, LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 해당 엔티티와 매핑된 테이블을 이용해서 선점 잠금 방식을 적용할 수 있습니다.

```java
Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
```

JPA 프로바이더와 DBMS에 따라 잠금 모드의 구현이 다른데, 하이버네이트의 경우 PESSIMISTIC_WRITE를 잠금 모드로 사용하면 `for update` 쿼리를 사용해서 선점 잠금을 구현합니다.
