## 아키텍처 개요

아키텍처를 설계할 때 출현하는 전형적인 영역이 `표현, 응용, 도메인, 인프라스트럭처`의 네영역입니다. 네 영역 표현 영역 또는 UI 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 합니다. 웹 애플리케이션을 개바랗라 때 많이 사용하는 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 속합니다. 웹 애플리케이션에서 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API를 호출하는 외부 시스템일 수도 있습니다.

웹 애플리케이션에서 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환해서 전달합니다. 예를 들어, 표현 영역은 웹 브라우저가 HTTP 요청 파라미터로 전송한 데이터를 응용 서비스가 요구하는 형식의 객체 타입으로 변환해서 전달하고, 응용 서비스가 리턴한 결과를 JSON 형식으로 변환해서 HTTP 응답으로 웹 브라우저에 전송합니다.

표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현합니다. 예를 들어, `주문 등록, 주문 취소, 상품 상세 조회`와 같은 기능을 구현합니다. 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용합니다. 주문 취소 기능을 제공하는 응용 서비스를 예로 들면 다음고 같이 주문 도메인 모델을 사용해서 기능을 구현합니다.

```java
public class CancelOrderService {

    @Transactional
    public void cancelOrder(String orderId) {
        Order order = findOrderById(orderId);
        if (order == null) throw new OrderNotFoundException(orderId);
        order.cacel();
    }
    ...
}
```

응용 서비스는 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임합니다. 위 코드도 주문 취소 로직을 직접 구현하지 않고 Order 객체에 취소 처리를 위임하고 있습니다.

>> 응용 영역은 도메인 모델을 이용해서 사용자에게 제공할 기능을 구현합니다. 실제 도메인 로직 구현은 도메인 모델에 위임합니다.

도메인 영역은 도메인 모델을 구현합니다. 앞에서 봤던 Order, OrderLine, ShippingInfo와 같은 도메인 모델이 이 영역에 위치합니다. 도메인 모델은 도메인 핵심 로직을 구현합니다. 주문 도메인의 경우 `배송지 변경, 결제완료, 주문총액계산`과 같은 핵심 로직을 도메인 모델에 구현합니다.

인프라스트럭쳐 영역은 구현 기술에 대한 것을 다룹니다. 이 영역은 RDBMS 연동을 처리하고, 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현하고, 몽고 DB나 HBase를 사용해서 데이터베이스 연동을 처리합니다. 이 영역은 SMTP를 이용한 메일발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API를 호출하는 것도 처리합니다. 인프라스트럭처 영역은 논리적인 개념을 표현하기 보다는 실제 구현을 다룹니다.

도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발합니다.

예를 들어 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어옵니다. 비슷하게 외부에 메일을 발송해야 하면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해서 메일을 발송합니다.

## 계층 구조 아키텍처

계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않습니다. 예를 들어, 표현 계층은 응용 계층에 의존하고 응용 계층이 도메인 계층에 의존하지만, 반대로 인프라스트럭처 계층이 도메인에 의존하거나 도메인이 응용 계층에 의존하지 않습니다.

계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만 편리함을 위해 계층 구조를 유연하게 적용합니다. 예를 들어, 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만, 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 스트럭처 계층에 의존하기도 합니다.

응용 영여과 도메인 영역은 DB나 외부 시스템 연동을 위해 인프라스트럭처의 기능을 사용하므로 이런 계층 구조를 사용하는 것은 직관적으로 이해하기 쉽습니다. 하지만, 짚고 넘어가야할 것이 있는데 바로 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다는 점입니다.

도메인 가격 계산 규칙을 예로 들어보겠습니다. 할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것보다 룰 엔진을 사용하는 것이 더 알맞을 때가 있습니다. 다음은 Drools라는 룰 엔진을 사용해서 로직을 수행할 수 있는 인프라스트럭처 영역의 코드를 만들어 본 것입니다. Drools 자체는 이 절의 주제가 아니므로 아래 코드가 무엇을 하는지 설명하지는 않습니다. evaluate() 메서드에 값을 주면 별도 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드라는 정도로만 생각하고 넘어갑시다.

```java
import java.util.List;

public class DroolsRuleEngine {

    private KieContainer kieContainer;

    public DroolsRuleEngine() {
        KieServices ks = KieServices.Factory.get();
        kContainer = ks.getKieClasspathContainer();
    }
    
    public void evalueate(String sessionName, List<?> facts) {
        KieSession kSession = kContainer.newKieSession(sessionName);
        try {
            
            facts.forEach(x -> kSession.insert(x));
            kSession.fireAllRules();
        } finally {
            kSession.dispose();
        }
    }
}
```

응용 영역은 가격 계산을 위해 인프라스트럭처 영역의 DroolsRuleEngine를 사용 합니다.

```java
import java.util.List;

public class CalculateDiscountService {

    private DroolsRuleEngine ruleEngine;


    public CalculateDiscountService() {
        ruleEngine = new DroolsRuleEngine();
    }

    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {

        Customer customer = findCustomer(customerId);

        MutableMoney money = new MutableMoney(0);
        List<?> facts = Arrays.asList(customer, money);

        facts.addAll(orderLines);
        ruleEngine.evaluate("discountCalculation", facts);
        return money.toImmutableMoney();
    }
    ...
}
```

CalculateDiscountService가 동작은 하겠지만 이 코드는 두 가지 문제점을 안고 있습니다. 첫 번째 문제는 CalculateDiscountService만 테스트하기 어렵다는 것입니다. CalculateDiscountService를 테스트하려면 RuleEngine이 완벽하게 동작해야 합니다. RuleEngine 클래스와 관련 설정 파일을 모두 만든 이후에 비로소 CalculateDiscountService가 올바르게 동작하는지 확인 할 수 있습니다.

두 번째 방식은 구현 방식을 변경하기 어렵다는 점입니다.

```java
// Drools에 특화된 코드 - 연산된 결과를 받기 위해 추가된 타입
MutableMoney money = new MutableMoney(0);
// Drools에 특화된 코드 - 룰에 필요한 데이터 지식
List<?> facts = Arrays.asList(customer, money);
// Drools에 특화된 코드 - Drools의 세션 이름
facts.addAll(orderLines);
```

코드만 보면 Drools가 제공하는 타입을 직접 사용하지 않으므로 CalculateDiscountService가 Drools 자체에 의존하지 않는다고 생각할 수 있습니다. 하지만 `discountCalculation` 문자열은 Drools의 세션 이름을 의미합니다. 따라서, Drools의 세션 이름을 변경하면 CalculateDiscountService의 코드도 함꼐 변경해야 합니다. MutableMoney는 룰 적용 결과값을 보관하기 위해 추가한 타입인데 다른 방식을 사용했다면 필요없는 타입입니다.

이처럼 CalculateDiscountService가 겉으로는 인프라스트럭처의 기술에 직접적인 의존을 하지 않는 것처럼 보여도 실제로는 Drools라는 인프라스트럭처 영역에 완전히 의존하고 있습니다. 이런 상황에서 Drools가 아닌 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야 합니다.

인프라스트럭처에 의존하면 `테스트 어려움`과 `기능 확장의 어려움`이라는 두 가지 문제가 발생하는 것을 알았습니다. 이 두 문제를 해소하는 방법은 DIP를 적용하는 것입니다.
