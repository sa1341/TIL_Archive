# 응용 서비스와 표현 영역


## 표현 영역과 응용 영역

이전 내용은 주로 도메인과 그 구현에 대한 것이였습니다. 도메인의 구성 요소와 JPA를 이용한 리포지터리 구현 방법들을 살펴보았습니다. 도메인 영역을 잘 구현하지 않으면 사용자의 요구를 충족하는 제대로 된 소프트웨어를 만들지 못합니다.

하지만, 도메인 영역만 잘 만든다고 끝나는 것은 아닙니다. 도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요합니다. 바로 응용 영역과 표현 영역이 사용자와 도메인을 연결해주는 매개체 역할을 합니다.

![image](https://user-images.githubusercontent.com/22395934/100451030-0e9c1780-30fa-11eb-83f1-9a8f9984f72a.png)

>> 사용자에게 기능을 제공하려면 도메인과 사용자를 연결해 줄 표현 영역과 응용 영역이 필요합니다.

표현 영역은 사용자의 요청을 해석합니다. 사용자가 웹 브라우저에서 폼에 아이디와 암호를 입력한 뒤에 전송 버튼을 클릭하면 요청 파라미터를 포함한 HTTP 요청을 표현 영역에 전달합니다. 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠기, 헤더 등을 이용해서 사용자가 어떤 기능을 실행하고 싶어 하는지 판별하고 그 기능을 제공하는 응용 서비스를 실행합니다.

실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스 입니다. 사용자가 회원 가입을 요청했다면 실제 그 요청을 위한 기능을 제공하는 주체는 응용 서비스에 위치합니다. 응용 서비스는 기능을 실행하는데 필요한 입력 값을 메서드 파라미터로 전달받고 실행 결과를 리턴합니다.

응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환합니다. 예를 들어, 표현 영역의 코드는 다음과 같이 폼에 입력한 요청 파라미터 값을 사용해서 응용 서비스가 요구하는 객체를 생성한 뒤, 응용 서비스의 메서드를 호출 합니다.

```java
@RequestMapping(value = "/member/join")
public ModelAndView join(HttpServletRequest request) {

    String email = request.getParameter("email");
    String password = request.getParameter("password");
    
    // 사용자 요청을 응용 서비스에 맞게 변환
    JoinRequest joinReq = new JoinRequest(email, password);
    // 변환한 객체(데이터)를 이용해서 응용 서비스 실행
    joinService.join(joinReq);
    ...
}
```

응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답합니다. 웹 브라우저인 경우 실행 결과를 HTML 형식으로 전송할 수 있습니다. REST를 클라이언트라면 JSON이나 xml과 같은 형식으로 응답할 것입니다.

사용자와의 상호작용은 표현영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않습니다. 응용 영역은 사용자가 웹 브라우저를 사용하는지, REST API를 호출하는지, TCP 소켓을 사용하는지 여부를 알 필요가 없습니다. 단지, 응용 영역은 기능 실행에 필요한 입력값을 전달받고 실행 결과만 리턴하면 될 뿐입니다.


## 응용 서비스의 역할

응용 서비스는 사용자가 요청한 기능을 실행합니다. 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용합니다.

응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현 영역 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구인 파사드 역할을 합니다.

응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 다음과 같이 단순한 형태를 갖습니다.

```java
public Result doSomeFunc(SomeReq req) {
    // 1. 리포지터리에서 애그리거트를 구합니다.
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);

    // 2. 애그리거트의 도메인 기능을 실행합니다.
    agg.doFunc(req.getValue());

    // 3. 결과를 리턴합니다.
    return createSuccessResult(agg);
}
```

새로운 애긜거트를 생성하는 응용 서비스 역시 간단합니다.

```java
public Result doSomeCreation(CreateSomeReq req) {

    // 1. 데이터 중복 등 데이터가 유효한지 검사합니다.
    checkVaild(req);

    // 2. 애그리거트를 생성합니다.
    SomeAgg newAgg = createSome(req);

    // 3. 리포지터리에 애그리거트를 저장합니다.
    someAggRepository.save(newAgg);
    
    // 4. 결과를 리턴합니다.
    return createSuccessResult(newAgg);
}
```

응용 서비스가 이것보다 복잡하면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높습니다. 응용 서비스가 도메인 로직을 일부 구현하면 코드 품질에 안좋은 영향을 주는데 뒤에서 이에 대해 살펴보겠습니다.

도메인 객체 간의 실행 흐름을 제어하는 것과 더불어 응용 서비스의 주된 역할 중 하나는 트랜잭션 처리입니다. 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 합니다. 한 번에 다수 회원을 차단 상태로 변경하는 응용 서비스를 생각해봅시다. 이 서비스는 차단 대상이 되는 Member 애그리거트 목록을 구하고 차례대로 차단 기능을 실행할 것 입니다.

```java
public void blockMembers(String[] blockingIds) {

    if (blockingIds == null || blockingIds.length == 0) return;

    List<Member> members = memberRepository.findByIds(blockingIds);

    for (Member member: members) {
        member.block();
    }
}
```

blockMembers() 메서드가 트랜잭션 범위에서 실행되지 않다고 가정해봅시다. Member 객체의 block() 메서드의 변경 상태를 DB에 반영하는 도중 문제가 발생하면 일부 Member만 차단 상태가 되어 데이터 일관성이 깨지게 됩니다. 이런 상황이 발생하지 않으려면 트랜잭션 범위에서 응용 서비스를 실행해야 합니다.

트랜잭션 외에 응용 서비스의 주요 역할로 접근 제어와 이벤트 처리가 있는데 이에 대한 내용도 추후에 살펴보겠습니다.

## 도메인 로직 넣지 않기

도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다고 했습니다. 암호 변경 기능을 예로 들어보겠습니다. 암호 변경 기능을 위한 응용 서비스는 Member 애그리거트와 관련 리포지터리를 이용해서 다음 코드처럼 도메인 객체간의 실행흐름을 제어합니다.

```java
public class ChangePasswordService {

    public void changePassowrd(String memberId, String oldPw, String newPw) {

        Member member = memberRepository.findById(memberId);
        checkMember(member);    
        member.changePassword(oldPw, newPw);
    }
}
```

Member 애그리거트는 암호를 변경하기 전에 기존 암호를 올바르게 입력했는지 확인하는 로직을 구현합니다.

```java
public class Member {   

    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw)) throw new BadPasswordException();
        setPassword(newPw);
    }

    private boolean matchPassword(String pwd) {
        return passwordEncoder.matches(pwd);
    }

    private void setPassword(String newPw) {
        if (isEmpty(newPw)) throw new IllegalArgumentException("no new password");
        this.password = newPw;
    }
}
```

기존 암호를 올바르게 입력했는지 여부를 확인하는 것은 도메인의 핵심 로직이기 때문에 다음 코드처럼 응용 서비스에 이 로직을 구현하면 안됩니다.

```java
public class ChangePasswordService {

    public void changePassowrd(String memberId, String oldPw, String newPw) {

        Member member = memberRepository.findById(memberId);
        checkMember(member);    

        if (!passwordEncoder.matches(oldPw, member.getPassword()){
            throw new BadPasswordException();
        }

        member.setPassword(newPw);
    }
}
```

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생합니다. 첫 번째 문제는 코드의 응집성이 떨어진다는 것입니다. 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 뜻합니다.

두 번째 문제는 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것입니다. 예를 들어, 비정상적인 계정 정지를 막기 위해 암호를 확인한다고 해보겠습니다. 이 경우 계정 정지 기능을 구현하는 응용 서비스는 다음과 같이 암호를 확인하는 코드를 구현해야 합니다.

```java
public class DeactivationService {  

    public void deactive(String memberId, String pwd) {
        Member member = memberRepository.findById(memberId);
        checkMember(member); 

         if (!passwordEncoder.matches(oldPw, member.getPassword(){
            throw new BadPasswordException();
        }
        member.deactivate();
    }
}
```

코드 중복을 막기 위해 응용 서비스 영역에 별도의 보조 클래스를 만들 수 있지만 애초에 도메인 영역에 암호 확인 기능을 구현했으면 응용 서비스는 그 기능을 사용하기만 하면 됩니다. 다음과 같이 암호 데이터를 가진 Member 객체에 암호 확인 기능을 구현하고 응용 서비스에서는 도메인이 제공하는 기능을 사용하면, 응용 서비스에서 도메인 로직을 구현하면서 발생하는 코드 중복 문제는 발생하지 않습니다.

```java
public class DeactivationService {  

    public void deactive(String memberId, String pwd) {
        Member member = memberRepository.findById(memberId);
        checkMember(); 

         if (!passwordEncoder.matches(oldPw, member.getPassword(){
            throw new BadPasswordException();
        }
        member.deactivate();
    }
}
```

일부 도메인 로직이 응용 서비스에 출현하면서 발생하는 두 가지 문제는 응집도가 떨어지고 코드 중복이 발생하는 결과적으로 코드 변경을 어렵게 만듭니다. 소프트웨어의 중요한 경쟁 요소 중 하나는 변경의 용이성인데, 변경이 어렵게 된다는 것은 그만큼 소프트웨어의 가치가 떨어진다는 것을 뜻합니다. 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 합니다.


## 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드(facade)와 같은 역할을 합니다. 응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않습니다. 이 절에서는 응용 서비스를 구현할 때 몇 가지 고려할 사항과 트랜잭션과 같은 구현 기술의 연동에 대해 살펴보겠습니다.

### 응용 서비스의 크기

응용 서비스 자체의 구현은 어렵지 않지만 몇 가지 생각할 거리가 있습니다. 그 중 하나가 응용 서비서의 크기입니다. 회원 도메인을 생각해봅시다. 응용 서비스는 회원 가입하기, 회원 탈퇴하기, 회원 암호 변경하기, 비밀번호 초기화와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 됩니다. 이 경우, 응용 서비스는 보통 다음 두 가지 방법 중 한 가지 방식으로 구현합니다.

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

회원과 관련된 기능을 한 클래스에서 모두 구현할 경우 다음과 같은 모습을 갖습니다.


각 메서드를 구현하는 데 필요한 리포지터리나 도메인 서비스는 필드로 추가합니다.

```java
public class MemberService {

    // 각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
    private MemberRepository memberRepository;

    public void join(MemberJoinRequest joinRequest) { ... }
    public void changePassword(String memberId, String currentPw, String newPw) { ... }
    public void initializePassword(String memberId) { ... }
    public void leave(String memberId, String curPw) { ... }
    ...
}
```

한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있습니다. 예를 들어, changePassoword(), initializePassword(), leave()는 회원이 존재하지 않으면 NotMemberException을 발생시켜야 한다고 해봅시다. 이 경우, 다음과 같이 중복된 로직을 구현한 private 메서드를 구현하고 이를 호출하는 방법으로 중복 로직을 쉽게 제거할 수 있습니다.

```java
public class MemberService {
    
    private MemberRepository memberRepository;
    private Notifier notifier;

    public void changePassword(String memberId, String currentPw, String newPw) {
        Member member = findExisitingMember(memberId);
        member.changePassword(currentPw, newPw);
    }

    public void initializePassword(String memberId) {
        Member member = findExistingMember(memberId);
        String newPassword = member.initializePassword();
        notifier.notifyNewPassowrd(member, newPassword);
    }

    public void leave(String memberId, String curPw) {
        Member meber = findExistingMember(memberId);
        member.leave();
    }

    // 각 기능의 동일 로직에 대한 구현 코드 중복을 쉽게 제거
    public Member findExistingMember(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) 
            throw new NoMemberException(memberId);
        return member;
    }
}
```

각 기능에서 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽다는 것이 장점이라면 한 서비스 클래스의 크기(코드 줄 수)가 커진다는 것은 이방식의 단점이 됩니다. 코드 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아짐을 의미하는데, 이는 결과적으로 관련 없는 코드가 뒤섞여서 코드를 이해하는데 방해가 될 수 있습니다.

예를 들어, 위 코드에서 암호 초기화 기능을 구현한 initializePassword() 메서드는 암호 초기화 후에 신규 암호를 사용자에게 통지하기 위해 Notifier를 사용하는데, 이 Notifier는 암호 변경 기능을 구현한 changePassword()에서는 필요하지 않는 기능입니다. 하지만 Notifier가 필드로 존재하기 때문에 이 Notifier가 어떤 기능 때문에 필요한지 확인하려면 각 기능을 구현한 코드를 뒤져야만 합니다.

게다가 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 됩니다. 이는 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래합니다.

구분되는 기능별로 서비스 클래스를 구현하는 방식은 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현합니다. 다음과 같이 암호 변경 기능만을 위한 응용 서비스 클래스를 별도로 구현하는 식입니다.

```java
public class ChangePasswordService {
    private MemberRepository meberRepository;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        if (member == null) throw new NoMemberException(memberId);
        member.changePassword(curPw, newPw);
    }
}
```

이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 됩니다. 또한, 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않습니다.

각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있습니다. 이런 경우 다음과 같이 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있습니다.

```java
// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현
public final class MemberServiceHelper {
    public static Member findExistingMember(MemberRepository repo, String memberId) {
        Member member = repo.findById(memberId);
        if (member = null) {
            throw new NoMemberException(memberId);
        }
        return member;
    }
}

// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용
import static com.myshop.member.application.MemberServiceHelper.*;
```

```java
public class ChangePasswordService {

    private MemberRepository memberRepository;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = findExistingMember(memberRepository, memberId);
        member.changePassword(curPw, newPw);
    }
}
```

개인적으로는 한 클래스가 여러 역할을 갖는 것보다 각 클래스마다 구분되는 역할을 갖는 것을 선호합니다. 즉, 한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보다 구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용합니다.

