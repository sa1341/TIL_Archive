# 응용 서비스와 표현 영역


## 표현 영역과 응용 영역

이전 내용은 주로 도메인과 그 구현에 대한 것이였습니다. 도메인의 구성 요소와 JPA를 이용한 리포지터리 구현 방법들을 살펴보았습니다. 도메인 영역을 잘 구현하지 않으면 사용자의 요구를 충족하는 제대로 된 소프트웨어를 만들지 못합니다.

하지만, 도메인 영역만 잘 만든다고 끝나는 것은 아닙니다. 도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요합니다. 바로 응용 영역과 표현 영역이 사용자와 도메인을 연결해주는 매개체 역할을 합니다.

![image](https://user-images.githubusercontent.com/22395934/100451030-0e9c1780-30fa-11eb-83f1-9a8f9984f72a.png)

>> 사용자에게 기능을 제공하려면 도메인과 사용자를 연결해 줄 표현 영역과 응용 영역이 필요합니다.

표현 영역은 사용자의 요청을 해석합니다. 사용자가 웹 브라우저에서 폼에 아이디와 암호를 입력한 뒤에 전송 버튼을 클릭하면 요청 파라미터를 포함한 HTTP 요청을 표현 영역에 전달합니다. 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠기, 헤더 등을 이용해서 사용자가 어떤 기능을 실행하고 싶어 하는지 판별하고 그 기능을 제공하는 응용 서비스를 실행합니다.

실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스 입니다. 사용자가 회원 가입을 요청했다면 실제 그 요청을 위한 기능을 제공하는 주체는 응용 서비스에 위치합니다. 응용 서비스는 기능을 실행하는데 필요한 입력 값을 메서드 파라미터로 전달받고 실행 결과를 리턴합니다.

응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환합니다. 예를 들어, 표현 영역의 코드는 다음과 같이 폼에 입력한 요청 파라미터 값을 사용해서 응용 서비스가 요구하는 객체를 생성한 뒤, 응용 서비스의 메서드를 호출 합니다.

```java
@RequestMapping(value = "/member/join")
public ModelAndView join(HttpServletRequest request) {

    String email = request.getParameter("email");
    String password = request.getParameter("password");
    
    // 사용자 요청을 응용 서비스에 맞게 변환
    JoinRequest joinReq = new JoinRequest(email, password);
    // 변환한 객체(데이터)를 이용해서 응용 서비스 실행
    joinService.join(joinReq);
    ...
}
```

응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답합니다. 웹 브라우저인 경우 실행 결과를 HTML 형식으로 전송할 수 있습니다. REST를 클라이언트라면 JSON이나 xml과 같은 형식으로 응답할 것입니다.

사용자와의 상호작용은 표현영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않습니다. 응용 영역은 사용자가 웹 브라우저를 사용하는지, REST API를 호출하는지, TCP 소켓을 사용하는지 여부를 알 필요가 없습니다. 단지, 응용 영역은 기능 실행에 필요한 입력값을 전달받고 실행 결과만 리턴하면 될 뿐입니다.


## 응용 서비스의 역할

응용 서비스는 사용자가 요청한 기능을 실행합니다. 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용합니다.

응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현 영역 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구인 파사드 역할을 합니다.

응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 다음과 같이 단순한 형태를 갖습니다.

```java
public Result doSomeFunc(SomeReq req) {
    // 1. 리포지터리에서 애그리거트를 구합니다.
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);

    // 2. 애그리거트의 도메인 기능을 실행합니다.
    agg.doFunc(req.getValue());

    // 3. 결과를 리턴합니다.
    return createSuccessResult(agg);
}
```

새로운 애긜거트를 생성하는 응용 서비스 역시 간단합니다.

```java
public Result doSomeCreation(CreateSomeReq req) {

    // 1. 데이터 중복 등 데이터가 유효한지 검사합니다.
    checkVaild(req);

    // 2. 애그리거트를 생성합니다.
    SomeAgg newAgg = createSome(req);

    // 3. 리포지터리에 애그리거트를 저장합니다.
    someAggRepository.save(newAgg);
    
    // 4. 결과를 리턴합니다.
    return createSuccessResult(newAgg);
}
```

응용 서비스가 이것보다 복잡하면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높습니다. 응용 서비스가 도메인 로직을 일부 구현하면 코드 품질에 안좋은 영향을 주는데 뒤에서 이에 대해 살펴보겠습니다.

도메인 객체 간의 실행 흐름을 제어하는 것과 더불어 응용 서비스의 주된 역할 중 하나는 트랜잭션 처리입니다. 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 합니다. 한 번에 다수 회원을 차단 상태로 변경하는 응용 서비스를 생각해봅시다. 이 서비스는 차단 대상이 되는 Member 애그리거트 목록을 구하고 차례대로 차단 기능을 실행할 것 입니다.

```java
public void blockMembers(String[] blockingIds) {

    if (blockingIds == null || blockingIds.length == 0) return;

    List<Member> members = memberRepository.findByIds(blockingIds);

    for (Member member: members) {
        member.block();
    }
}
```

blockMembers() 메서드가 트랜잭션 범위에서 실행되지 않다고 가정해봅시다. Member 객체의 block() 메서드의 변경 상태를 DB에 반영하는 도중 문제가 발생하면 일부 Member만 차단 상태가 되어 데이터 일관성이 깨지게 됩니다. 이런 상황이 발생하지 않으려면 트랜잭션 범위에서 응용 서비스를 실행해야 합니다.

트랜잭션 외에 응용 서비스의 주요 역할로 접근 제어와 이벤트 처리가 있는데 이에 대한 내용도 추후에 살펴보겠습니다.

## 도메인 로직 넣지 않기

도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다고 했습니다. 암호 변경 기능을 예로 들어보겠습니다. 암호 변경 기능을 위한 응용 서비스는 Member 애그리거트와 관련 리포지터리를 이용해서 다음 코드처럼 도메인 객체간의 실행흐름을 제어합니다.

```java
public class ChangePasswordService {

    public void changePassowrd(String memberId, String oldPw, String newPw) {

        Member member = memberRepository.findById(memberId);
        checkMember(member);    
        member.changePassword(oldPw, newPw);
    }
}
```

Member 애그리거트는 암호를 변경하기 전에 기존 암호를 올바르게 입력했는지 확인하는 로직을 구현합니다.

```java
public class Member {   

    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw)) throw new BadPasswordException();
        setPassword(newPw);
    }

    private boolean matchPassword(String pwd) {
        return passwordEncoder.matches(pwd);
    }

    private void setPassword(String newPw) {
        if (isEmpty(newPw)) throw new IllegalArgumentException("no new password");
        this.password = newPw;
    }
}
```

기존 암호를 올바르게 입력했는지 여부를 확인하는 것은 도메인의 핵심 로직이기 때문에 다음 코드처럼 응용 서비스에 이 로직을 구현하면 안됩니다.

```java
public class ChangePasswordService {

    public void changePassowrd(String memberId, String oldPw, String newPw) {

        Member member = memberRepository.findById(memberId);
        checkMember(member);    

        if (!passwordEncoder.matches(oldPw, member.getPassword()){
            throw new BadPasswordException();
        }

        member.setPassword(newPw);
    }
}
```

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생합니다. 첫 번째 문제는 코드의 응집성이 떨어진다는 것입니다. 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 뜻합니다.

두 번째 문제는 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것입니다. 예를 들어, 비정상적인 계정 정지를 막기 위해 암호를 확인한다고 해보겠습니다. 이 경우 계정 정지 기능을 구현하는 응용 서비스는 다음과 같이 암호를 확인하는 코드를 구현해야 합니다.

```java
public class DeactivationService {  

    public void deactive(String memberId, String pwd) {
        Member member = memberRepository.findById(memberId);
        checkMember(member); 

         if (!passwordEncoder.matches(oldPw, member.getPassword(){
            throw new BadPasswordException();
        }
        member.deactivate();
    }
}
```

코드 중복을 막기 위해 응용 서비스 영역에 별도의 보조 클래스를 만들 수 있지만 애초에 도메인 영역에 암호 확인 기능을 구현했으면 응용 서비스는 그 기능을 사용하기만 하면 됩니다. 다음과 같이 암호 데이터를 가진 Member 객체에 암호 확인 기능을 구현하고 응용 서비스에서는 도메인이 제공하는 기능을 사용하면, 응용 서비스에서 도메인 로직을 구현하면서 발생하는 코드 중복 문제는 발생하지 않습니다.

```java
public class DeactivationService {  

    public void deactive(String memberId, String pwd) {
        Member member = memberRepository.findById(memberId);
        checkMember(); 

         if (!passwordEncoder.matches(oldPw, member.getPassword(){
            throw new BadPasswordException();
        }
        member.deactivate();
    }
}
```

일부 도메인 로직이 응용 서비스에 출현하면서 발생하는 두 가지 문제는 응집도가 떨어지고 코드 중복이 발생하는 결과적으로 코드 변경을 어렵게 만듭니다. 소프트웨어의 중요한 경쟁 요소 중 하나는 변경의 용이성인데, 변경이 어렵게 된다는 것은 그만큼 소프트웨어의 가치가 떨어진다는 것을 뜻합니다. 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 합니다.


## 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드(facade)와 같은 역할을 합니다. 응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않습니다. 이 절에서는 응용 서비스를 구현할 때 몇 가지 고려할 사항과 트랜잭션과 같은 구현 기술의 연동에 대해 살펴보겠습니다.

### 응용 서비스의 크기

응용 서비스 자체의 구현은 어렵지 않지만 몇 가지 생각할 거리가 있습니다. 그 중 하나가 응용 서비서의 크기입니다. 회원 도메인을 생각해봅시다. 응용 서비스는 회원 가입하기, 회원 탈퇴하기, 회원 암호 변경하기, 비밀번호 초기화와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 됩니다. 이 경우, 응용 서비스는 보통 다음 두 가지 방법 중 한 가지 방식으로 구현합니다.

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

회원과 관련된 기능을 한 클래스에서 모두 구현할 경우 다음과 같은 모습을 갖습니다.


각 메서드를 구현하는 데 필요한 리포지터리나 도메인 서비스는 필드로 추가합니다.

```java
public class MemberService {

    // 각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
    private MemberRepository memberRepository;

    public void join(MemberJoinRequest joinRequest) { ... }
    public void changePassword(String memberId, String currentPw, String newPw) { ... }
    public void initializePassword(String memberId) { ... }
    public void leave(String memberId, String curPw) { ... }
    ...
}
```

한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있습니다. 예를 들어, changePassoword(), initializePassword(), leave()는 회원이 존재하지 않으면 NotMemberException을 발생시켜야 한다고 해봅시다. 이 경우, 다음과 같이 중복된 로직을 구현한 private 메서드를 구현하고 이를 호출하는 방법으로 중복 로직을 쉽게 제거할 수 있습니다.

```java
public class MemberService {
    
    private MemberRepository memberRepository;
    private Notifier notifier;

    public void changePassword(String memberId, String currentPw, String newPw) {
        Member member = findExisitingMember(memberId);
        member.changePassword(currentPw, newPw);
    }

    public void initializePassword(String memberId) {
        Member member = findExistingMember(memberId);
        String newPassword = member.initializePassword();
        notifier.notifyNewPassowrd(member, newPassword);
    }

    public void leave(String memberId, String curPw) {
        Member meber = findExistingMember(memberId);
        member.leave();
    }

    // 각 기능의 동일 로직에 대한 구현 코드 중복을 쉽게 제거
    public Member findExistingMember(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) 
            throw new NoMemberException(memberId);
        return member;
    }
}
```

각 기능에서 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽다는 것이 장점이라면 한 서비스 클래스의 크기(코드 줄 수)가 커진다는 것은 이방식의 단점이 됩니다. 코드 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아짐을 의미하는데, 이는 결과적으로 관련 없는 코드가 뒤섞여서 코드를 이해하는데 방해가 될 수 있습니다.

예를 들어, 위 코드에서 암호 초기화 기능을 구현한 initializePassword() 메서드는 암호 초기화 후에 신규 암호를 사용자에게 통지하기 위해 Notifier를 사용하는데, 이 Notifier는 암호 변경 기능을 구현한 changePassword()에서는 필요하지 않는 기능입니다. 하지만 Notifier가 필드로 존재하기 때문에 이 Notifier가 어떤 기능 때문에 필요한지 확인하려면 각 기능을 구현한 코드를 뒤져야만 합니다.

게다가 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 됩니다. 이는 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래합니다.

구분되는 기능별로 서비스 클래스를 구현하는 방식은 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현합니다. 다음과 같이 암호 변경 기능만을 위한 응용 서비스 클래스를 별도로 구현하는 식입니다.

```java
public class ChangePasswordService {
    private MemberRepository meberRepository;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        if (member == null) throw new NoMemberException(memberId);
        member.changePassword(curPw, newPw);
    }
}
```

이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 됩니다. 또한, 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않습니다.

각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있습니다. 이런 경우 다음과 같이 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있습니다.

```java
// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현
public final class MemberServiceHelper {
    public static Member findExistingMember(MemberRepository repo, String memberId) {
        Member member = repo.findById(memberId);
        if (member = null) {
            throw new NoMemberException(memberId);
        }
        return member;
    }
}

// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용
import static com.myshop.member.application.MemberServiceHelper.*;
```

```java
public class ChangePasswordService {

    private MemberRepository memberRepository;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = findExistingMember(memberRepository, memberId);
        member.changePassword(curPw, newPw);
    }
}
```

개인적으로는 한 클래스가 여러 역할을 갖는 것보다 각 클래스마다 구분되는 역할을 갖는 것을 선호합니다. 즉, 한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보다 구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용합니다.

## 응용 서비스의 인터페이스와 클래스

응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한지 여부입니다. 다음과 같이 인터페이스를 만들고 이를 상속한 클래스를 만드는 것이 필요할까요?

```java
public interface ChangePassword {
    public void changePassword(String memberId, String curPw, String newPw);
}

public class ChangePasswordImpl implements ChangePasswordService {
    ... 구현
}
```

인터페이스가 필요한 몇 가지 상황이 있는데 그중 하나는 구현 클래스가 여러 개인 경우입니다. 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우 인터페이스를 유용하게 사용할 수 있습니다. 그런데, 응용 서비스는 보통 런타임에 이를 교체하는 경우가 거의 없을 뿐만 아니라 한 응용 서비스의 구현 클래스가 두 개인 경우도 매우 드뭅니다.

이런 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 문제가 발생합니다. 따라서 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하지 않는 것이 좋은 설계라고는 볼 수 없습니다.

테스트 주도 개발(TDD)를 즐겨하고 표현 영역부터 개발을 시작한다면 미리 응용 서비스를 구현할 수 없으므로 응용 서비스의 인터페이스부터 작성하게 될 것입니다.

예를 들어, 스프링 MVC의 컨트롤러를 TDD로 먼저 개발한다면 컨트롤러에서 사용할 응용 서비스 클래스의 구현은 존재하지 않으므로 응용 서비스의 인터페이스를 이용해서 컨트롤러 구현을 완성해 나가게 됩니다.

표현 영역이 아닌 도메인 영역이나 응용 영역의 개발을 먼저 시작하면 응용 서비스 클래스가 먼저 만들어집니다. 이렇게 되면 표현 영역의 단위 테스트를 위해 응용 서비스 클래스가 가짜 객체가 필요한데 이를 위해 인터페이스를 추가할 수도 있습니다. 하지만, Mokito와 같은 테스트 도구는 클래스에 대해서도 테스트용 가짜 객체를 만들기 때문에 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트할 수 있습니다. 이는 결과적으로 응용 서비스에 대한 인터페이스 필요성을 약화 시킵니다.

## 메서드 파라미터와 값 리턴

응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터를 통해 전달받아야 합니다. 암호 변경 응용 서비스는 암호 변경 기능을 구현하는데 필요한 세 값인 회원 아이디, 현재 암호, 변경할 암호를 파라미터로 전달받아야 합니다.

```java
public class ChangePasswordService {

    public void changePassword(String memberId, String curPw, String newPw) {
        ...
    }
}
```

위 코드처럼 필요한 각 값을 개별 파라미터로 전달받을 수도 있고, 다음 코드와 같이 값 전달을 위한 별도 데이터 클래스를 만들어 전달받을 수도 있습니다.

```java
public class ChangePasswordRequest {
    private String memberId;
    private String curPw;
    private String newPw;

    ... 생성자나 get 메서드
    public String getMemberId() { return memberId; }
    public String getCurrentPassword() { return curPw; }
    public String getNewPassword() { return newPw; }
}
```

응용 서비스는 데이터 클래스를 파라미터로 전달받고 필요한 데이터를 추출해서 필요한 기능을 구현하면 됩니다.

```java
public class ChangePasswordService {
    public void changePassword(ChangePasswordRequest reuquest) {
        Member member = findExistingMember(request.getMemberId());
        member.changePassword(request.getCurrentPassword(), request.getNewPassword());
    }
    ...
}
```

스프링 MVC와 같은 웹 프레임워크는 웹 요청 파라미터를 자바 객체로 변환해 주는 기능을 제공하므로 응용 서비스에 데이터로 전달할 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 편리합니다.

```java
@Controller
@RequestMapping(value = "/member/changePassword") 
public class MemberPasswordController {

    @Autowired
    private ChangePasswordService changePasswordService;

    // 자바 클래스를 이용해서 응용 서비스에 데이터를 전달하면
    // 프레임워크가 제공하는 기능을 활용하기에 좋음
    @RequestMapping(method = RequestMethod.POST)
    public String submit(ChangePasswordRequest changePwdReq) {

        Authentication auth = SecurityContext.getAuthentication();
        changePwdReq.setMemberId(auth.getId());
    
        try {
            changePasswordSerivce.changePassword(changePwdReq);
        } catch (NoMemberException ex) {
            // 알맞은 익셉션 처리 및 응답
        }
    }
 ...
}
```

표현 영역에서 응용 서비스의 결과가 필요하다면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴합니다. 결과 데이터가 필요한 대표적인 예가 주문 기능 실행 후 주문번호입니다. 온라인 쇼핑몰을 보면 주문 후 주문 상세내역을 볼 수 있는 링크를 바로 보여줍니다. 이 링크를 제공하려면 방금 요청한 주문의 번호를 알아야 합니다. 이 요구를 충족하려면 주문 응용 서비스는 주문 요청 처리 후에 주문번호를 결과로 리턴해야 합니다.

```java
public class OrderService {

    @Transactional
    public OrderNo placeOrder(OrderRequest orderRequest) {
        OrderNo orderNo = orderRepository.nextId();
        Order order = createOrder(orderNo, orderRequest);
        orderRepository.save(order);
        
        return orderNo;
    }
    ...
}
```

위 코드를 사용하는 표현 영역의 코드는 응용 서비스가 리턴한 값을 사용해서 사용자에게 알맞은 결과를 보여줄 수 있게 됩니다. 예를 들어, 스프링 MVC의 컨트롤러를 사용한다면 다음과 같이 결과를 모델에 담아 뷰 코드에서 링크를 생성하는데 사용할 것입니다.

```java
@Controller
public class OrderController {

    @RequestMapping(value = "order/place", method = RequestMethod.POST) {
        setOrderer(orderReq);
        OrderNo orderNo = orderService.placeOrder(orderReq);
        modelMap.setAttribute("orderNo", orderNo.toString());
        return "order/success";
    }
}
```

다음 코드처럼 응용 서비스에서 애그리거트 객체를 그대로 리턴할 수도 있을 것입니다.

```java
public Order placeOrder(OrderRequest req) {
    ...
    return order;
}
```

표현 영역 코드는 응용 서비스가 리턴한 주문 애그리거트 객체에서 주문번호를 구해 사용자에게 보여줄 응답 화면을 생성하면 됩니다.

```java
@Controller
public class OrderController {  

    @RequestMapping(value = "order/place", method = RequestMethod.POST) 
    public String order(OrderRequest orderReq, ModelMap model) {
        setOrder(orderReq);
        Order order = orderService.placeOrder(orderReq);
        modelMap.setAttribute("order", order);
        return "order/success";
    }
    ...
    // 뷰 코드
    <a href="/orders/my/${order.number}">주문 내용 보기</a>    
}
```

응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 됩니다. 이는 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 됩니다. 애그리거트의 상태를 변경하는 응용 서비스가 애그리거트를 리턴할 경우 해당 애그리거트의 기능을 컨트롤러나 뷰 코드에서 실행하면 안 된다는 규칙을 정할 수 있겠지만, 그보다는 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법입니다.

## 표현 영역에 의존하지 않기

응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안된다는 점입니다. 예를 들어, 다음과 같이 표현 영역에 해당하는 HttpServletRequest나 HttpSession을 응용 서비스에 파라미터로 전달하면 안됩니다.


```java
@Controller
@RequestMapping(value = "/member/changePassword")
public class MemberPasswordController {

    @RequestMapping(method = RequestMethod.POST)
    public String submit(HttpServletRequest request) {
        try {
            // 응용 서비스가 표현 영역에 대한 의존이 발생하면 안됩니다.
            changePasswordService.chanePassword(request);
        } catch (NoMemberException ex) {
            // 알맞은 익셉션 처리 및 응답
        }
    }
}
```

응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워집니다. 게다가 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 하는 문제도 발생합니다.

이 두 문제보다 더 나쁜 문제는 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다는 것입니다. 예를 들어, 응용 서비스에 파라미터로 HttpServletRequest를 전달했는데 응용 서비스에서 HttpSession을 생성하고 세션에 인증과 관련된 정보를 담는다고 해봅시다.

```java
public class AuthenticationService {

    public void authenticate(HttpServletRequest request) {

        String id = request.getParameter("id");
        String password = request.getParameter("passsword");

        if (checkIdPassowrdMatching(id, password)) {
            // 응용 서비스에서 표현 영역의 상태 처리
            HttpSession session = request.getSession();
            session.setAttribute("auth", new Authentication(id));
        }
    }
}
```

HttpSession이나 쿠키는 표현 영역의 상태에 해당하는데 이 상태를 응용 서비스에서 변경해 버리면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워 집니다. 즉, 표현 영역의 응집도가 깨지는 것입니다. 이는 결과적으로 코드를 유지보수하는 비용을 증가시키기는 원인이 됩니다.

이러한 문제가 발생하지 않도록 하려면 철저하게 응용 서비스가 표현 영역의 기술을 사용하지 않도록 해야합니다. 이를 지키기 위한 가장 쉬운 방법이 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것입니다.
