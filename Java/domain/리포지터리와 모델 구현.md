## 리포지터리와 모델 구현(JPA 중심)

이번 장의 주제는 리포지터리 구현입니다. 애그리거트를 어떤 저장소에 저장하냐느냐에 따라 리포지터리를 구현하는 방법이 다르기 때문에 모든 구현 기술에 대해 알아 볼 수는 없습니다. 도메인 모델과 리포지터리를 구현할 때 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM만한 것이 없습니다. 다양한 ORM 기술이 존재하지만, 이 절에서는 자바의 ORM 표준인 JPA를 이용해서 리포지터리와 애그리거틀 구현하는 방법에 대해 살펴보겠습니다.

## 모듈 위치

앞에서 본 것처럼 리포지터리 인터페이스는 애그리그터와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속합니다. 

가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존성을 낮춰야 합니다.

## 리포지터리 기본 기능 구현

리포지터리의 기본 기능은 다음의 두 가지입니다.

- 아이디로 애그리거트 조회하기
- 애그리거트 저장하기

이 두메서드를 위한 리포지터리 인터페이스는 다음과 같은 형식을 갖습니다.

```java
public interface OrderRepository {
    public Order findById(orderNo no);
    public void save(Order order);
}
```

인터페이스는 애그리거트 루트를 기준으로 작성합니다. 주문 애그리거트는 Order 루트 엔티티를 비롯해 OrderLine, Orderer, ShippingInfo 등 다양한 객체를 포함하는데, 이 구성요소 중에서 Order 루트 엔티티를 기준으로 리포지터리 인터페이스를 작성합니다.

애그리거트를 조회하는 기능의 이름을 지을 때 특별한 규칙은 없지만 널리 사용되는 규칙은 findBy 프로퍼티(프로퍼티 값)의 형식을 사용하는 것입니다. 위 인터페이스의 경우 아이디로 애그리거트를 조회하는 메서드의 이름을 findById()로 지정하였습니다.

findById()는 아이디에 해당하는 애그리거트가 존재하면 Order를 리턴하고, 존재하지 않으면 null을 리턴합니다. null을 사용하고 싶지 않다면 자바 8의 Optional을 이용해 해시값을 리턴해도 됩니다.

save() 메서드는 전달받는 애그리거트를 저장합니다. 이 인터페이스를 구현한 클래스는 JPA의 EntityManager를 이용해서 기능을 구현합니다. 스프링 프레임워크에 기반한 리포지터리 구현 클래스는 아래 코드와 같습니다.


```java
@Repository
public class JpaOrerRepository implements OrderRepository {

    @PersistenceContext
    private EntityManager em;

    @Override
    public Order findById(OrderNo id) {
        return em.find(Order.class, id);
    }

    @Override
    public void save(Order order) {
        em.persist(order);
    }
}
```

- EntityManager의 find 메서드를 이용해서 아이디로 애그리거트를 검색합니다.
- EntityManager의 persist 메서드를 이용해서 애그리거트를 저장합니다.

애그리거트를 수정한 결과를 저장소에 반영하느 ㄴ메서드를 추가할 필요는 없습니다.  JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문입니다.

```java
public classs ChangeOrderService {

    @Transactional
    public void changeShippingInfo(OrderNo no, ShippingInfo newShippingInfo) {
        Order order = orderRepository.findById(no);
        if (order == null) throw new OrderNotFoundException();
        order.changeShippingInfo(newShippingInfo);
    }
}
```

이 코드에서 changeShippingInfo() 메서드는 스프링 프레임워크의 트랜잭션 관리 기능을 통해 트랜잭션 범위에서 실행됩니다. 메서드는 실행이 끝나면 트랜잭션을 커밋하는데, 이 때 JPA는 트랜잭션 범위에서 변경된 객체의 데이터를 DB에 반영하기 위해 UPDATE 쿼리를 실행합니다. order.changeShippingInfo() 메서드의 실행 결과로 애그리거트 내부의 객체가 변경되면 JPA는 변경 데이터를 DB에 반영하기 위해 UPDATE 쿼리를 실행합니다.

다른 조건으로 애그리거트를 조회할 때에는 JPA의 Criteria나 JPQL을 사용합니다. 아래 코드는 JPQL을 이용해서 findByOrderId() 메서드를 구현한 코드입니다.

```java
@Override
public List<Order> findByOrderId(String orderId, int startRow, int fetchSize) {

    TypedQuery<Order> query = em.createQuery(
        "select o from Order o " +
        "where o.orderer.memberId.id = :orderId " + 
        "order by o.number.number desc",
        Order.class);
    query.setParameter("ordererId", ordererId);
    query.setFirstResult(startRow);
    query.setMaxResults(fetchSize);
    return query.getResultList();
}
```

애그리거트를 삭제하는 기능이 필요할 수도 있습니다. 삭제 기능을 위한 메서드는 다음과 같이 삭제할 애그리거트 객체를 파라미터로 전달받습니다.

```java
public interface OrderRepository {
    ...
    public void delete(Order order);
}
```

구현 클래스는 EntityManager의 remove() 메서드를 이용해서 삭제 기능을 구현합니다.

```java
public class JpaOrerRepository implements OrderRepository {

    @PersistenceContext
    private EntityManager em;

    @Override
    public void remove(Order order) {
        em.remove(order);
    }
}
```

>> 삭제 기능은 요구사항이 있더라도 여러 이유로 데이터를 실제로 삭제하는 경우는 많지 않습니다. 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터 원복을 위해 일정 기간동안 보관해야 할 때도 있기때문입니다. 이런 이유로 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기 보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현합니다.

## 매핑 구현

엔티티와 벨류 기본 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 아래와 같습니다.

- 애긜거트 루트는 엔티티이므로 @Entity로 매핑 설정합니다.
- 한 테이블에 엔티티와 벨류 데이터가 같이 있다면,
    - 밸류는 @Embeddable로 매핑 설정합니다.
    - 밸류 타입 프로퍼티는 @Embedded로 매핑 설정 합니다.

주문 애그리거트를 예로 들어봅시다. 주문 애그리거트의 루트 엔티티는 Order이고 이 애그리거트에 속한 Orderer와 ShippingInfo는 밸류인데, 이 세 객체와 ShippingInfo에 포함된 Address 객체와 Receiver 객체는 한 테이블에 매핑할 수 있습니다. 루트 엔티티와 루트 엔티티에 속한 밸류는 보통 한 테이블에 매핑될 때가 많습니다.


```java
import javax.persistence.*;

@Table(name = "purchase_order")
@Entity
public class Order {
    ...
}
```

Order에 속하는 Orderer는 밸류이므로 @Embeddable로 매핑합니다.

```java
import javax.persistence.*;

@Embeddable
public class Orderer {

    // MemberId에 정의된 컬럼 이름을 변경하기 위해
    // @AttributeOverride 에노테이션 사용
    @Embedded
    @AttributeOverrides(
            @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}
```

Orderer의 memberId는 Member 애그리거트를 ID로 참조합니다. Member의 아이디 타입으로 사용되는 MemberId는 다음과 같이 id 프로퍼티와 매핑되는 테이블 컬럼 이름으로 "meber_id"를 지정하고 있습니다.

```java
import javax.persistence.Column;
import javax.persistence.Embeddable;
import java.io.Serializable;

@Embeddable
public class MemberId implements Serializable {

    @Column(name = "member_id")
    private String id;
}
```

Orderer의 memberId 프로퍼티와 매핑되는 컬럼 이름은 `orderer_id`이므로 MemberId에 설정된 `member_id`와 이름이 다릅니다. @Embeddable 타입에 설정한 컬럼 이름과 실제 컬럼 이름이 다르므로 Orderer의 memberId 프로퍼티를 매핑할 때 @AttributeOverrides 에노테이션을 이용해서 매핑할 컬럼 이름을 변경했습니다.

JPA 2부터 @Embeddable은 중첩을 허용하므로 밸류인 Orderer가 또 다른 밸류인 MemberId를 포함할 수 있습니다. Orderer와 마찬가지로 ShippinInfo 밸류도 또 다른 밸류인 Address와 Receiver를 포함합니다. Address의 매핑 설정과 다른 컬럼 이름을 사용하기 위해 @AttributeOverride 에노테이션을 사용합니다.

```java
import javax.persistence.*;

@Embeddable
public class ShippingInfo {

    @Embedded
    @AttributeOverrides({
      @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zipcode")),
      @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
      @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
    })
    private Address address;
    
    @Column(name = "shipping_message")
    private String message;
    
    @Embedded
    private Receiver receiver;
}
```

Order 애그리거트 루트 엔티티는 @Embedded를 이용해서 밸류 타입 프로퍼티를 설정합니다.

```java
import javax.persistence.*;

@Entity
public class Order {
    ...

    @Embedded
    private Orderer orderer;
    
    @Embedded
    private ShippingInfo shippingInfo;

    ...
}
```

## 기본 생성자

엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받습니다. Receiver 밸류 타입의 경우 생성 시점에 수취인 이름과 연락처를 생성자 파라미터로 전달받습니다.

```java
public class Receiver {
    private String name;
    private String phone;

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
    ...
}
```

Receiver가 불변 타입이면 생성 시점에 필요한 값을 모두 전달받으므로 값을 변경하는 set 메서드를 제공하지 않습니다. 이는 Receiver 클래스에 (파라미터가 없는)기본 생성자를 추가할 필요가 없다는 것을 뜻합니다.

하지만 JPA의 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 합니다. 하이버네이트와 같은 JPA 프로바이더는 DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성합니다. 이런 기술적인 제약으로 Receiver와 같은 불변 타입은 기본 생성자가 필요없음에도 불구하고 다음과 같이 기본 생성자를 추가해야 합니다.

```java
public class Receiver {
   
    @Column(name = "receiver_name")
    private String name;
    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {} // JPA를 적용하기 위해 기본 생성자 추가

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
    ... // get 메서드 생략
}
```

기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용합니다. 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 됩니다. 이런 이유로 다른 코드에서 기본 생성자를 사용하지 못하도록 protected로 선언합니다.


>> 하이버네이트는 클래스를 상속한 프록시 객체를 이용해서 지연 로딩을 구현합니다.
아 경우 프록시 클래스에서 상위 클래스의 기본 생성자를 호출할 수 있어야 하므로 지연 로딩 대상이 되는 @Entity와 @Embeddable의 기본 생성자는 private가 아닌 protected로 지정해야 합니다.

## 필드 접근 방식

JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있습니다. 메서드 방식을 사용하려면 다음과 같이 프로퍼티를 위한 get/set 메서드를 구현해야 합니다.

```java
@Access(AccessType.PROPERTY)
@Entity
public class Order {

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    public OrderState getState() {
        return state;
    }

    public void setState(OrderState state) {
        this.state = state;
    }
    ...
}
```

엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아집니다. 특히 set 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있습니다.

엔티티가 객체로서 제 역할을 하려면 외부에 set 메서드 대신 의도가 잘 드러나는 기능을 제공해야 합니다. 상태 변경을 위한 setState() 메서드보다 주문 취소를 위한 cancel() 메서드가 도메인을 더 잘 표현하고, setShippingInfo() 메서드보다 배송지를 변경한다는 의미를 갖는 changeShippingInfo()가 도메인을 더 잘 표현합니다.

밸류 타입을 불변으로 구현하고 싶은 경우 set 메서드 자체가 필요 없는데 JPA의 구현 방식 때문에 공개 set 메서드를 추가하는 것도 좋지 않습니다.

엔티티를 객체가 제공할 기능 중심으로 구현하도록 유지하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 합니다.

```java
@Access(AccessType.FIELD)
@Entity
public class Order {

    @Embedded
    private OrderNo number;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;


    ... // cancel(), changeShippingInfo() 등 도메인 기능 구현
    ... // 필요한 get 메서드 제공
}
```

JPA 구현체인 하이버네이트는 @Access를 이용해서 명시적으로 접근 방식을 지정하지 않으면 @Id나 @EmbeddedId가 어디에 위치했느냐에 따라 접근 방식을 결정합니다. @Id나 @EmbeddedId가 필드에 위치하면 필드 접근 방식을 선택하고, get 메서드에 위치하면 메서드 접근 방식을 선택합니다.



## AttributeConverter를 이용한 밸류 매핑 처리

int, long, String, LocalDate와 같은 타입은 DB 테이블의 한 개 컬럼과 매핑 됩니다. 이와 비슷하게 밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때도 있습니다. 
예를 들어, Length가 길이 값과 단위의 두 프로퍼티를 갖고 있는데 DB 테이블에는 한 개 컬럼에 `1000mm`와 같은 형식으로 저장할 수 있습니다.

![image](https://user-images.githubusercontent.com/22395934/99877372-11ea5b80-2c41-11eb-98f4-7394a3d080f7.png)


두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑해야 할 경우 @Embeddable로는 처리할 수 없습니다. JPA 2.0 버전에는 이를 처리하기 위해 다음과 같이 컬럼과 매핑하기 위한 프로퍼티를 따로 추가하고 get/set 메서드에서 실제 밸류 타입과 변환 처리를 해야 했습니다.


```java
public class Product {

    @Column(name = "WIDTH")
    private String width;

    public Length getWidth() {
        return new Width(width); // DB 칼럼 값을 실제 프로퍼티 타입으로 변환
    }

    void setWith(Length width) {
        this.width = width.toString(); // 실제 프로퍼티 타입을 DB 컬럼 값으로 변환
    }
}
```

JPA 2.1에서는 DB 컬럼과 밸류 사이의 변환 코드를 모델에 구현하지 않아도 됩니다. 대신 AttributeConverter를 사용해서 변환을 처리 할 수 있습니다. AttributeConverter는 JPA 2.1에 추가된 인터페이스로 다음과 같이 밸류 타입과 칼럼 데이터 간의 변환 처리를 위한 기능을 정의하고 있습니다.

```java
package javax.persistence;

public interface AttributeConverter<X,Y> {

    public Y convertToDatabaseColumn (X attribute);
    public X convertToEntityAttribute (y dbData);
}
```

타입 파라미터 X는 밸류 타입이고, Y는 DB 타입입니다. convertToDatabaseColumn() 메서드는 밸류 타입을 DB 칼럼 값으로 변환하는 기능을 구현하고, convertToEntityAttribute() 메서드는 DB 칼럼 값을 밸류로 변환하는 기능을 구현합니다.

이 책에서 사용하는 Money 밸류 타입을 위한 AttributeConverter는 아래 코드와 같이 구현할 수 있습니다.

```java
package shop.infra;

import shop.common.Money;

import javax.persistence.AttributeConverter;
import javax.persistence.Converter;

@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {

    @Override
    public Integer convertToDatabaseColumn(Money money) {
        if (money == null)
            return null;
        else 
            return money.getValue();
    }

    @Override
    public Money convertToEntityAttribute(Integer value) {
        if (value == null) return null;
        else return new Money(value);
    }
}
```

AttributeConverter 인터페이스를 구현한 클래스 @Converter 에노테이션을 적용합니다. 위 코드에서 @Converter 에노테이션의 autoApply 속성값을 true로 지정했는데, 이 경우 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용합니다. 

예를 들어, Order의 totalAmounts 프로퍼티는 Money 타입인데 이 프로퍼티를 DB total_amounts 컬럼에 매핑할 때 MoneyConverter를 사용합니다.


```java
@Table(name = "purchase_order")
@Entity
public class Order {
    ...

    @Column(name = "total_amounts")
    private Money totalAmounts; // MoneyConverter를 적용해서 값 변환

    ...
}
```

@Converter의 autoApply 속성이 false인 경우 (이 속성의 기본값이 false 입니다.), 프로퍼티 값을 변환할 때 사용할 컨버터를 직접 지정할 수 있습니다.

```java
import javax.persistence.converter;

public class Order {

    @Column(name = "total_amounts")
    @Converter(converter = MoneyConverter.class)
    private Money totalAmounts;

}
```

## 밸류 컬렉션: 별도 테이블 매핑

Order 엔티티는 한 개 이상의 OrderLine을 가질 수 있습니다. OrderLine의 순서가 있다면 다음과 같이 List 타입을 이용해서 OrderLine 타입의 컬렉션을 프로퍼티로 갖게 됩니다.

```java
public class Order {

    private List<OrderLine> orderLines;
    ...
```

밸류 타입의 컬렉션은 별도 테이블에 보관합니다. 밸류 컬렉션을 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용합니다. 관련 매핑 코드는 아래와 같습니다.

```java
import javax.persistence;

@Table(name = "purchase_order")
@Entity
public class Order {

    ...
    @ElementCollection
    @CollectionTable(name = "order_line",
                    joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
    ...
}

@Embeddable
public class OrderLine {

    @Embedded
    private ProduceId produceId;

    @Column(name = "price")
    private Money price;

    @Column(name = "quantity")
    private int quantity;

    
    @Column(name = "amounts")
    private Money amounts;

    ...
}
```

OrderLine의 매핑을 함께 표시했는데 OrderLine에는 List의 인덱스 값을 저장하기 위한 프로퍼티가 존재하지 않습니다. 그 이유는 List 타입 자체가 인덱스를 갖고 있기 때문입니다. JPA는 @OrderColumn 에노테이션을 이용해서 지정한 칼럼에 리스트의 인덱스 값을 지정합니다

@CollectionTable은 밸류를 저장할 테이블을 지정할 때 사용합니다. name 속성으로 테이블 이름을 지정하고 joinColumns 속성은 외부키로 사용하는 컬럼을 지정합니다. 
예제에서는 외부키가 한 개인데, 두 개 이상인 경우 @JoinColumn의 배열을 이용해서 외부키 목록을 지정합니다.
