# 이벤트

## 시스템 간 강결합의 문제

쇼핑몰에서 구매를 취소하면 환불을 처리해야 합니다. 이때 환불 기능을 실행하는 주체는 주문 도메인 엔티티가 될 수 있습니다. 도메인 객체에 환불 기능을 실행하려면 다음 코드처럼 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행하게 됩니다.

```java
public class Order {


    public void cancel(RefundService refundService) {

        verifyNotShipped();
        this.state = OrderState.CANCELED;

        this.refundStatus = State.REFUND_STARTED;
        try {
            refundService.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch(Exception ex) {
            ...
        }
    }
}
```

응용 서비스에서 환불 기능을 실행할 수도 있습니다.

```java
public class CancelOrderService {

    private RefundService refundService;

    @Transactional
    public void cancel(OrderNo orderNo) {
        Order order = findOrder(orderNo);
        order.cancel();

        order.refundStarted();
        try {
            refundService.refund(order.getPaymentId());
        } catch(Exception ex) {
            ???
        }
    }
}
```

보통 결제 시스템은 외부에 존재하므로 RefundService는 외부의 환불 시스템 서비스를 호출하는데, 이 때 두가지 문제가 발생합니다. 첫 번째 문제는 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매하다는 것입니다. 환불 기능을 실행하는 과정에서 익셉션이 발생하면 트랜잭션을 롤백해야 할까요?

외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는게 맞는 것으로 보입니다. 하지만, 반드시 트랜잭션을 롤백해야 하는 것은 아닙니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수도 있습니다.

두 번째 문제는 성능에 대한 것입니다. 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간이 발생합니다. 환불 처리 기능이 30초가 걸리면 주문 취소 기능은 30초만큼 대기 시간이 증가합니다. 즉, 외부 서비스 성능에 직접적인 영향을 받는 문제가 있습니다.

```java
// 외부 서비스 성능에 직접 영향을 받습니다.
refundService.refund(order.getPaymentId());
```
두 가지 문제 외에 도메인 객체에 서비스를 전달하면 추가로 설계상 문제가 나타날 수 있습니다. 우선 아래 코드를 보면 주문 로직과 결제 로직이 섞이는 문제가 있습니다.

```java
public class Order {


    public void cancel(RefundService refundService) {
        // 주문 로직
        verifyNotShipped();
        this.state = OrderState.CANCELED;

        // 결제 로직
        this.refundStatus = State.REFUND_STARTED;
        try {
            refundService.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch(Exception ex) {
            ...
        }
    }
}
```

Order는 주문을 표현하는 도메인 객체인데 결제 도메인의 환불 관련 로직이 뒤섞이게 됩니다. 이는 환불 기능이 바뀌면 Order도 영향을 받게 된다는 것을 의미합니다. 주문 도메인 객체의 코드를 결제 도메인 때문에 변경할지도 모르는 상황은 좋아 보이지 않습니다.

도메인 객체에 서비스를 전달할 때 또 다른 문제는 기능을 추가할 때 발생합니다. 만약 주문을 취소한 뒤에 환불뿐만 아니라 취소했다는 내용을 통지해야 한다면 어떻게 될까요? 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 구현하면서 앞서 언급한 로직이 뒤섞이는 문제가 더 커지고 트랜잭션 처리가 더 복잡해집니다. 게다가 영향을 주는 외부 서비스가 두 개나 증가했습니다.

```java
public class Order {
    // 기능을 추가할 때마다 파라미터가 함께 추가되면
    // 다른 로직이 더많이 섞이고, 트랜잭션 처리가 더 복잡해집니다.
    public void cancel(RefundService refundService, NotiService notiSvc) {
            // 주문 로직
            verifyNotShipped();
            this.state = OrderState.CANCELED;

            // 주문 + 결제 + 통지 + 로직이 섞임
            // refundService는 성공하고, notiSvc는 실패하면?
            // refundService와 notiSvc 중 무엇을 먼저 처리하나?
    }
}
```

지금까지 언급한 문제가 발생하는 이유는 주문 BOUNDED CONTEXT와 결제 BOUNDED CONTEXT간의 강결합 때문입니다. 주문이 결제와 강하게 결합되어 있어서 주문 BOUNDED CONTEXT  결제 BOUNDED CONTEXT에 영향을 받게 되는 것입니다.

이런 강한 결합을 없앨 수 있는 방법이 있는데 그것은 바로 이벤트를 사용하는 것입니다. 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있습니다. 한번 익숙해지면 모든 연동을 이벤트와 비동기로 처리하고 싶을 정도로 강력하고 매력적인 것이 이벤트입니다. 지금부터 이벤트에 대해서 살펴보겠습니다.

## 이벤트 개요

이 섹션에서 사용하는 이벤트(event)라는 용어는 `과거에 벌어진 어떤 것`을 뜻합니다. 예를 들어, 사용자가 암호를 변경한 것을 `암호를 변경했음 이벤트`라고 부를 수 있습니다.
비슷하게 주문을 취소했다면 `주문을 취소했음 이벤트`가 발생했다고 할 수 있습니다.

웹 브라우저에서 자바 스크립트 코드를 작성한 개발자라면 이미 이벤트에 익숙할 것입니다. UI 개발에서 모든 UI 컴포넌트는 관련 이벤트를 발생시킵니다. 예를 들어, 버튼을 클릭하면 `버튼 클릭 이벤트`가 발생하고, 스크롤을 하면 `스크롤됨 이벤트`가 발생합니다.

이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미합니다. `암호 변경됨 이벤트`가 발생한 이유는 회원의 암호를 변경했기 때문이고, `주문 취소됨 이벤트`가 발생한 이유는 주문이 취소 상태로 바뀌었기 때문입니다.

이벤트가 발생하는 것에서 끝나지 않습니다. 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현합니다. 다음 자바스크립트는 jQuery를 이용해서 작성한 코드입니다. 이 코드에서 click()에 전달한 함수는 `myBn` 버튼에서 `클릭됨 이벤트`가 발생하면 그 이벤트에 반응하여 경고 창을 출력합니다.

```javascript
$('#myBn').clcik(function (evt) {
    alert("경고!");
});
```
도메인 모델에서도 UI 컴포넌트와 유사하게 도메인의 상태 변경을 이벤트로 표현할 수 있습니다. 보통 `~할 때`, `~가 발생하면`, `만약~하면`과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있습니다. 예를 들어, `주문을 취소할 때 이메일을 보낸다` 라는 요구사항에서 주문을 취소할 때는 주문이 취소 상태로 바뀌는 것을 의미하므로 `주문 취소됨 이벤트`를 활용해서 구현할 수 있습니다.

## 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 아래 그림과 같은 네 개의 구성요소를 구현해야 합니다.

![image](https://user-images.githubusercontent.com/22395934/102713521-3acb4280-430c-11eb-910c-b72dcf8c9414.png)

도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체입니다. 이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생합니다.

이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 반응합니다. 이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달 받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행합니다. 예를 들어, `주문 취소됨 이벤트`를 받는 이벤트 핸들러는 해당 주문의 주문자에게 SNS로 주문 취소 사실을 통지할 수 있습니다.

이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처 입니다. 이벤트 생성 주체는 이벤트를 생성해서 디스패치에 이벤트를 전달합니다. 이벤트를 전달받는 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전달합니다. 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 됩니다.

## 이벤트의 구성

이벤트는 발생한 이벤트에 대한 정보를 담습니다. 이 정보는 다음을 포함합니다.

- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

배송지를 변경할 때 발생하는 이벤트를 생각해봅시다. 이 이벤트를 위한 클래스는 다음과 같이 작성할 수 있습니다.

```java
public class ShippingInfoChangedEvent {

    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;

    // 생성자, getter
}
```

클래스 이름을 보면  `chnaged`라는 과거 시제를 사용했습니다. 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트 이름에는 과거 시제를 사용합니다.

이 이벤트를 발생하는 주체는 Order 애그리거트 입니다. Order 애그리거트의 배송지 변경 기능을 구현한 메서드는 다음 코드처럼 배송지 정보를 변경 한 뒤에 이벤트 디스패처를 사용해서 이 이벤트를 발생시킬 것입니다. 이 코드에서 Events.raise()는 디스패처를 통해 이벤트를 전파하는 기능을 제공합니다. 이 기능의 구현과 관련된 내용은 뒤에서 살펴보겠습니다.

```java
public class Order {

    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }
    ...
}
```

ShippingInfoChangedEvent를 처리하는 핸들러는 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행합니다. 예를 들어, 변경된 배송지 정보를 물류 서비스에 재전송하는 핸들러는 다음과 같이 구현할 수 있습니다.

```java
public class ShippingInfoChangedHandler implements EventHandler<ShippingInfoChangedEvent> {

    @Override
    public void handle(ShippingInfoChangedEvent evt) {
        shippingInfoSynchronizer.sync(
            evt.getOrderNumber(),
            evt.getNewShippingInfo());
    }
}
```

이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 최소한의 데이터를 담아야 합니다. 이 데이터가 부족할 경우 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 합니다. 예를 들어, ShippingInfoChangedEvent가 바뀐 배송지 정보를 포함하고 있지 않다고 가정해봅시다. 이 핸들러가 같은 VM에서 동작하고 있다면 다음과 같이 주문 데이터를 로딩해서 배송지 정보를 추출해야 합니다.


```java
public class ShippingInfoChangedHandler implements EventHandler<ShippingInfoChangedEvent> {

    @Override
    public void handle(ShippingInfoChangedEvent evt) {
        // 이벤트가 필요한 데이터를 담고 있지 않으면,
        // 이벤트 핸들러는 리포지터리, 조회 API, 직접 DB 접근 ㅡㅇ의
        // 방식을 통해 필요한 데이터를 조회해야 합니다.
        Order order = orderRepository.finfById(evt.getOrderNo());
        shippingInfoSynchronizer.sync(
            order.getNumber().getValue(),
            order.getShippingInfo());
    }
}
```

이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없습니다. 배송지 정보를 변경해서 발생시킨 ShippingInfoChangedEvent가 이벤트 발생과 직접 관련된 바뀐 배송지 정보를 포함하는 것은 맞지만 배송지 정보 변경과 전혀 관련 없는 주문 상품 번호와 개수를 담을 필요는 없습니다.

