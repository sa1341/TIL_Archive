# 성능과 최적화

## 1. JVM 구현체 종류

오라클이 제작한 핫스팟 이외에도 제각기 다른 방법으루 구현한 자바 구현체가 많습니다.

- OpenJDK: 자바 기준 구현체를 제공하는 특별한 오픈소스 프로젝트입니다. 오라클이 직접 프로젝트를 주관/지원하며 자바 릴리즈 기준을 발표합니다.

- 줄루(Zulu): 줄루는 아줄 시스템이 제작한 자바 풀 인증을 받은 무료 OpenJDK 구현체 입니다. 상용 라이선스 문제로 제약받을 일 없이 자유롭게 재배포 할 수 있습니다. 

- 징(Zing): 징은 아줄 시스템이 제작한 고성능 상용 JVM 입니다. 자바 풀 인증을 받았고 64비트 리눅스에서만 작동합니다. 대용량 힙 메모리와 멀티 CPU 서버급 시스템을 위해 설계된 제품입니다.

## 2. JVM 라이선스

JVM 구현체는 거의 다 오픈 소스이고 IBM J9와 상용 제품인 아줄 징을 제외하면 대부분 핫스팟(GPL 라이선스)에서 비롯된 제품입니다.

그런데 오라클 자바(JAVA 9 이후) 라이선스 체계는 좀 복잡합니다. 오라클 자바의 기반은 OpenJDK 코드 베이스지만 오픈소스가 아닌 상용 제품입니다. 그래서 오라클은 모든 OpenJDK 컨트리뷰터들이 OpenJDK의 GPL 라이선스와 오라클 상용 라이선스, 이중 라이선스에 동의한다는 서명을 받아냈습니다.

지금까지 오라클 자바의 업데이트 버전은 각각 OpenJDK 주 브랜치에서 가져왔지만, 차기 릴리즈부터는 주 브랜치에는 패치하지 않겠다고 합니다. 그러면 오카르 JDK와 OpenJDK의 격차가 점점 더 벌어지는 현상을 막을 수 있고, 소스가 동일한 오라클 JDK와 OpenJDK의 바이너리 간의 유의미한 차이점도 사라집니다.

핀트는 오라클 JDK와 OpenJDK는 라이선스 외에는 아무런 차이가 없다는 것입니다. 

## 3. 성능 테스트 패턴 및 안티 패턴

### 3.1 성능 테스트 유형

성능 테스트를 나쁜 의도로, 부실하게 수행하는 경우가 많습니다. 원인은 다양하지만 대개 성능 분석의 본질을 이해하지 못하기 때문입니다. 

가장 흔히 저지르는 실수는 구체적인 내용을 정하지 않고 뭉뚱그려 `성능 테스트`를 운운하는 겁니다. 

시스템 상에서 수행 가능한 대규모 성능 테스트는 그 종류가 많습니다. 

- 지연 테스트(Latency test): 종단 트랜잭션에 걸리는 시간은?

- 처리율 테스트(Throughput test): 현재 시스템이 처리 가능한 동시 트랜잭션 개수는?

- 부하 테스트(Load test): 특정 부하를 시스템이 감당할 수 있는가?

- 스트레스 테스트(Stress test): 이 시스템의 한계점은 어디까지 인가?

- 내구성 테스트(Endurance test): 시스템을 장시간 실행할 경우 성능 이상 증상이 나타나는가?

- 용량 계획 테스트(Capacity planning test): 리소스를 추가한 만큼 시스템이 확장되는가?

- 저하 테스트(Degradation): 시스템이 부분적으로 실패할 경우 어떤 일이 벌어지는가?

위에서 소개한 테스트 유형들에 대해서 간략하게 정리해봤씁니다. 이제 구체적으로 각각의 테스트 유형들을 살펴보겠습니다.

#### 3.1.1 지연테스트

지연 테스트는 가장 일반적인 성능 테스트 입니다. `고객이 트랜잭션(또는 페이지 로딩)을 얼마나 오래 참고 기다려야 하는지` 측정한 시스템 수치는 경영진들이 피부로 느끼는 관심사입니다.

그런데 지연 테스트는 사실상 양날의 검입니다. 이 테스트를 통해 답변하려는 질문이 너무 정량적이고 명확한 나머지 다른 종류의 성능 테스트로 밝히려는 정량적 질문을 식별할 필요성마저 흐릿하게 만들 수 있습니다.

#### 3.1.2 처리율 테스트

처리율 테스트는 그 다음으로 일반적인 성능 테스트일 겁니다. 어떤 측면에서 처리율은 지연과 동등한 개념이라고 볼 수 있습니다.

이를 테면, 지연 테스트를 수행할 때에는 계속 진행중인 동시 트랜잭션을 반드시 명시해야 합니다.

마찬가지로, 처리율 역시 지연을 모니터링하면서 테스트 합니다. 지연 분포가 갑자기 변하는 시점, 즉 사실상 한계점이 바로 `최대 처리율`입니다. 스트레스 테스트의 목표는 이런 현상이 발생하는 지점과 그 시점의 부하 수준을 포착하는 것입니다. 

반면, 처리율 테스트는 시스템 성능이 급락하기 직전, 최대 처리율 수치를 측정하는 것이 목표입니다.

#### 3.1.3 부하 테스트

부하 테스트는 처리율 테스트와는 조금 다릅니다. `시스템이 이 정도 부하는 견딜 수 있을까 없을까?` 하는 예/아니오 질문에 답을 구하는 과정입니다.

보통 애플리케이션 트래픽이 상당할 것으로 예상되는 특정 비즈니스 이벤트에 대비하기 위해 부하 테스트를 수행합니다.

#### 3.1.4 스트레스 테스트

스트레스 테스트는 시스템 여럭이 어느 정도인지 알아보는 수단입니다. 보통 일정한 수준의 트랜잭션, 즉 특정 처리율(현재로서 최대치)을 시스템에 계속 걸어놓습니다. 시간이 갈수록 서서히 동시 트랜잭션이 증가하고 시스템 성능이 저하됩니다. 측정값이 나빠지기 시작하기 직전의 값이 바로 최대 처리율입니다.

#### 3.1.5 내구 테스트

메모리 누수, 캐시 오염, 메모리 단편화 등 한참 시간이 지나고 나서야 드러나는 문제점도 있습니다. 
대개 이런 종류의 문제는 내구 테스트로 감지합니다.

평균 사용률로 시스템에 일정 부하를 계속 주며 모니터링하다가 갑자기 리소스가 고갈되거나 시스템이 깨지는 지점을 찾습니다.

내구 테스트는 빠른 응답을 요구하는(지연이 낮은) 시스템에서 많이 사용합니다. 풀 GC 사이클이 일으키는 STW 시간조차 허영되지 않습니다.

#### 3.1.6 용량 계획 테스트

용량 계획 테스트는 스트레스 테스트와 여러모로 비슷하지만, 분명이 구분되는 차이점이 있습니다. 스트레스 테스트는 현재 시스템이 어느정도 부하를 버틸수 있는지 알아보는 반면, 용량 계획 테스트는 `업그레이드한 시스템이 어느정도 부하를 감당할 수 있을지 미리 내다보는 것입니다.`

따라서 어떤 이벤트나 위협 요소에 대응하는 것이 아니라, 예정된 계획의 일부분으로 실행하는 경우가 많습니다.

#### 3.1.7 저하 테스트

저하 테스트는 부분 실패 테스트라고도 합니다. 보통 은행이나 재무법인처럼 업무 체계가 잘 잡혀있고 정규화된 환경에서는 대부분 페일오버 및 복원 테스트를 아주 꼼꼼하게 기획하며, 매우 엄격한 기준 하에 수행합니다.

저하 테스트는 기본적으로 평상시 운영 환경과 동등한 수준의 부하를 시스템에 가하는 도중, 어떤 컴포넌트나 전체 서브 시스템이 갑자기 능력을 상실하는 시점에 벌어지는 일들을 확인합니다. 예를 들어, 애플리케이션 서버 클러스터에서 순간적으로 멤버가 사라지거나, DB 서버에서 RAID 디스크가 빠져버리든지, 네트워크 대역폭이 갑자기 줄어드는 경우를 떠올려볼 수 있습니다.

저하 테스트 도중 눈여겨 봐야 할 측정값은 트랜잭션 지연 분포와 처리율입니다.

부분 실패 테스트 중에는 `카오스 멍키`라는 하위 유형이 있습니다.
넷플릭스에서 자사 인프라의 견고함을 검증하려고 수행한 프로젝트명에서 유래됐습니다.

카오스 멍키의 요지는 진짜 복원성 있는 아키텍처에서는 어느 한 컴포넌트가 잘못돼도 다른 컴포넌트까지 연쇄적으로 무너뜨리면서 전체 시스템에  부정적 영향을 끼치는 일은 없어야 한다는 것입니다.

실제로 운영환경에 떠 있는 라이브 프로세스를 하나씩 랜덤하게 킬하면서 검증합니다.

카오스 멍키형 시스템을 잘 구축하려면 조직 차원에서 시스템 위생, 시스템 설계, 운영 탁월성을 최고 수준으로 확보해야 합니다.

> RAID(Redundant Array of Independent Disk)란 2개 이상의 디스크를 병렬로 처리하여 성능 및 안정성을 향상시키는 방식을 말합니다. 핀트는 한 개의 디스크에 데이터를 저장하는 방식이 아닌, 데이터 저장의 성능 및 안정성 확보를 위해 복수의 디스크를 구성하는 방식을 레이드(RAID)라 합니다.

### 4. 기본 베스트 프랙티스

성능 튜닝 시 주안점을 두어야 할 부분은 아래와 같이 세 가지 기본 원칙에 따라 결정합니다.

- 나의 관심사가 무엇인지 식별하고 그 측정방법을 고민합니다.

- 최적화하기 용이한 부분이 아니라 중요한 부분을 최적화합니다.

- 중요한 관심사를 먼저 다룹니다.

두번째 원칙을 반대로 바꿔보면, 쉽게 측정 가능한 양에 큰 의미를 부여하는 실수를 저지르지 말라는 뜻입니다. 

모든 측정값이 다 비즈니스에 중요한 건 아닙니다.

## 5. 핫스팟의 가비지 수집

자바는 C/C++ 계열의 환경과 달리 OS를 이용해 동적으로 메모리를 관리하고 있지 않습니다. 대신, 일단 프로세스가 시작되면 JVM은 메모리를 할당하고
고 유저 공간에서 연속된 단일 메모리 풀을 관리합니다.

이 메모리 풀은 각각의 목적에 따라 다른 영역으로 구성되며, 객체는 보통 에덴 영역에 생성됩니다. 

수집기가 줄곧 객체를 이동시키기 때문에 객체가 차지한 주소는 대부분이 시간이 흐르면 아주 빈번하게 바뀝니다. 

### 5.1 스레드 로컬 할당

JVM은 성능을 강화하여 에덴을 관리합니다. 에덴은 대부분의 객체가 탄생하는 장소이고 단명한 객체는 다른 곳에는 위치할 수 없으므로 특별한 관리를 잘해야 합니다.

JVM은 에덴을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 합니다.

이렇게 하면 각 스레드는 혹여 다른 스레드가 자신의 버퍼에 객체를 할당하지 않을까 염려할 필요가 없어집니다.

이 구역을 `스레드 로컬 할당 버퍼(TLAB)`라고 합니다.

애플리케이션 스레드가 자신의 `TLAB`를 배타적으로 제어한다는 건 JVM 스레드의 할당 복잡도가 O(1)이라는 것을 뜻합니다. 스레드가 객체를 생성할 때 이 객체에 저장 공간이 할당되고 스레드-로컬 포인트는 그 다음 비어 있는 메모리 주소를 가르키도록 업데이트 하기 때문입니다. 

> 참고문헌: (Optimizing Java)자바 최적화


