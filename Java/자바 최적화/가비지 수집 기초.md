# 가비지 수집 기초

가비지 수집(GC)는 자바 환경을 상징하는 여러 특성 가운데서도 단연 돋보이지만, 자바 플랫폼이 처음 출시됐을 때 GC는 상당한 반감을 샀습니다. 언어 수준에서 의도적으로 수집기 작동을 제어하지 못하게 만들었다는 사실(최신 버전도 변함은 없습니다)이 알려지면서 여론은 나빴습니다.

하지만 이게 역설적으로 자바 플랫폼의 인지도를 높였습니다.

왜냐하면 요즘은 메모리는 손으로 직접 관리해야 한다는 의견에 동조하는 개발자가 많이 없습니다. 요즘 각광받는 고, 러스트에서도 메모리 관리는 프로그래머가 아닌, 컴파일러나 런타임의 영역이라고  보는 시각이 지배적입니다.

모든 가비지 수집 구현체는 다음 두 가지 기본 원칙을 준수해야 합니다.

- 알고리즘은 반드시 모든 가비지를 수집해야 합니다.

- 살아 있는 객체는 절대로 수집해선 안 됩니다.

이 중에서 두 번째 규칙이 가장 중요합니다. 살아 있는 객체를 수집했다간 세그멘테이션 결함이 발생하거나 프로그램이 조용히 더럽혀집니다. 프로그래머가 저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 바로 자바 관리 방식의 핵심입니다.

## 6.1 마크 앤 스위프

자바에서 가비지 수집은 대부분 마크 앤 스위프 알고리즘이 기초라는 정도만 알고 있습니다. 실제로 프로세스가 어떻게 동작하는지는 몰라서 한번 살펴봤습니다.

전체적인 GC 알고리즘은 아래와 같이 동작합니다.

1. 할당 리스트를 순회하면서 마크 비트를 지웁니다.
2. GC 루트부터 살아 있는 객체를 찾습니다.
3. 이렇게 찾은 객체마다 마크 비트를 세팅합니다.
4. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾습니다.
    
    a. 힙에서 메모리를 회수해 프리 리스트에 되돌립니다.
    
    b. 할당 리스트에서 객체를 삭제합니다.


## 6.2 가비지 수집 용어

GC 알고리즘을 설명하는 기본 용어를 살펴보겠습니다.

STW: GC 사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 스레드가 중단됩니다. 따라서 애플리케이션 코드는 GC 스레드가 바라보는 힙 상태를 무효화할 수 없습니다. 단순 GC 알고리즘에서는 대부분 이럴 때 STW가 일어납니다.


병렬: 여러 스레드를 동원해서 가비지 수집을 합니다.

정확: 정확한 GC 스킴은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있습니다. 

보수: 보수적인 스킴은 정확한 스킴의 정보가 없습니다. 그래서 리소스를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 훨씬 비효율적입니다.

이동: 이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있습니다. 즉, 객체 주소가 고정된게 아닙니다. 
