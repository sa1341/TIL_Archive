# 객체지향 프로그래밍

## 객체지향 프로그래밍을 향해
객체지향은 객체를 지향하는 것입니다. 객체를 지향한다는 말이 무슨 의미일까요? C++, 자바, 루비, C#과 같이 클래스 기반의 객체지향 언어에 익숙한 사람이라면 가장 먼저 어떤 클래스가 필요한지 고민부터 합니다. 대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 어떤 메서드가 필요한지 고민합니다.

안타깝게도 이것은 객체지향의 본질과는 거리가 멉니다. 객체지향은 말 그대로 객체를 지향하는 것입니다.진정한 객체지향의 패러다임으로의 전환은 클래스가 아니라 `객체`에 초점을 맞출 때에만 얻을 수 있습니다. 이를 위해서는 프로그래밍하는 동안 다음의 두 가지에 집중해야 합니다.

첫째, 어떤 클래스들이 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야 합니다. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한것입니다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야합니다. 객체를 중심에 두는 접근 방식은 설계를 단순하고 깔끔하게 만듭니다.

둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 합니다. 객체는 홀로 존재하는 것이 아닙니다. 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재입니다. 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만듭니다. 객체 지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라보기 바랍니다. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현합니다. 훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳습니다.


## 도메인 구조를 따르는 프로그램의 구조
이 시점에서 도메인(domain)이라는 용어를 살펴보는것이 도움이 될 것입니다. 소프트웨어는 사용자가 원하는 어떠한 문제를 해결하기 위해 만들어졌습니다. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것입니다. 이 처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부릅니다.

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문입니다. 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있습니다.


#### 영화 예매 도메인을 구성하는 타입들의 구조
![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71569583-7d03de80-2b13-11ea-9893-7c1b7dc1cf28.png)

위의 그림은 영화 예매 도메인을 구성하는 개념과 관계를 표현한 것입니다. 영화는 여러 번 상영될 수 있고 상영은 여러번 예매될 수 있다는 것을 알 수 있습니다. 영화에는 할인 정책을 할당하지 않거나 할당하더라도 오직 하나만 할당할 수 있고 할인 정책이 존재하는 경우에는 하나 이상의 할인 조건이 반드시 존재한다는 것을 알 수 있습니다.
할인 정책의 종류로는 금액 할인 정책과 비율 할인 정책이 있고, 할인 조건의 종류로는 순번 조건과 기간 조건이 있다는 사실 역시 확인할 수 있습니다.

자바나 C#과 같은 클래스 기반의 객체지향 언어에 익숙하다면 도메인 개념들을 구현하기 위해 클래스를 사용한다는 사실이 낮설지는 않을 것입니다. 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 합니다. 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 합니다.

이 원칙에 따라 영화라는  개념은 Movie 클래스로, 상영이라는 개념은 Screening 클래스로 구현합니다. 할인 정책은 DiscountPolicy, 금액 할인 정책은 AmountDiscountPolicy, 비율 할인 정책은 percentDiscountPolicy 클래스로 구현하고, 할인 조건은 DiscountCondition, 순번 조건은 SequenceCondition, 기간 조건은 PeriodCondition 클래스로 구현합니다. 예매라는 개념은 Reservation이라고 이름 지어진 클래스로 구현합니다. 도메인 개념과 관계를 반영하도록 프로그램을 구조화해야 하기 때문에 아래 그림과 같이 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 합니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71569834-14b5fc80-2b15-11ea-882d-461573157359.png)


## 클래스 구현하기
도메인 개념들의 구조를 반영하는 적절한 클래스 구조를 만들었다고 가정합시다. 이제 남은 일은 적절한 프로그래밍 언어를 이용해 이 구조를 구현하는 것입니다. 여기서는 설명을 위해 설계 과정을 생략하고 최종 코드의 모습과 객체지향 프로그래밍과 관련된 중요한 개념을 살펴보기로 합시다.

Screening 클래스는 사용자들이 예매하는 대상인 `상영`을 구현합니다. Screening은 상영할 영화(movie), 순번(sequence),상영 시작 시간(whenScreened)을 인스턴스 변수로 포함합니다. Screening은 상영 시작 시간을 반환하는 getStartTime 메서드, 순번의 일치 여부를 검사하는 isSequence 메서드, 기본 요금을 반환하는 getMovieFee 메서드를 포함합니다.

```java
import java.time.LocalDateTime;

public class Screening {

    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public LocalDateTime getStartTime(){
        return whenScreened;
    }

    public boolean isSequence(int sequence){
        return  this.sequence == sequence;
    }

    public Money getMovieFee(){
        return movie.getFee();
    }
}
```

여기서 주목할 점은 인스턴스 변수의 가시성은 private이고 메서드의 가시성은 public 입니다. 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것입니다. 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것입니다. Screening에서 알 수 있는 것처럼 외부에서는 객체의 속성에 직접 접근할수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야합니다.

클래스의 내부와 외부를 구분하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문입니다. 그리고 더 중요한 이유로 프로그래머에게 구현의 자유를 제공하기 때문입니다.



## 자율적인 객체
먼저 두가지 중요한 사실을 알아야 합니다. 첫 번째 사실은 객체가 상태와 행동을 함께 가지는 복합적인 존재라는 것입니다. 두 번째 사실은 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것입니다. 두 가지 사실은 서로 깊이 연관돼 있습니다.

객체지향 이전의 패러다임에서는 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성했습니다. 이와 달리 객체지향은 객체라는 단위 안에 데이터 와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 합니다. 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부릅니다.

또한 캡슐화하는 것에서 한 걸음 더 나아가 외부에서 접근을 통제할 수 있는 접근 제어 메커니즘도 함께 제공합니다. 많은 프로그래밍 언어들은 `접근 제어(access control)`를 위해 public, private, protected과 같은 `접근 수정자(access modifier)`를 제공합니다.

객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서 입니다. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것입니다. 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화 해야합니다. 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안되며, 결정에 직접적으로 개입하려고 해서도 안됩니다. 객체에게 원하는 것을 요청하고 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 합니다.

캡슐화와 접근제 제어는 객체를 두 부분으로 나눕니다. 하나는 외부에서 접근 가능한 부분으로 이를 `퍼블릭 인터페이스(public interface)`라고 부르고, 다른 하나는 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 `구현(implementation)`이라고 부릅니다. 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙입니다.

일반적으로 객체의 상태를 숨기고 행동만 외부에 공개해야 합니다. 어떤 메서드들이 서브 클래스나 내부에서만 접근 가능해야 한다면 가시성을 protected나 private으로 지정해야 합니다. 이때 퍼블릭 인터페이스에는 public으로 지정된 메서드만 포함합니다. 그 밖의 private 메서드나 protected 메서드, 속성은 구현에 포함됩니다.


## 프로그래머의 자유
프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분하는 것이 유용합니다. 클래스 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용합니다. 

클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것입니다. 클래스 작성자는 프롣그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 합니다. 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있습니다. 이를 `구현 은닉(implementation hiding)`이라고 부릅니다.

구현 은닉은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념입니다. 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있습니다. 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경 할 수 있습니다. 다시 말해 public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다는 것입니다.

객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고, 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어집니다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 합니다.


## 협력하는 객체들의 공동체
이제 영화를 예매하는 기능을 구현하는 메서드를 살펴보겠습니다. Screening의 reserve 메서드는 영화를 예매한 후 예매 정보를 담고 있는 Reservation의 인스턴스를 생성해서 반환합니다. 인자인 customer는 예메자에 대한 정보를 담고 있고 audienceCount는 인원수 입니다.

```java
public class Screening{
    public Reservation reserve(Customer customer, int audienceCount){
        return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
    }
}
```
Screening의 reserve 메서드를 보면 calculateFee라는 private 메서드를 호출해서 요금을 계산한 후 그 결과를 Reservation의 생성자에 전달하는 것을 알 수 있습니다. calculateFee 메서드는 요금을 계산하기 위해 다시 Movie의 calculateMovieFee 메서드를 호출합니다. Movie의 calculateMovieFee 메서드의 반환 값은 1인당 예매 요금입니다. 따라서 Screening은 전체 예매 요금을 구하기 위해 calculateMovieFee 메서드의 반환 값에 인원 수인 audienceCount를 곱합니다.

```java
public class Screening{
  private Money calculateFee(int audienceCount){
        return movie.calculateMovieFee(this).times(audienceCount);
    }
}
```

Money는 금액과 관련된 다양한 계산을 구현하는 클래스 입니다.

```java
import java.math.BigDecimal;

public class Money {

    public static final Money ZERO = Money.wons(0);

    private final BigDecimal amount;

    public static Money wons(long amount){
        return new Money(BigDecimal.valueOf(amount));
    }

    public static Money wons(double amount){
        return new Money(BigDecimal.valueOf(amount));
    }

    Money(BigDecimal amount){
        this.amount = amount;
    }

    public Money plus(Money amount){
        return new Money(this.amount.add(amount.amount));
    }

    public Money minus(Money amount){
        return new Money(this.amount.subtract(amount.amount));
    }

    public Money times(double percent){
        return new Money(this.amount.multiply(
                BigDecimal.valueOf(percent)
        ));
    }

    public boolean isLessThan(Money other){
        return amount.compareTo(other.amount) < 0;
    }


    public boolean isGreaterThanOrEqual(Money other){
        return amount.compareTo(other.amount) >= 0;
    }
    
}
```

이전 시간에 공부했던 티켓발권 시스템을 공부했을때 금액을 구현하기 위해서 Long 타입을 사용했었습니다. Long 타입은 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표현할 수 있지만 Money 타입처럼 저장하는 값이 금액과 관련돼 있다는 의미를 전달 할 수는 없습니다. 또한 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없습니다. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것입니다. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현해야 합니다. 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음 입니다.

Reservation 클래스는 고객, 상영정보, 예매 요금, 인원 수를 속성으로 포함합니다.

```java
public class Reservation {

    private Customer customer;
    private Screening screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.screening = screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
```

영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하며 상호작용합니다. 이처럼 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 `협력(Collaboration)`이라고 부릅니다.

#### Screenihng, Reservation, Movie 사이의 협력
![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/71573450-48018700-2b27-11ea-85f3-853cff611f04.png)


객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성합니다. 따라서 협력에 대한 개념을 간략하게라도 살펴보는 것이 도움이 됩니다.


## 협력에 관한 짧은 이야기
객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청을 할 수 있습니다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답합니다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐입니다. 다른 객체에게 요청이 도착할 때 해당 객체가 메시지 수신했다고 이야기 합니다. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정합니다. 이 처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 `메서드`라고 부릅니다.

메시지와 메서드를 구분하는 것은 매우 중요합니다. 객체지향 패러다임이 유연하고 확장 가능하며, 재사용 가능한 설계를 낳는다는 명성을 얻게 된 배경에는 메시지와 메서드를 명확하게 구분한 것도 단단히 한몫합니다. 
 
위에서 Screening이 Movie의 calculateMovieFee `메서드를 호출한다`고 말했지만 사실은 Screening이 Movie에게 calculateMovieFee `메시지를 전송한다`고 말하는 것이 더 적절한 표현입니다. 사실 Screening은 Movie안에 calculateMovieFee 메서드가 존재하고 있는지조차 알지 못합니다. 단지 Movie가 calculateMovieFee 메시지에 응답할수 있다고 믿고 메시지를 전송할 뿐입니다.

메시지를 수신한 Movie는 스스로 적절한 메서드를 선택합니다. 사실 예제에서 사용한 자바 같은 정적 타입 언어에는 해당되지 않지만 루비나 스몰토크 같은 동적 타입 언어에서는 calculateMovieFee가 아닌 다른 시그니처를 가진 메서드를 통햏서도 해당 메시지에 응답할 수 있습니다. 결국 메시지를 처리하는 방법을 결정하는 것은 Movie 스스로의 문제인 것입니다.


## 할인 요금 구하기
### 할인 요금 계산을 위한 협력 시작하기
Movie는 제목(title), 상영시간(Duration), 기본요금(fee), 할인 정책(discountPolicy)을 속성으로 가집니다. 이 속성들의 값은 생성자를 통해서 전달받습니다.

```java
import java.time.Duration;

public class Movie {
    private String title;
    private Duration runningTime; 
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Money getFee(){
        return fee;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

calculateMovieFee 메서드는 discountPolicy에 calculateDiscountAmount 메시지를 전송해 할인 요금을 반환 받습니다. Movie는 기본 요금인 fee에서 반환된 할인 요금을 차감합니다.

이 메서드 안에는 한 가지 이상한 점이 있습니다. 어떤 할인 정책을 사용할 것인지 결정하는 코드가 어디에도 존재하지 않는다는 것입니다. 도메인을 설명할 때 언급했던 것처럼 영화 예매 시스템에는 두 가지 종류의 할인 정책이 존재합니다. 하나는 일정한 금액을 할인해 주는 금액 할인 정책이고 다른 하나는 일정한 비율에 따라 할인 요금을 결정하는 비율 할인 정책입니다. 따라서 예매 요금을 게산하기 위해서는 현재 영화에 적용되 있는 할인 정책의 종류를 판단할 수 있어야 합니다. 하지만 코드 어디에도 할인 정책을 판단하는 코드는 존재하지 않습니다. 단지 discountPolicy에게 메시지를 전송할 뿐입니다.

이 코드가 어색하다면 아직 객체지향 패러다임에 익숙하지 않는 것이라고 봐도 무방하다는군요.... 이 코드에는 객체지향에서 중요하다고 여겨지는 두가지 개념이 숨겨져 있습니다. 하나는 상속이고 다른 하나는 다형성입니다. 그리고 그 기반에는 추상화라는 원리가 숨겨져 있습니다. 먼저 코드의 개념부터 살펴보겠습니다.

## 할인 정책과 할인 조건
할인 정책은 금액 할인 정책과 비율 할인 정책으로 구분됩니다. 두 가지 할인 정책을 각각 AmountDiscountPolicy와 PercentDiscountPolicy라는 클래스로 구현할 것입니다. 두 클래스는 대부분의 코드가 유사하고 할인 요금을 계산하는 방식만 조금 다릅니다. 따라서 두 클래스 사이의 중복 코드를 제거하기 위해 공통의 코드를 보관할 장소가 필요합니다.

여기서 부모 클래스인 DiscoutPolicy 안에 중복 코드를 두고 AmountDiscoutPolicy와 PercentDiscountPolicy가 이 클래스를 상속받게 할 것입니다. 실제 애플리케이션에서는 DiscountPolicy의 인스턴스를 생성할 필요가 없기 때문에 추상화 클래스로 구현했습니다.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public abstract class DiscountPolicy {

    private List<DiscountCondition> conditions = new ArrayList<>();
    
    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }
    
    public Money calculateDiscountAmount(Screening screening){
        for (DiscountCondition each : conditions){
            if(each.isSatisfiedBy(screening)){
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

DiscountPolciy는 DiscountCondition의 리스트인 conditions를 인스턴스 변수로 가지기 때문에 하나의 할인 정책은 여러 개의 할인 조건을 포함할 수 있습니다. calculateDiscountAmount 메서드는 전체 할인 정책에 대해 차례대로 DiscountCondition의 isSatisfiedBy 메서드를 호출합니다. isSatisfiedBy 메서드는 인자로 전달된 Screening이 할인 조건을 만족시킬 경우에는 true를, 만족시키지 못할 경우에는 false를 반환합니다.

할인 조건을 만족하는 DiscountCondition이 하나라도 존재하는 경우에는 추상 메서드인  getDiscountAmount 메서드를 호출하여 할인 요금을 계산합니다. 만족하는 할인 조건이 하나도 존재하지 않는다면 Screening의 getMovieFee 메서드를 호출해 원래의 영화 가격을 반환합니다. 

DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임합니다. 실제로 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행될 것입니다. 이처럼 부모 클래스에 기본적인 알고리즘을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 `TEMPLATE METHOD 패턴`이라고 부릅니다.

DiscountCondition은 자바의 인터페이스를 이용해 선언돼 있습니다. isSatisfiedBy 오퍼레이션은 인자로 전달된 Screening이 할인이 가능한 경우 true를 반환하고 할인이 불가능한 경우에는 false를 반환합니다.

```java
public interface DiscountCondition{
    boolean isSatisfiedBy(Screening screening);
}
```

영화 예매 시스템에는 순번 조건과 기간 조건의 두 가지 할인 조건이 존재합니다. 두 가지 할인 조건은 각각 SequenceCondition과 PeriodCondition이라는 클래스로 구현할 것입니다.

SequenceCondtion은 할인 여부를 판단하기 위해 사용할 순번(sequence)을 인스턴스 변수로 포함합니다. isSatisfiedBy 메서드는 파라미터로 전달된 Screening의 상영 순번과 일치할 경우 할인 가능한 것으로 판단해서 true를, 그렇지 않는 경우에는 false를 반환합니다.

```java
public class SequenceCondition implements DiscountCondition {

    private int sequence;

    public SequenceCondition(int sequence) {
        this.sequence = sequence;
    }

    @Override
    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}
```

PeriodCondition은 상영 시작 시간이 특정한 기간 안에 포함되는지 여부를 판단해 할인 여부를 결정합니다. 조건에 사용할 요일(dayOfWeek)과 시작 시간(startTime), 종료 시간(endTime)을 인스턴스 변수로 포함합니다. isSatisfiedBy 메서드는 인자로 전달된 Screening의 상영 요일이 dayOfWeek과 같고 상영 시작 시간이 startTime과 endTime 사이에 있을 경우에는 true를 반환하고 그렇지 않은 경우에는 false를 반환합니다.

```java
import java.time.DayOfWeek;
import java.time.LocalTime;

public class PeriodCondition implements DiscountCondition {

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    @Override
    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

이제 할인 정책을 구현해봅시다. AmountDiscountPolicy는 DiscountPolicy로 자식 클래스로서 할인 조건을 만족할 경우 일정한 금액을 할인해주는 금액 할인 정책을 구현합니다. 이 클래스는 DiscountPolicy의 getDiscountAmount 메서드를 오버라이딩 합니다. 할인 요금은 이스턴스 변수인 discountAmount에 저장합니다.

```java
public class AmountDiscoutPolicy extends DiscountPolicy {

    private Money discountAmount;

    public AmountDiscoutPolicy(Money discountAmount, DiscountCondition... conditions) {
        super(conditions);
        this.discountAmount = discountAmount;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}
```

PercentDiscountPolicy 역시 DiscountPolicy의 자식 클래스로서 getDiscountAmount 메서드를 오버라이딩 합니다. AmountDiscountPolicy와 다른 점이라면 고정 금액이 아닌 일정 비율을 차감한다는 것입니다. 할인 비율은 인스턴스 변수인 percent에 저장합니다.

```java
public class PercentDiscountPolicy extends DiscountPolicy {

    private double percent;

    public PercentDiscountPolicy(double percent, DiscountCondition... conditions) {
        super(conditions);
        this.percent = percent;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getMovieFee().times(percent);
    }
}
```
#### 할인 정책과 할인 조건 다이어그램
![Untitled Diagram](https://user-images.githubusercontent.com/22395934/71586739-90886700-2b5e-11ea-881e-30d4bb759e28.png)

## 할인 정책 구성하기
하나의 영화에 대해 단 하나의 할인 정책만 설정할 수 있지만 할인 조건의 경우에는 여러 개를 적용할 수 있습니다. Movie와 DiscountPolicy의 생성자는 이런 제약을 강제합니다. Movie의 생성자는 오직 하나의 DiscountPolicy 인스턴스만을 받을 수 있도록 선언돼 있습니다.

```java
   public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        ...
        this.discountPolicy = discountPolicy;
    }
```
반면 DiscountPolicy의 생성자는 여러 개의 DiscoutCondition 인스턴스를 허용합니다.

```java
 public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }
```

이처럼 생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체 생성을 보장할 수 있습니다. 아래 코드는 `아바타`에 대한 할인 정책과 할인 조건을 설정한 것입니다. 할인 정책으로 금액 할인 정책이 적용되고, 두 개의 순서 조건과 두개의 기간조건을 이용해 할인 여부를 판단한다는 것을 알 수 있습니다.

```java
Movie avatar = new Movie("아바타", 
    Duration.ofMinute(120),
    Money.wons(10000),
    new AmountDiscountPolicy(Money.wons(800),
    new SequenceCondition(1),
    new SequenceCondition(10),
    new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10,0), LoclaTime.of(11,59)),
    new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10,0), LoclaTime.of(20,59))));
```

또한 `타이타닉`에 대한 할인 정책은 다음과 같이 설정할 수 있습니다. 10%의 비율 할인 정책이 적용되고 두개의 기간 조건과 한 개의 순서 조건을 이용해 할인 여부를 판단한다는 것을 알 수 있습니다.


