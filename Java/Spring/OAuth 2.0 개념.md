# OAuth 2.0 이란?

OAuth 2.0은 `외부 서비스(third-party-application)`의 인증 및 권한부여를 관리하는 범용 프레임워크 입니다. OAuth 기반 API를 호출을 할 때에는, HTTP 헤더에 access token을 포함하여 요청을 보내게 됩니다. 서비스는 access token을 검사하면서 이 요청이 유효한지 판단하여 적절한 결과를 응답합니다.

사용자 입장에선 OAuth의 권한 요청 절차는 access token을 획득하는 것이 가장 주요한 목적이라고 할 수 있습니다. 반대로 서비스 제공자 입장에선 인증딘 사용자에게 access token을 발급하는것이 가장 중요한 일이라고 할 수 있습니다.


# OAuth를 구성하고 있는 주요 4가지 객체

아래 용어는 OAuth 2.0 프레임워크에 대해서 이해하기 위해서 필요한 용어들을 정리하였습니다.

- resource owner(자원 소유자)는 protected resource(보호된 자원)에 접근하는 권한을 제공 합니다.

- resource server(자원 서버)는 access token을 사용해서 요청을 수신할 때, 권한을 검증한 후 적절한 결과를 응답합니다.

- 클라이언트는 resource owner(자원 소유자)의 protected resource(보호된 자원)에 접근을 요청을 하는 애플리케이션 입니다.

- authorization Server(권한 서버)는 client(클라이언트)가 성공적으로 access token을 발급받은 이후에 resource owner(자원 소유자)를 인증하고 obtaining authorization(권한 부여)를 합니다.


처음에 저도 리소스 서버랑 리소스 오너는 무엇을 의미하고.. 클라이언트는 대체 무엇을 의미하는지 몰라서 여러 자료를 찾아보았는데요. 리소스(resource)는 자원이라는 뜻으로 고객이나 사용자의 정보라고 생각하는게 편합니다. 구글이나 페이스북 트위터와 같은 글로벌 공룡들이 운영하는 서비스들은 대부분의 사람들이 하나 정도의 계정을 가지고 있습니다. 당연히 해당 서비스에는 사용자의 정보가 존재합니다. 그래서 구글, 페이스북, 트위터 같이 많은 사용자들의 정보를 가지고 있는 서버들을 리소스 서버라고 부릅니다. 그리고 리소스 서버에서 저장하고 있는 정보의 주인은 사용자이기 때문에 리소스 오너라고 부르게 됩니다.
그럼 클라이언트는 무엇일까요? 그건 바로 저희가 운영하는 웹/앱 어플리케이션과 같은 `외부 서비스(third-party-application)`를 의미 합니다.


### OAuth 2.0 프레임워크 흐름
![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/70778169-fa65ea00-1dc4-11ea-8860-c3d396faebfd.png)


위의 OAuth 2.0이 동작하는 메커니즘에 대해서 제가 한번 그려보았습니다.
OAuth 2.0을 프레임워크를 실제로 어떻게 동작하는지에 대한 예를 살펴보겠습니다. 저는 모두의 커뮤니티라는 이름의 웹 서버를 운영하고 있습니다. 즉, 클라이언트는 모두의 커뮤니티를 의미합니다. 이 모두의 커뮤니티라는 서버는 구글에서 제공하고 있는 캘린더 서비스 중에서도 사용자들이 저장한 캘린더 목록에 대한 정보를 제공해주는 API를 사용하고 싶습니다.

이 API를 사용하기 위해서는 사전에 구글 클라우드 플랫폼에서 프로젝트를 만든 후에 해당 서비스를 이용하기 위해 클라이언트를 등록을 해야합니다. 이건 나중에 자세히 설명하겠습니다. 그리고 나면 등록에 대한 자격으로 구글이 `client id, client secret` 코드라는 것을 제공하게 되는데 이건 클라이언트를 구분하는 식별자라고 생각하시면 됩니다. 중요한것은 client secret 코드는 절대로 외부에 노출되어서는 안되는 중요한 정보라는 사실입니다. 

이제 등록을 했으니 본격적으로 구글 캘린더 서비스 중에서 캘린더 목록에 대한 정보를 가지고 있는 사용자의 정보를 어떻게 저희 모두의 커뮤니티 웹 서버에서 보여주는지에 대한 구체적인 흐름을 설명하겠습니다.

1. 리소스 오너(사용자)가 클라이언트(모두의 커뮤니티)에 접속을 하게 됩니다. 

2. 리소스 오너(사용자)는 캘린더 목록에 대한 정보를 요청하게 되면 클라이언트는 리소스 오너에게 권한을 요청하게 됩니다. 이때 권한 요청은 리소스 오너에게 직접 하거나, 리소스 서버를 통해 간접적으로 이루어 질 수도 있습니다.

> 클라이언트가 리소스 오너에게 보내는 권한요청은 리소스 서버(구글)에게 내가 당신의 캘린더 목록에 대한 정보를 가져오는 서비스를 사용할 수 있도록 허락을 받아달라고 요청하는 행위를 의미합니다. 극단적으로 표현하자면 허락해달라고 때를 쓴다고 표현할 수도 있겠네요.

3. 인증이 성공하게 된다면 이에 대한 대가로? 리소스 서버(구글)은 클라이언트(모두의 커뮤니티)에게 `Authorizaion Code(권한 코드)`라는 것을 부여하게 됩니다. 이 권한 코드는 실제 리소스 서버(구글)의 서비스(캘린더 목록 정보)를 호출할 수 있는 access token을 발급받기 위해 필요한 필수적인 정보입니다.

4. 이제 발급받은 권한코드와 함께 사전에 구글 클라우드 플랫폼에서 등록 후 받은 client id, client secret 코드를 리소스 서버에 전송하여 access token을 발급받게 됩니다. 이때 access token을 발급받기 위한 클라이언트의 redirect Url을 명시해줘야 하지만 우리의 스프링 시큐리티에서는 이미 경로를 구현해놨기 때문에 따로 컨트롤러를 통해서 access token을 받을 경로를 구현할 필요가 없습니다.

5. access token을 받은 클라이언트(모두의 커뮤니티)는 리소스 서버(구글)에 자원(캘린더 목록 정보)를 요청할 수 있게 됩니다.

6. 요청을 받은 리소스 서버(구글)은 access token의 유효성을 검증하고 유효하다면 요청을 처리해줍니다.


위의 과정이 전반적인 OAuth 2.0 동작 메커니즘에 대한 정말 간단한 설명입니다. 사실 리소스 오너가 리소스 서버로부터 인증을 성공하게 된다면 Authorizaion Gran(권한 증서)라는 리소스 오너가 자원에 접근할 수 있는 권한을 부여하였다는 확인증을 발급받는데 이 권한 증서는 총 4개의 타입이 있지만 제가 위에서 설명한 예는 그 중에서 Authorization Code 타입에 대해서 설명하였습니다. 

권한 코드 타입은 보안상의 이점이 있습니다. access token을 곧 바로 클라이언트에게 전달하지 않기 때문에 전달과정에서 생길 수 있는 잠재적인 유출 위험을 방지하는데 도움을 줍니다.


> 스코프(scope)란 클라이언트에게 허용된 리소스의 범위를 지정합니다. 만약 리소스 오너가 클라이언트를 통해서 리소스 서버로부터 인증을 하게 되고 전체 서비스를 사용할 수 있게 된다면 aceess token을 외부에 탈취당했을 때 리소스 오너에 대한 정보를 전체 털릴 수 있는 심각한 손실을 야기합니다.

# Access Token와 Refrsh Token

Access Token은 요청 절차를 정상적으로 종료한 클라이언트에게 발급됩니다. 이 토큰은 보호된 자원에 접근할 때 권한 확인용으로 사용됩니다. 문자열 형태이며 클라이언트에 발급된 권한을 대표하게 됩니다. 계정 아이디와 비밀번호 등 계정 인증에 필요한 형태들을 이 토큰 하나로 표현함으로써, 리소스 서버는 여러 가지 인증 방식에 각각 대응 하지 않아도 권한을 확인 할 수 있게 됩니다.

Refresh Token은 한번 발급받은 access token은 사용할 수 있는 시간이 제한되어 있습니다. 사용하고 있던 access token이 유효기간 종료 등으로 만료되면, 새로운 액세스 토큰을 얻어야 하는데 그때 이 refresh token 이 활용됩니다. 권한 서버가 access token을 발급해주는 시점에 refresh token도 함께 발급하여 클라이언트에게 알려주기 때문에, 전용 발급 절차 없이 refresh token을 미리 가지고 있을 수 있습니다. 토큰의 형태는 access token과 동일하게 문자열 형태입니다. 단 권한 서버에서만 활용되며 리소스 서버에는 전송되지 않습니다.



오늘은 간단하게 OAuth 2.0 프레임워크에 대한 개념과 용어에 대해서 살펴보았고, OAuth 2.0 동작 메터니즘을 이미지로 표현하였습니다. 또한 모두의 커뮤니티라는 third-party-application을 통해서 OAuth 2.0 사용 예시를 들어서 조금이라도 OAuth 2.0에 다가갈수 있었던 것 같습니다.

다음에는 실제 OAuth 2.0을 스프링 부트 시큐리티 프레임워크와 함께 연동하여서 어떻게 소셜 로그인을 통해서 인증을 하게 되고 사용자의 정보를 가져오는지 살펴보겠습니다.


##### 참고: 생활코딩(https://opentutorials.org/course/2473/16571),http://blog.weirdx.io/post/39955
