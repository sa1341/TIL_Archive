# 카프카(Kafka)란?

`카프카(Kafka)`는 Apach 재단의 pub-sub 모델의 메시징 시스템 입니다. ActiveMQ, Artmeis, RabbitMQ와 유사한 메시지 브로커입니다. 그러나 카프카(Kafka)는 특유의 아키텍처를 가지고 있습니다.

카프카(Kafka)는 높은 확장성을 제공하는 클러스터로 실행되도록 설계되어 있습니다. 또한 `fail-over`, `replication`와 같은 여러가지 특징들을 가지고 있습니다. 

## 1. Pub - Sub 모델

카프카(Kafka)는 `pub-sub(발행/구독)` 모델을 사용합니다. pub-sub는 메시지를 특정 수신자에게 직접적으로 보내주는 시스템이 아닙니다. publisher는 메시지를 topic을 통해서 카테고리화 합니다. 분류된 메시지를 받기ㄹ



## 2. 토픽(Topic)

카프카(Kafka)는 데이터를 최종적으로 토픽(Topic)이라는 곳에 저장을 하며 데이터를 구분하기 위한 분류값 혹은 구분된 저장소라 이해하면 됩니다. 

카프카는 데이터를 주고 받을 때 지정된 토픽으로 주고 받게 되며, 설계를 어떻게 할 것인지가 관건입니다.


## 3. 파티션(Partition)

메시지가 토픽(Topic)으로 분류되고, 토픽(Topic)은 여러개의 파티션으로 나눠질 수 있습니다. 파티션내의 한 칸은 로그라고 불립니다. 데이터는 한 칸의 로그에 순차적으로 append 됩니다. 메시지의 상대적인 위치를 나타내는게 offset인데, 배열에서 index 개념이라고 생각하면 쉽게 이해됩니다.

토픽(Topic)에 여러개의 파티션을 두는 경우에는 몇 천건의 메시지가 동시에 카프카(Kafka)에 쓰여진다고 생각해보면 하나의 파티션만 둘 경우 순차적으로 append가 발생하게 되는데, 그렇게 되면 카프카 입장에서는 처리하기가 무겁습니다. 그렇기 때문에 여러개의 파티션을 두어서 분산저장을 하는 것입니다. 

그만큼 시간이 절약된다는게 핀트입니다. 하지만 이것도 트레이드오프(trade-off)로 한 번 늘린 파티션은 절대로 줄일 수 없기 때문에 운영 중에, 파티션을 늘려야하는건 항상 고려해야할 사항입니다.

> 파티션에 메시지가 `Round-robin` 방식으로 쓰여집니다. 즉 순차적으로 메시지가 쓰여지지 않습니다. 만약 해당 토픽을 소비하는 소비자가 만약 메시지의 순서가 엄청 중요한 모델이라면 순차적으로 소비됨을 보장해주지 않기 때문에 상당히 리스크가 커집니다.


## 4. Producer

Producer는 메시지를 생산하는 주체입니다. 메시지를 만들고 Topic에 메시지를 씁니다. Producer는 Consumer의 존재를 알지 못합니다. 단지 카프카(Kafka)에 메시지를 쓰는 주체라고 생각하면 됩니다.


## 5. Consumer

Consumer는 소비자로써 메시지를 소비하는 주체입니다. 역시 Producer의 존재를 모릅니다. 해당 토픽(Topic)를 구독함으로써, 자기가 스스로 조절해가면서 소비할 수 있는 것입니다. 

소비를 했다는 표시는 해당 토픽(Topic)내의 각 파티션에 존재하는 offset의 위치를 통해서 이전에 소비했던 offset위치를 기억하고 관리하고 이를 통해서, 혹시나 Consumer가 죽었다가 다시 살아나도, 이전에 마지막으로 읽었던 위치에서부터 다시 읽어들일 수 있습니다. 그렇기 대문에 `fail-over`에 대한 신뢰가 존재합니다.
