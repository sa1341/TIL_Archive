# 카프카(Kafka)란?

`카프카(Kafka)`는 Apach 재단의 pub-sub 모델의 메시징 시스템 입니다. ActiveMQ, Artmeis, RabbitMQ와 유사한 메시지 브로커입니다. 그러나 카프카(Kafka)는 특유의 아키텍처를 가지고 있습니다.

카프카(Kafka)는 높은 확장성을 제공하는 클러스터로 실행되도록 설계되어 있습니다. 또한 `fail-over`, `replication`와 같은 여러가지 특징들을 가지고 있습니다. 

## 1. Pub - Sub 모델

카프카(Kafka)는 `pub-sub(발행/구독)` 모델을 사용합니다. pub-sub는 메시지를 특정 수신자에게 직접적으로 보내주는 시스템이 아닙니다. publisher는 메시지를 topic을 통해서 카테고리화 합니다. 


## 2. 토픽(Topic)

카프카(Kafka)는 데이터를 최종적으로 토픽(Topic)이라는 곳에 저장을 하며 데이터를 구분하기 위한 분류값 혹은 구분된 저장소라 이해하면 됩니다. 

카프카는 데이터를 주고 받을 때 지정된 토픽으로 주고 받게 되며, 설계를 어떻게 할 것인지가 관건입니다.


## 3. 파티션(Partition)

메시지가 토픽(Topic)으로 분류되고, 토픽(Topic)은 여러개의 파티션으로 나눠질 수 있습니다. 파티션내의 한 칸은 로그라고 불립니다. 데이터는 한 칸의 로그에 순차적으로 append 됩니다. 메시지의 상대적인 위치를 나타내는게 offset인데, 배열에서 index 개념이라고 생각하면 쉽게 이해됩니다.

토픽(Topic)에 여러개의 파티션을 두는 경우에는 몇 천건의 메시지가 동시에 카프카(Kafka)에 쓰여진다고 생각해보면 하나의 파티션만 둘 경우 순차적으로 append가 발생하게 되는데, 그렇게 되면 카프카 입장에서는 처리하기가 무겁습니다. 그렇기 때문에 여러개의 파티션을 두어서 분산저장을 하는 것입니다. 

그만큼 시간이 절약된다는게 핀트입니다. 하지만 이것도 트레이드오프(trade-off)로 한 번 늘린 파티션은 절대로 줄일 수 없기 때문에 운영 중에, 파티션을 늘려야하는건 항상 고려해야할 사항입니다.

> 파티션에 메시지가 `Round-robin` 방식으로 쓰여집니다. 즉 순차적으로 메시지가 쓰여지지 않습니다. 만약 해당 토픽을 소비하는 소비자가 만약 메시지의 순서가 엄청 중요한 모델이라면 순차적으로 소비됨을 보장해주지 않기 때문에 상당히 리스크가 커집니다.


## 4. Producer

Producer는 메시지를 생산하는 주체입니다. 메시지를 만들고 Topic에 메시지를 씁니다. Producer는 Consumer의 존재를 알지 못합니다. 단지 카프카(Kafka)에 메시지를 쓰는 주체라고 생각하면 됩니다.


## 5. Consumer

Consumer는 소비자로써 메시지를 소비하는 주체입니다. 역시 Producer의 존재를 모릅니다. 해당 토픽(Topic)를 구독함으로써, 자기가 스스로 조절해가면서 소비할 수 있는 것입니다. 

소비를 했다는 표시는 해당 토픽(Topic)내의 각 파티션에 존재하는 offset의 위치를 통해서 이전에 소비했던 offset위치를 기억하고 관리하고 이를 통해서, 혹시나 Consumer가 죽었다가 다시 살아나도, 이전에 마지막으로 읽었던 위치에서부터 다시 읽어들일 수 있습니다. 그렇기 대문에 `fail-over`에 대한 신뢰가 존재합니다.

## 6. Consumer Group

Producer에서 생산한 메시지는 여러개의 파티션에 저장을 하는데, 그렇다면 소비하는 쪽에서도 여러 소비자가 메시지를 읽어가는 것이 훨씬 효율적일 것입니다. 하나의 목표를 위해 소비를 하는 그룹, 즉 하나의 토픽을 읽어가기 위한 Consumer들을 Consumer Group라고 합니다.

Consumer Group가 필요한 또 한가지 이유는 데이터를 병렬로 읽게 되어 빠른처리가 가능하다는 부분도 있겠지만, 특정 컨슈머에 문제가 생겼을 경우 다른 그룹내 컨슈머가 대신 읽을 수 있게 리벨런싱이 되어 장애 상황에서도 문제없이 대처할 수 있게 됩니다.

> Consumer Group은 한가지 룰이 있습니다. Topic과 Consumer Group는 `1:N`의 관계를 가집니다. 즉, 자신이 읽고 있는 파티션에는 같은 그룹내 다른 컨슈머가 읽을 수 없습니다. 
보통 파티션 개수와 컨슈머 그룹내 컨슈머 수를 맞추는것을 추천하기도 합니다. 


## 7. 주키퍼란?

주키버는 분산 어플리케이션을 위한 코디네이션 시스템 입니다. 

분산되어있는 각 애플리케이션의 정보를 중앙에 집중하고 구성 관리, 그룹 관리 네이밍, 동기화 등을 제공합니다.

상태 정보를 지노트(znode)라 불리는 곳에 key-value 형태로 저장합니다. 이 지노드에 저장된 key-value를 이용하여 분산 어플리케이션은 서로 데이터를 주고 받습니다.

지노드(znode)는 일반 컴퓨터의 파일이나 폴더 개념으로 생각하면 이해하기 쉽습니다.


## 8. 카프카 클러스터 구조

![image](https://user-images.githubusercontent.com/22395934/128202447-7b35e28a-27d3-4461-a111-b0dd4ee5dba7.png)

#### 참조 블로그: https://team-platform.tistory.com/11

## 9. 세그먼트

프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장됩니다. 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장됩니다. 

각 파티션마다 N개의 세그먼트 로그 파일들이 존재합니다. 
브로커 서버에 접속하면 `토픽-파티션번호` 형식의 디렉토리가 생성되어 있고 해당 디렉토리에서 로그 파일을 열어서 프로듀서가 보낸 메시지 확인이 가능합니다.
