![스크린샷 2019-10-30 오후 11 32 53](https://user-images.githubusercontent.com/22395934/67867506-db412f00-fb6d-11e9-99b7-b049e2d64f29.png)


```java
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HashMaraton {


    public String solution(String[] participant, String[] completion) {

        Arrays.sort(participant);
        Arrays.sort(completion);


        int i = 0;
        for (i = 0; i < completion.length; i++) {
            if(!participant[i].equals(completion[i])){
               return participant[i];
            }
        }

        return participant[i];
    }


    public static void main(String[] args) {

        HashMaraton maraton = new HashMaraton();

        String[] participant = {"leo", "kiki", "kiki", "eden"};
        String[] completion = {"eden", "kiki"};

        System.out.println(maraton.solution(participant, completion));


    }
}
```

 이 문제는 해시를 이용하여 푸는 문제입니다. 위의 코드는 해시를 사용하지 않고 정렬 후 단순히 participant와 completion 배열의 값을 비교하여
 completion에 없는 참가자를 리턴하면 됩니다.
 
 하지만 문제의 의도는 해시로 완주하지 못한 참가자의 이름을 리턴하라고 나왔기 때문에 아래코드와 같이 해시 맵을 이용해서 문제를 풀어보았습니다.
 
 
 
 
 
