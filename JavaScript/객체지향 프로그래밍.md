## 객체지향 프로그래밍
자바스크립트는 여러 가지 특성으로 객체지향 언어의 특징을 구현해낼 수 있습니다. 초창기 더글라스 크락포드가 소개한 상속과 캡슐화 등으로 자바스크립트가 객체지향 프로그래밍이 가능함이 알려졌고, 그 후 많은 개발자가 자바스크립트로 객체지향적인 구현 방법을 고민하기 시작했습니다. 이번 장에서는 다음에 나오는 객체지향 언어의 특성을 자바스크립트로 구현하는 방법을 살펴보겠습니다.

- 클래스, 생성자, 메서드
- 상속
- 캡슐화

먼저 이번 장을 읽기 전에 객체지향 언어로서 클래스 기반의 언어와 프로토타입 기반의 언어를 간단하게나마 구분해서 알아야 할 필요가 있습니다. 클래스 기반의 언어는 클래스로 객체의 기본적인 형태와 기능을 정의하고, 생성자로 인스턴스를 만들어서 사용할 수 있습니다. 클래스에 정의된 메서드로 여러가지 기능을 수행할 수 있습니다. 우리에게 널리 알려진 Java, C++과 같은 언어가 이에 해당합니다. 이런 유형의 언어는 모든 인스턴스가 클래스에 정의된 대로 같은 구조이고 보통 런타임에 바꿀 수 없습니다. 반면에 프로토타입 기반의 언어는 객체의 자료구조, 메서드 등을 동적으로 바꿀수 있습니다. 이는 마치 정적 타입의 언어와 동적 타입의 언어의 차이와 거의 비슷하게 보입니다. 마찬가지로 장단점도 명확합니다. 정확성, 안전성, 에측성 등의 관점에서 클래스 기반 언어는 프로토타입 기반의 언어보다 좀 더 나은 결과를 보장합니다. 하지만 프로토타입 기반의 언어는 동적으로 자유롭게 객체의 구조와 동작 방식을 바꿀 수 있다는 장점이 있습니다. 자바스크립트는 프로토타입 기반의 언어입니다. 따라서 이번 장을 이해하려면 저번 포스팅을 했던 프로토타입을 잘 이해해야 합니다.

프로토타입은 자바스크립트로 객체지향적으로 구현하는 필수 요소이므로 확실히 이해하는게 좋습니다.

## 클래스, 생성자, 메서드
C++이나 Java와 같은 경우 class라는 키워드를 제공하여 프로그래머는 클래스를 만들 수 있습니다. 클래스와 같은 이름의 메서드로 생성자를 구현해냅니다. 하지만 자바스크립트에서는 이러한 개념이 없습니다. 게속해서 강조했듯이 자바스크립트는 거의 모든것이 객체이고, 특히 함수 객체로 많은 것을 구현해냅니다. 클래스, 생성자, 메서드 모두 함수로 구현이 가능합니다. 구체적으로 살펴보기에 다시한번 자바스크립트의 프로토타입과 new 연산자를 살펴보겠습니다.

```java
function Person(arg) {

    this.name = arg;

    this.getName = function() {
        return this.name;
    }

    this.setName = function(value) {
        this.name = value;
    }
}

var me = new Person("zzoon");
console.log(me.getName()); // 출력값: zzoon

me.setName("junyoung");
console.log(me.getName()); // 출력값: junyoung
```

위 예제에서 new 키워드로 새로운 객체 me를 만들었음을 주목합시다.

```javascript
var me = new Person("zzoon");
```

이 형태는 기존 객체지향 프로그래밍 언어에서 한 클래스의 인스턴스를 생성하는 코드와 매우 유사합니다. 함수 Person이 클래스이자 생성자의 역할을 합니다. 자바스크릡트에서 클래스 기반의 객체지향 프로그래밍은 기본적인 형태가 이와 같습니다. 클래스 및 생성자의 역할을 하는 함수가 있고, 사용자는 new 키워드로 인스턴스를 생성하여 사용할 수 있습니다. 예제에서 생성된 me는 Person의 인스턴스로서 name 변수가 있고, getName()과 setName() 함수가 있습니다.

하지만 이 예제는 문제가 많습니다. 정확히는 이 예제의 Person 함수의 구현이 바람직하지 못합니다. 이 Person을 생성자로 하여 여러 개의 객체를 생성한다고 가정해보겠습니다.

```javascript
var me = new Person("me");
var you = new Person("you");
var him = new Person("him");
```

이와 같이 객체를 생성하여 사용하면 겉으로는 별 문제 없이 작동하는 것을 볼 수 있습니다. 하지만 각 객체는 자기 영역에서 공통으로 사용할 수 있는 setName() 함수와 getName() 함수를 따로 생성하고 있습니다. 이는 불필요하게 중보고디는 영역을 메모리에 올리고 사용함을 의미하고 자원 낭비를 가져옵니다. 이를 그림으로 표현하면 아래와 같습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/76162204-9e6df000-617e-11ea-883a-6ca4671166c8.png)


따라서 앞의 문제를 해결하려면 다른 방식의 접근이 필요한데, 여기서 활용할수 있는 자바스크립트의 특성이 함수 객체의 프로토타입입니다. 다음 코드를 살펴보겠습니다.

```javascript
function Person(arg){
    this.name = arg;
}

Person.prototype.getName = function() {
    return this.name;
}

Person.prototype.setName = function(value) {
    this.name = value;
}

var me = new Person("me");
var you = new Person("you");
console.log(me.getName());  // 출력값: me
console.log(you.getName()); // 출력값: junyounyoug
```

위 예제 코드에서는 Person 함수 객체의 prototype 프로퍼티에 getName()과 setNmae() 함수를 정의하였습니다. 이 Person으로 객체를 생성한다면 각 객체는 각자 따로 함수 객체를 생성할 필요없이 getName()과 setNmae() 함수를 프로토타입 체인으로 접근할 수 있습니다. 이를 그림으로 표현하면 다음과 같습니다.


![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/76162495-a8ddb900-6181-11ea-898e-ccc156f3f213.png)

이와 같이 자바스크립트에서 클래스 안의 메서드를 정의할 때는 프로토타입 객체에 정의한 후, new로 생성한 객체에서 접근할 수 있게 하는 것이 좋습니다. 더글라스 크락포드는 다음과 같은 함수를 제시하면서 메서드를 정의하는 방법을 소개합니다.

```javascript
Function.prototype.method = function(name, func) {
    if(!this.prototype[name]) {
        this.prototype[name] = func;
    }
}
```

이 함수를 활용하면 예제는 다음과 같은 형태가 됩니다.

```javascript
Function.prototype.method = function(name, func) {
    this.prototype[name] = func;
}

function Person(arg) {
    this.name = arg;
}

Person.method("setName", function(value)) {
    this.name = value;
}

Person.method("getName", function() {
    return this.name;
});


var me = new Person("me");
var you = new Person("you");
console.log(me.getName());  
console.log(you.getName()); 
```
