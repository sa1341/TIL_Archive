## 객체지향 프로그래밍
자바스크립트는 여러 가지 특성으로 객체지향 언어의 특징을 구현해낼 수 있습니다. 초창기 더글라스 크락포드가 소개한 상속과 캡슐화 등으로 자바스크립트가 객체지향 프로그래밍이 가능함이 알려졌고, 그 후 많은 개발자가 자바스크립트로 객체지향적인 구현 방법을 고민하기 시작했습니다. 이번 장에서는 다음에 나오는 객체지향 언어의 특성을 자바스크립트로 구현하는 방법을 살펴보겠습니다.

- 클래스, 생성자, 메서드
- 상속
- 캡슐화

먼저 이번 장을 읽기 전에 객체지향 언어로서 클래스 기반의 언어와 프로토타입 기반의 언어를 간단하게나마 구분해서 알아야 할 필요가 있습니다. 클래스 기반의 언어는 클래스로 객체의 기본적인 형태와 기능을 정의하고, 생성자로 인스턴스를 만들어서 사용할 수 있습니다. 클래스에 정의된 메서드로 여러가지 기능을 수행할 수 있습니다. 우리에게 널리 알려진 Java, C++과 같은 언어가 이에 해당합니다. 이런 유형의 언어는 모든 인스턴스가 클래스에 정의된 대로 같은 구조이고 보통 런타임에 바꿀 수 없습니다. 반면에 프로토타입 기반의 언어는 객체의 자료구조, 메서드 등을 동적으로 바꿀수 있습니다. 이는 마치 정적 타입의 언어와 동적 타입의 언어의 차이와 거의 비슷하게 보입니다. 마찬가지로 장단점도 명확합니다. 정확성, 안전성, 에측성 등의 관점에서 클래스 기반 언어는 프로토타입 기반의 언어보다 좀 더 나은 결과를 보장합니다. 하지만 프로토타입 기반의 언어는 동적으로 자유롭게 객체의 구조와 동작 방식을 바꿀 수 있다는 장점이 있습니다. 자바스크립트는 프로토타입 기반의 언어입니다. 따라서 이번 장을 이해하려면 저번 포스팅을 했던 프로토타입을 잘 이해해야 합니다.

프로토타입은 자바스크립트로 객체지향적으로 구현하는 필수 요소이므로 확실히 이해하는게 좋습니다.

## 클래스, 생성자, 메서드
C++이나 Java와 같은 경우 class라는 키워드를 제공하여 프로그래머는 클래스를 만들 수 있습니다. 클래스와 같은 이름의 메서드로 생성자를 구현해냅니다. 하지만 자바스크립트에서는 이러한 개념이 없습니다. 게속해서 강조했듯이 자바스크립트는 거의 모든것이 객체이고, 특히 함수 객체로 많은 것을 구현해냅니다. 클래스, 생성자, 메서드 모두 함수로 구현이 가능합니다. 구체적으로 살펴보기에 다시한번 자바스크립트의 프로토타입과 new 연산자를 살펴보겠습니다.

```java
function Person(arg) {

    this.name = arg;

    this.getName = function() {
        return this.name;
    }

    this.setName = function(value) {
        this.name = value;
    }
}

var me = new Person("zzoon");
console.log(me.getName()); // 출력값: zzoon

me.setName("junyoung");
console.log(me.getName()); // 출력값: junyoung
```

위 예제에서 new 키워드로 새로운 객체 me를 만들었음을 주목합시다.

```javascript
var me = new Person("zzoon");
```

이 형태는 기존 객체지향 프로그래밍 언어에서 한 클래스의 인스턴스를 생성하는 코드와 매우 유사합니다. 함수 Person이 클래스이자 생성자의 역할을 합니다. 자바스크릡트에서 클래스 기반의 객체지향 프로그래밍은 기본적인 형태가 이와 같습니다. 클래스 및 생성자의 역할을 하는 함수가 있고, 사용자는 new 키워드로 인스턴스를 생성하여 사용할 수 있습니다. 예제에서 생성된 me는 Person의 인스턴스로서 name 변수가 있고, getName()과 setName() 함수가 있습니다.

하지만 이 예제는 문제가 많습니다. 정확히는 이 예제의 Person 함수의 구현이 바람직하지 못합니다. 이 Person을 생성자로 하여 여러 개의 객체를 생성한다고 가정해보겠습니다.

```javascript
var me = new Person("me");
var you = new Person("you");
var him = new Person("him");
```

이와 같이 객체를 생성하여 사용하면 겉으로는 별 문제 없이 작동하는 것을 볼 수 있습니다. 하지만 각 객체는 자기 영역에서 공통으로 사용할 수 있는 setName() 함수와 getName() 함수를 따로 생성하고 있습니다. 이는 불필요하게 중보고디는 영역을 메모리에 올리고 사용함을 의미하고 자원 낭비를 가져옵니다. 이를 그림으로 표현하면 아래와 같습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/76162204-9e6df000-617e-11ea-883a-6ca4671166c8.png)


따라서 앞의 문제를 해결하려면 다른 방식의 접근이 필요한데, 여기서 활용할수 있는 자바스크립트의 특성이 함수 객체의 프로토타입입니다. 다음 코드를 살펴보겠습니다.

```javascript
function Person(arg){
    this.name = arg;
}

Person.prototype.getName = function() {
    return this.name;
}

Person.prototype.setName = function(value) {
    this.name = value;
}

var me = new Person("me");
var you = new Person("you");
console.log(me.getName());  // 출력값: me
console.log(you.getName()); // 출력값: junyounyoug
```

위 예제 코드에서는 Person 함수 객체의 prototype 프로퍼티에 getName()과 setNmae() 함수를 정의하였습니다. 이 Person으로 객체를 생성한다면 각 객체는 각자 따로 함수 객체를 생성할 필요없이 getName()과 setNmae() 함수를 프로토타입 체인으로 접근할 수 있습니다. 이를 그림으로 표현하면 다음과 같습니다.


![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/76162495-a8ddb900-6181-11ea-898e-ccc156f3f213.png)

이와 같이 자바스크립트에서 클래스 안의 메서드를 정의할 때는 프로토타입 객체에 정의한 후, new로 생성한 객체에서 접근할 수 있게 하는 것이 좋습니다. 더글라스 크락포드는 다음과 같은 함수를 제시하면서 메서드를 정의하는 방법을 소개합니다.

```javascript
Function.prototype.method = function(name, func) {
    if(!this.prototype[name]) {
        this.prototype[name] = func;
    }
}
```

이 함수를 활용하면 예제는 다음과 같은 형태가 됩니다.

```javascript
Function.prototype.method = function(name, func) {
    this.prototype[name] = func;
}

function Person(arg) {
    this.name = arg;
}

Person.method("setName", function(value)) {
    this.name = value;
}

Person.method("getName", function() {
    return this.name;
});


var me = new Person("me");
var you = new Person("you");
console.log(me.getName());  
console.log(you.getName()); 
```
 > 더글라스 크락포드는 함수를 생성자로 사용하여 프로그래밍하는 것을 추천하지 않습니다. 그 이유는 생성된 함수는 new로 호출될 수 있을 뿐만 아니라, 직접 호출도 가능하기 때문입니다. 여기서 문제는 new로 호출될 때와 직접 호출될 때의 this에 바인딩되는 객체가 달라진다는 것입니다. 크락포드는 이러한 문제 때문에, 일단 생성자로 사용되는 함수는 첫 글자를 대문자로 표기할 것을 권고하고 있습니다. 


## 상속
자바스크립트는 클래스를 기반으로 하는 전통적인 상속을 지원하지 않습니다. 하지만 자바스크립트 특성 중 객체 프로토타입 체인을 이용하여 상속을 구현해낼 수 있습니다. 이러한 상속 구현 방식은 크게 두 가지로 구분할 수 있는데, 하나는 클래스 기반 전통적인 상속 방식을 흉내내는 것이고, 다른 하나는 클래스 개념 없이 객체의 프로토타입으로 상속을 구현하는 방식입니다. 이를 프로토타입을 이용한 상속이라고 합니다. 자바나 C++에 익숙한 개발자는 전통적인 상속의 형태가 익숙할 것입니다. 클래스와 생성자 등의 개념이 들어가 있기 때문입니다. 하지만 프로토타입을 이용한 상속은 객체 리터럴을 중심으로 철저히 프로토타입을 이용하여 상속을 구현해낸다, 이 책에서는 프로토타입을 이용한 상속을 먼저 소개하고, 클래스 기반의 상속을 소개하겠습니다.


## 프로토타입을 이용한 상속
다음 예제를 살펴보겠습니다. 

```javascript
function create_object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
```

이 코드는 더글라스 크락포드가 자바스크립트 객체를 상속하는 방법으로 오래 전에 소개한 코드입니다. 조금 과장해서 말하면 이 세줄의 코드를 이해하면 자바스크립트에서 프로토타입 기반의 상속을 다 배운 것이나 다름없다고 합니다?... 전 아직도 모르겠습니다

이 세줄의 코드는 언뜻 보면 쉬워 보이지만 이해하기 쉬운 코드는 아닙니다.

다음 그림을 보겠습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/76220122-4ad0d480-625a-11ea-98b5-5548cf19499d.png)

create_object() 함수는 인자로 들어온 객체를 부모로 하는 자식 객체를 생성하여 반환합니다. 그림을 보면 새로운 빈 함수 객체 F를 만들고, F.prototype 프로퍼티에 인자로 들어온 객체를 참조합니다. 함수 객체 F를 생성자로 하는 새로운 객체를 만들어 반환합니다. 이렇게 반환된 객체는 부모 객체의 프로퍼티에 접근할 수 있고, 자신만의 프로퍼티를 만들수도 있습니다. 이렇게 프로토타입의 특성을 활용하여 상속을 구현하는 것이 프로토타입 기반의 상속입니다. 참고로 앞에서 소개한 Object() 함수는 ECMAScript 5에서 Object.create() 함수로 제공되므로, 따로 구현할 필요는 없습니다. 이 함수의 코드로 프로토타입 기반 상속의 이해를 돕고자 사용한 것입니다.



다음 예제는 앞에서 소개한 create_object() 함수를 이용하여 상속을 구현한 예제입니다.

```javascript
var person = {
    name: "junyoung",
    getName: function() {
        return this.name;
    },
    setName: function (arg) {
        this.name = arg;
    }
};

function create_object(o) {

    function F() {};
    F.prototype = o;
    return new F();
}


var student = create_object(person);

student.setName("junyoung");
console.log(student.getName()); // 출력값: me
```

Person 객체를 상속하여 Student 객체를 만들었습니다. 프로토타입 기반 상속의 특징이 보이나요? 클래스에 해당하는 생성자 함수를 만들지도 않았고, 그 클래스의 인스턴스를 따로 생성하지도 않았습니다. 단지 부모 객체에 해당하는 person 객체와 이 객체를 프로토타입 체인으로 참조할수 있는 자식 객체 Student를 만들어서 사용하였습니다. 이와 같은 방식으로 상속의 개념을 구현하였습니다.
그림을 표현하면 다음과 같습니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/76322233-7b7e4000-6326-11ea-9198-8c3737d6a472.png)


지금까지는 부모 객체의 메서드를 그대로 상속받아 사용하는 방법을 살펴보았습니다.
여기에서 자식은 자신의 메서드를 재정의 혹은 추가로 기능을 확장시킬수 있어야 합니다.

```javascript
student.setAge = function(age) { ... }
student.getAge = function() { .... }
```
단순히 앞과 같이 그 기능을 확장시킬 수는 있습니다. 하지만 이렇게 구현하면 코드가 지저분해지기 십상입니다. 보다 깔끔한 방법을 생각해봅시다. 자바스크립트에서는 범용적으로 extend()라는 이름의 함수로 객체에 자신이 원하는 객체 혹은 함수를 추가시킵니다. 여기서는 가장 유명한 자바스크립트 라이브러리 중 하나인 jQuery의 extend() 함수를 살펴보고 이를 활용하는 방법을 생각해봅시다. jQuery의 1.0의 extend 함수는 다음과 같이 구현되었습니다.

```javascript
jQuery.extend = jQuery.fn.extend = function(obj, prop) {
    if(!prop) { prop = obj; obj = this; }
    for(var i in prop) obj[i] = prop[i];
    return obj;
};
```

이 코드를 분석해봅시다.

```javascript
jQuery.extend = jQuery.fn.extend = ...
```

jQuery.fn은 jQuery.prototype이다. 따라서 앞 코드가 의마하는 바는 jQuery 함수 객체와 jQuery 함수 객체의 인스턴스 모두 extend 함수가 있겠다는 말입니다. 즉, jQuery.extend()로 호출할 수도 있고, var elem = new jQuery(...); elem.extend(); 형태로도 호출할 수 있음을 뜻합니다.
