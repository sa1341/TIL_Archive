# 함수와 프로토타입 체이닝

자바스크립트에서 가장 중요한 개념은 1순위는 당연히 함수입니다. 마치 C 프로그래밍을 배울 때 포인터를 얼마나 제대로 이해하느냐에 따라 고급 C 개발자로 발돋움 할 수 있듯이 자바스크립트에서 이러한 함수를 얼마나 제대로 이해하고 활용하느냐에 따라서 고급 자바스크립트 개발자로 거듭날 수 있습니다.

자바스크립트에서의 함수는 언뜻 보면 언어와 마찬가지로 기능을 제공합니다. 즉, 특정 기능을 제공하는 코드를 작성해서 함수를 정의하고, 이를 호출해서 결과값을 얻는 것처럼 말입니다. 하지만 이러한 기능 외에도 자바스크립트의 함수는 모듈화 처리나 클로저, 객체 생성 등 자바스크립트의 근간이 되는 많은 기능을 제공하고 있습니다. 

- 함수 생성
- 함수 객체
- 다양한 함수 형태
- 함수 호출 this
- 프로토타입과 프로토타입 체이닝

## 함수 정의
자바스크립트에서 함수를 생성하는 방법은 3가지가 있습니다. 이들 방식 모두 같은 함수를 생성하지만, 각각의 방식에 따라 함수 동작이 미묘하게 차이가 납니다.

- 함수 선언문
- 함수 표현식
- Function() 생성자 함수

이번 절에서는 두 개의 인자를 받아 그합을 구하는 add() 함수를 3가지 방식으로 정의해보고, 이를 통해 각 방식의 차이점을 살펴보겠습니다. 먼저 그 전에 함수 선언문과 함수 표현식에서 함수를 생성하는 함수 리터럴의 개념부터 알아보겠습니다.

## 함수 리터럴

자바스크립트에서도 함수는 일반 객체처럼 값으로 취급됩니다. 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, 자바스크립트에서는 함수 리터럴을 이용해 함수를 생성항 수 있습니다. 실제로 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성합니다. 다음 예제는 함수 리터럴로 두 개의 인자를 더하는 add() 함수를 정의한 것입니다.

```javascript
function add(x, y){
    return x + y;
}
```

함수 리터럴은 위의 코드와 같이 크게 네 부분으로 구성됩니다.

1. function 키워드: 자바스크립트 함수 리터럴은 function 키워드로 시작합니다.
2. 함수명: 함수명은 함수 몸체의 내부 코드에서 자신을 재귀적으로 호출하거나 또는 자바스크립트 디버거가 해당 함수를 구분하는 식별자로 사용합니다. 여기서 주목할 점은 함수명은 선택 사항이라는 것입니다. 이것은 기존 C나 자바에 익숙한 개발자들에겐 생소할 수도 있습니다. 자바스크립트에서 함수명이 없는 함수를 익명 함수라 합니다.
3. 매개변수 리스트 : 매개변수는 C언어와 같은 기존 언어의 함수 매개변수 형태와 거의 비슷하지만, 매개변수 타입을 기술하지 않는다는 차이가 있습니다.
4. 함수 몸체 : 실제 함수가 호출됐을 때 실행되는 코드 부분입니다.

## 함수 선언문 방식으로 함수 생성하기
함수 선언문 방식은 위에서 설명한 함수 리터럴 형태와 같습니다. 여기서 주의할 점은 함수 선언문 방식으로 정의된 함수의 경우는 반드시 함수명이 정의되어 있어야 한다는 것입니다. 일반적으로 함수 선언문 방식은 C/C++에서 사용하는 함수 정의방법과 유사하지만, function이라는 키워드를 명시적으로 사용하고 리턴값과 매개변수로 넘기는 값에 변수 타입(int, char등)을 기술하지 않는다는 점에서 차이가 있습니다.

아래 예제코드는 함수 선언문 형태로 add()함수를 구현한 코드입니다. 함수명 add가 있고, 또한 이 함수명으로 함수를 호출하고 있습니다.

```java
// 함수 선언문 방식
function(x, y){
    return x + y;
}

console.log(add(3,4)); // 출력값 : 7
```

## 함수 표현식 방식으로 함수 생성하기
자바스크립트에서는 함수도 하나의 값처럼 취급됩니다. 그래서 자바스크립트에서 함수를 일급 객체라고도 합니다. 따라서 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능합니다.

이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하는 함수를 생성하는 것을 함수 표현식이라고 말합니다.

아래 예제는 add()함수를 함수 표현식 형태로 생성한 것입니다. 함수 리터럴로 두 값을 덯하는 함수를 생성한 다음, 이를 add 변수에 저장한 것입니다. 여기서 함수 리터럴로 생성한 함수는 함수명이 없으므로 익명 함수입니다.

```java
// 함수 표현식 방식

var add = function(x, y){
    return x + y;
}

var plus = add;

console.log(add(3,4)); // 출력값 : 7
console.log(plus(5,6)); // 출력값 : 11
```

에제 코드에서 알 수 있듯이 함수 표현식은 함수 선언문 문법과 거의 유사합니다. 유일한 차이점은 함수 표현식 방법에서는 함수 이름이 선택 사항이며, 보통 사용하지 않습니다.

1. add 변수는 함수 리터럴로 생성한 함수를 참조하는 변수이지, 예제처럼 함수 이름이 아니라는 것에 주의해야합니다. add와 같이 함수가 할당된 변수를 함수 변수라고 부릅니다.

2. 함수 변수 add는 함수의 참조값을 가지므로 다른 변수 plus에도 그 값을 그대로 할당할 수가 있습니다. 

3. 함수 표현식으로 생성된 함수를 호출하려면 함수 변수를 사용해야 합니다. 

4. plus 또한 add 함수 변수와 같은 함수를 참조하는 함수 변수이므로 plus(5,6)과 같은 형태로 함수를 호출하는 것이 가능합니다.


#### add와 plus 함수 변수는 두 개의 인자를 더하는 동일한 익명 함수를 참조합니다.
![스크린샷 2020-01-14 오후 11 12 11](https://user-images.githubusercontent.com/22395934/72351250-5a80e080-3723-11ea-9d4e-3c0017a07dff.png)

위의 예제에서는 함수 변수 add가 실제로 참조하는 두 수를 더하는 함수의 이름이 없습니다. 앞서 설명했듯이 이렇게 이름이 없는 함수 형태를 자바스크립트에서는 익명 함수라고 부릅니다.
즉, 앞 예제는 인자로 넘겨진 두 수를 더하는 익명 함수를 만들고 이를 add 변수에 할당한 것입니다. 이것이 바로 익명 함수를 이용한 함수 표현식 방법입니다. 이러한 익명 함수의 호출은 앞 에제와 같이 함수 변수에 함수 호출 연산자인 ()를 붙여서 기술하는 것으로 가능합니다.

참고로 함수 이름이 포함된 함수 표현식을 기명 함수 표현식이라고 합니다. 이러한 기명 함수 표현식을 사용할 경우 주의해야 할 점이 있습니다.

```javascript
var add = function sum(xm y){
    return x + y;
}

console.log(add(3,4)); // 출력값 : 7
console.log(sum(3,4)); // 출력값 : Uncaught RefereceError: sum is not defined 에러 발생
```

sum() 함수를 정의하고, 이 함수를 add 함수 변수에 할당했습니다. 예제에서 특이한 점은 add() 함수를 호출는 결과값이 성공적으로 리턴된 반면에, sum() 함수 호출의 경우 에러가 발생한다는 것입니다. 이것은 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능 하기 때문입니다.

실제로 함수 표현식에 사용된 함수 이름은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용됩니다. 따라서 함수 이름으로 사용된 sum으로 함수 외부에서 해당 함수를 호출할 때 sum() 함수가 정의되어 있지 않다는 에러가 발생합니다.


그렇다면 함수 선언문으로 정의할 때 add() 함수는 어떻게 함수 이름으로 함수 외부에서 호출이 가능할까요? 함수 선언문 형식으로 정의된 add() 함수는 자바스크립트 엔진에 의해 다음과 같은 함수 표현식 상태로 변경되기 때문입니다.

```javascript
var add = function(x, y){
    return x + y;
}
```
함수 이름과 함수 변수 이름이 add로 같으므로, 함수 이름으로 함수가 호출되는 것처럼 보이지만 실제로  add 함수 변수로 함수 외부에서 호출이 가능하게 된 것입니다.
이를 그림으로 표현하면 다음과 같습니다.


![스크린샷 2020-01-14 오후 11 24 24](https://user-images.githubusercontent.com/22395934/72352103-04ad3800-3725-11ea-93df-401b63928a0d.png)



앞서 설명했듯이 함수 표현식에서는 함수 이름이 선택 사항이지만, 이러한 함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능합니다.

```javascript
var factorialVar = function factorial(n) {

    if (n <= 1){
        return 1;
    }
    return n * factorial(n-1);
}

console.log(factorialVar(3)); // 출력값 : 6
console.log(factorial(3)); // Uncaught ReferenceError: factorial is not defined
```

1. 함수 외부에서는 함수 변수 factorialVar로 함수를 호출하였으며, 함수 내부에서 이뤄지는 재귀 호출은 factorial() 함수 이름으로 처리한다는 것을 알 수 있습니다.

2. 앞서 설명한 것과 마찬가지로 함수명 factorial()으로 함수 외부에서 해당 함수를 호출하지 못해 에러가 발생합니다.

## Funtion() 생성자 함수를 통한 함수 생성하기
이 정의 뒷부분에 설명하겠지만, 자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있습니다. 앞에서 설명한 함수 선언문이나 함수 표현식 방식도 Function() 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로 Function() 생성자 함수로 함수를 생성하는 문법은 다음과 같습니다.

```javascript
new Function(arg1, arg2, ..., argN, functionBody)
```
- arg1, arg2, argN - 함수의 매개변수
- functionBody - 함수가 호출될 때 실행할 코드를 포함한 문자열

이 방식을 사용해서 작성한 add 함수는 다음과 같습니다.
```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3.4)); // 출력값 : 7
```

하지만 일반적으로 Function() 생성자 함수를 사용한 함수 생성 방법은 자주 사용되지 않으므로 본서에서는 더 이상 다루지 않겠습니다. 이러한 문법은 실제 사용하기보다는 다른 사람이 작성한 소스를 분석할 때 나오는 경우가 있으므로 상식 수준으로 알아두도록 하겠습니다.

## 함수 호이스팅
지금까지 자바스크립트에서 함수를 생성하는 3가지 방법을 살펴봤습니다. 코드는 약간씩 다르지만 서로 모두 같은 기능의 함수를 생성함을 확인할 수 있습니다. 하지만 이들 사이에는 동작 방식의 약간 차이가 있습니다. 그중의 하나가 바로 함수 호이스팅 입니다.

자바스크립트 Guru로 알려진 더글라스 크락포드는 함수 생성에 있어서 그의 저서 `더글라스 크락포드의 자바스크립트 핵심 가이드`에서 함수 표현식만을 사용할 것을 권하고 있습니다. 그 이유 중의 하나가 바로 함수 호이스팅 때문입니다. 다음 예제를 살펴보겠습니다.

```javascript
add(2,3); // 출력값 : 5


function add(x, y){
    return x + y;
}

add(3,4); // 출력값 : 7 
```

위의 add() 함수 호출 부분은 함수가 정의되지 않았음에도 정의된 add()함수를 호출하는 것이 가능합니다. 이것은 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유효범위는 코드의 맨 처음부터 시작한다는 것을 확인할 수 있습니다. 이것을 함수 호이팅이라고 부릅니다.

더글라스 크락포드는 이러한 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적하였습니다. 함수 표현식을 권장하고 있습니다. 아래 예제를 보면 함수 표현식 형태로 add() 함수를 정의하면 실행결과는 다르게 됩니다.

```javascript
add(2,3); // uncaught type error

// 함수 표현식 형태로 add() 함수 정의
var add = function(x, y){
    return x + y;
} 

add(3, 4); // 7
```

add() 함수는 함수 표현식 형태로 정의되어 있어 호이스팅이 일어나지 않습니다. 따라서 맨 아래와 같이 함수가 생성된 이후에 호출이 가능합니다. 맨 위에서 add() 함수를 호출한 시점에서 아직 add() 함수가 생성되기 전이므로 uncaught type error 에러가 발생합니다.

이러한 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리돼서 진행되기 때문입니다.


## 함수 객체: 함수도 객체다
자바스크립트에서는 함수도 객체입니다. 즉, 함수의 기본 기능인 코드 실행뿐만 아니라, 함수 자체가 일반 객체처럼 프로퍼티들을 가질 수 있다는 것입니다. 아래 예제 코드를 보겠습니다.

```javascript
// 함수 선언 방식으로 add() 함수 정의
function add(x, y){
    return x + y;
}

// add() 함수 객체에 result, status 프로퍼티 추가
add.result = add(3, 2);
add.status = 'OK';

console.log(add.result); // 출력값: 5
console.log(add.status); // 출력값: 'OK'
``` 

위의 코드는 add() 함수가 일반 객체처럼 result, status 프로퍼티를 추가하는게 가능하다는 것을 보여줍니다.

> add() 함수를 생성할 때 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장됩니다. add() 함수 객체의 status 프로퍼티도 일반 객체에서의 접근 방식처럼 add.status를 이용해 접근 가능합니다.

## 변수나 프로퍼티의 값으로 할당
함수는 숫자나 문자열처럼 변수나 프로퍼티의 값으로 할당될 수 있습니다. 아래 예제를 살펴보겠습니다.

```java
// 변수에 함수 할당
var foo = 100;
var bar = function () {return 100; };
console.log(bar()); // 출력값: 100

// 프로퍼티에 함수 할당
var obj= {};
obj.baz = function () {return 200; };
console.log(obj.baz()); // 출력값: 200
```

## 함수 인자로 전달
함수는 다른 함수의 인자로도 전달이 가능합니다. 다음 예제를 보겠습니다. foo()는 함수 표현식 방법으로 생성한 함수로서, 인자로 받은 func 함수를 내부에서 함수 호출 연산자를() 붙여 호출하는 기능을 합니다.

```javascript
// 함수 표현식으로 foo() 함수 생성
var foo = function(func){
    func();
};

// foo() 함수 실행
foo(function(){
    console.log('Function can be used as the argument.');
});
```
foo() 함수를 호출할 때, 함수 리터럴 방식으로 생성한 익명 함수 func 인자로 넘겼습니다. 따라서 foo() 함수 내부에서는 func 매개변수로 인자에 넘겨진 함수를 호출할 수 있습니다. 출력결과를 보면 알 수 있듯이 인자로 넘긴 익명 함수가 foo() 함수 내부에서 제대로 호출된 것을 알 수 있습니다.

## 리턴값으로 활용
함수는 다른 함수의 리턴값으로도 활용할 수 있습니다. 다음 예제에서 foo() 함수는 console.log()를 이용해 출력하는 간단한 익명 함수를 리턴하는 역할을 합니다. 이것이 가능한 이유 또한 함수 자체가 값으로 취급되기 때문입니다.

```javascript
var foo = function(){
    return function(){
        console.log('this function is the return value.')
    };
};

var bar = foo();
bar();
```
