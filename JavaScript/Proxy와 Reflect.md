# Proxy와 Reflect

Proxy는 특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 작업을 중간에 가로채는 객체로, 가로채진 작업은 Proxy 자체에서 처리되기도 하고, 원래 객체가 처리하도록 그대로 전달되기도 합니다.

프락시는 다양한 라이브러리와 몇몇 브라우저 프레임워크에서 사용되고 있습니다. 

문법:

```javascript
let proxy = new Proxy(target, handler);
```

- target: 감싸게 될 객체로, 함수를 포함한 모든 객체가 가능합니다.
- handler: 동작을 가로채는 메서드인 `트랩(trap)`이 담긴 객체로, 여기서 프락시를 설정합니다. (get 트랩은 target의 프로퍼티를 읽을 때, set 트랩은 target의 프로퍼티를 쓸 때 활성화 됩니다.)

proxy에 작업이 가해지고, handler에 상응하는 트랩이 있으면 트랩이 실행되어 프락시가 이 작업을 처리할 기회를 얻게 됩니다. 트랩이 없으면 작업은 target에 직접 수행됩니다.

먼저, 트랩이 없는 프락시를 사용한 예시를 살펴보겠습니다.

```javascript
let target = {};
let proxy = new Proxy(target, {}); // 빈 핸들러

proxy.test = 5; // 프락시에 값을 씁니다.
alert(target.test); // 5, target에 새로운 프로퍼티가 생겼습니다.

alert(proxy.test); // 5, 프락시를 사용해 값을 읽을 수도 있습니다.

for(let key in proxy) alert(key); // test, 반복도 잘 동작합니다.
```

위 예시의 프락시엔 트랩이 없기 때문에 proxy에 가해지는 모든 작업은 target에 전달됩니다.

1. prxoy.test=를 이용해 값을 쓰면 target에 새로운 값이 설정됩니다.
2. proxy.test를 이용해 값을 읽으면 target에서 값을 읽어옵니다.
3. proxy를 대상으로 반복 작업을 하면 target에 저장된 값이 반환됩니다.

아래 그림에서 볼 수 있듯이 트랩이 없으면 proxy는 target을 뚤러싸는 투명한 래퍼가 됩니다.

![image](https://user-images.githubusercontent.com/22395934/103357910-a7f28b00-4af7-11eb-9aba-d2c756a677e9.png)

Proxy는 일반 객체와는 다른 행동 양상을 보이는 `특수 객체`입니다. 프로퍼티가 없습니다. handler가 비어있으면 Proxy에 가해지는 작업은 target에 곧 바로 전달됩니다.

그 전에 먼저, 트랩을 추가해 Proxy의 기능을 활성화 해보겠습니다.

트랩을 사용해 가로챌 수 있는 작업이 무엇이 있는지 살펴보겠습니다.

객체에 어떤 작업을 할 땐, 자바스크립트 명세서에 정의된 `내부 메서드가 깊숙한 곳에 관여 합니다` 프로퍼티를 읽을 땐 [[Get]]이란 내부 메서드가, 프로퍼티에 쓸 땐 [[Set]]이라는 내부 메서드가 관여하게 됩니다. 이런 내부 메서드들은 명세서에만 정의된 메서드이기 때문에 개발자가 코드를 사용해 호출할 순 없습니다.
프락시의 트랩은 내부 메서드의 호출을 가로 챕니다. 프락시가 가로채는 내부 메서드 리스트는 명세서에서 확인할 수 있습니다.

모든 내부 메서드엔 대응하는 트랩이 있습니다. new Proxy의 handler에 매개변수로 추가할 수 있는 메서드 이름은 `핸들러 메서드` 열에서 확인할 수 있습니다.

